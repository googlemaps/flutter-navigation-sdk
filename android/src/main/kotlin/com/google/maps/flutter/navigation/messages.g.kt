// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Autogenerated from Pigeon (v25.3.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.google.maps.flutter.navigation

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private object MessagesPigeonUtils {

  fun createConnectionError(channelName: String): FlutterError {
    return FlutterError(
      "channel-error",
      "Unable to establish connection on channel: '$channelName'.",
      "",
    )
  }

  fun wrapResult(result: Any?): List<Any?> {
    return listOf(result)
  }

  fun wrapError(exception: Throwable): List<Any?> {
    return if (exception is FlutterError) {
      listOf(exception.code, exception.message, exception.details)
    } else {
      listOf(
        exception.javaClass.simpleName,
        exception.toString(),
        "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception),
      )
    }
  }

  fun deepEquals(a: Any?, b: Any?): Boolean {
    if (a is ByteArray && b is ByteArray) {
      return a.contentEquals(b)
    }
    if (a is IntArray && b is IntArray) {
      return a.contentEquals(b)
    }
    if (a is LongArray && b is LongArray) {
      return a.contentEquals(b)
    }
    if (a is DoubleArray && b is DoubleArray) {
      return a.contentEquals(b)
    }
    if (a is Array<*> && b is Array<*>) {
      return a.size == b.size && a.indices.all { deepEquals(a[it], b[it]) }
    }
    if (a is List<*> && b is List<*>) {
      return a.size == b.size && a.indices.all { deepEquals(a[it], b[it]) }
    }
    if (a is Map<*, *> && b is Map<*, *>) {
      return a.size == b.size &&
        a.all { (b as Map<Any?, Any?>).containsKey(it.key) && deepEquals(it.value, b[it.key]) }
    }
    return a == b
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 *
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError(
  val code: String,
  override val message: String? = null,
  val details: Any? = null,
) : Throwable()

/** Describes the type of map to construct. */
enum class MapViewTypeDto(val raw: Int) {
  /**
   * Navigation view supports navigation overlay, and current navigation session is displayed on the
   * map.
   */
  NAVIGATION(0),
  /** Classic map view, without navigation overlay. */
  MAP(1);

  companion object {
    fun ofRaw(raw: Int): MapViewTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Determines the initial visibility of the navigation UI on map initialization. */
enum class NavigationUIEnabledPreferenceDto(val raw: Int) {
  /** Navigation UI gets enabled if the navigation session has already been successfully started. */
  AUTOMATIC(0),
  /** Navigation UI is disabled. */
  DISABLED(1);

  companion object {
    fun ofRaw(raw: Int): NavigationUIEnabledPreferenceDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class MapTypeDto(val raw: Int) {
  NONE(0),
  NORMAL(1),
  SATELLITE(2),
  TERRAIN(3),
  HYBRID(4);

  companion object {
    fun ofRaw(raw: Int): MapTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class CameraPerspectiveDto(val raw: Int) {
  TILTED(0),
  TOP_DOWN_HEADING_UP(1),
  TOP_DOWN_NORTH_UP(2);

  companion object {
    fun ofRaw(raw: Int): CameraPerspectiveDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class MarkerEventTypeDto(val raw: Int) {
  CLICKED(0),
  INFO_WINDOW_CLICKED(1),
  INFO_WINDOW_CLOSED(2),
  INFO_WINDOW_LONG_CLICKED(3);

  companion object {
    fun ofRaw(raw: Int): MarkerEventTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class MarkerDragEventTypeDto(val raw: Int) {
  DRAG(0),
  DRAG_START(1),
  DRAG_END(2);

  companion object {
    fun ofRaw(raw: Int): MarkerDragEventTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class StrokeJointTypeDto(val raw: Int) {
  BEVEL(0),
  DEFAULT_JOINT(1),
  ROUND(2);

  companion object {
    fun ofRaw(raw: Int): StrokeJointTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PatternTypeDto(val raw: Int) {
  DASH(0),
  DOT(1),
  GAP(2);

  companion object {
    fun ofRaw(raw: Int): PatternTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class CameraEventTypeDto(val raw: Int) {
  MOVE_STARTED_BY_API(0),
  MOVE_STARTED_BY_GESTURE(1),
  ON_CAMERA_MOVE(2),
  ON_CAMERA_IDLE(3),
  ON_CAMERA_STARTED_FOLLOWING_LOCATION(4),
  ON_CAMERA_STOPPED_FOLLOWING_LOCATION(5);

  companion object {
    fun ofRaw(raw: Int): CameraEventTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class AlternateRoutesStrategyDto(val raw: Int) {
  ALL(0),
  NONE(1),
  ONE(2);

  companion object {
    fun ofRaw(raw: Int): AlternateRoutesStrategyDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RoutingStrategyDto(val raw: Int) {
  DEFAULT_BEST(0),
  DELTA_TO_TARGET_DISTANCE(1),
  SHORTER(2);

  companion object {
    fun ofRaw(raw: Int): RoutingStrategyDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class TravelModeDto(val raw: Int) {
  DRIVING(0),
  CYCLING(1),
  WALKING(2),
  TWO_WHEELER(3),
  TAXI(4);

  companion object {
    fun ofRaw(raw: Int): TravelModeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RouteStatusDto(val raw: Int) {
  INTERNAL_ERROR(0),
  STATUS_OK(1),
  ROUTE_NOT_FOUND(2),
  NETWORK_ERROR(3),
  QUOTA_EXCEEDED(4),
  API_KEY_NOT_AUTHORIZED(5),
  STATUS_CANCELED(6),
  DUPLICATE_WAYPOINTS_ERROR(7),
  NO_WAYPOINTS_ERROR(8),
  LOCATION_UNAVAILABLE(9),
  WAYPOINT_ERROR(10),
  TRAVEL_MODE_UNSUPPORTED(11),
  LOCATION_UNKNOWN(12),
  QUOTA_CHECK_FAILED(13),
  UNKNOWN(14);

  companion object {
    fun ofRaw(raw: Int): RouteStatusDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class AudioGuidanceTypeDto(val raw: Int) {
  SILENT(0),
  ALERTS_ONLY(1),
  ALERTS_AND_GUIDANCE(2);

  companion object {
    fun ofRaw(raw: Int): AudioGuidanceTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class SpeedAlertSeverityDto(val raw: Int) {
  UNKNOWN(0),
  NOT_SPEEDING(1),
  MINOR(2),
  MAJOR(3);

  companion object {
    fun ofRaw(raw: Int): SpeedAlertSeverityDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RouteSegmentTrafficDataStatusDto(val raw: Int) {
  OK(0),
  UNAVAILABLE(1);

  companion object {
    fun ofRaw(raw: Int): RouteSegmentTrafficDataStatusDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto(val raw: Int) {
  UNKNOWN(0),
  SLOWER_TRAFFIC(1),
  TRAFFIC_JAM(2);

  companion object {
    fun ofRaw(raw: Int): RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** A set of values that specify the navigation action to take. */
enum class ManeuverDto(val raw: Int) {
  /** Arrival at a destination. */
  DESTINATION(0),
  /** Starting point of the maneuver. */
  DEPART(1),
  /** Arrival at a destination located on the left side of the road. */
  DESTINATION_LEFT(2),
  /** Arrival at a destination located on the right side of the road. */
  DESTINATION_RIGHT(3),
  /** Take the boat ferry. */
  FERRY_BOAT(4),
  /** Take the train ferry. */
  FERRY_TRAIN(5),
  /** Current road joins another road slightly on the left. */
  FORK_LEFT(6),
  /** Current road joins another road slightly on the right. */
  FORK_RIGHT(7),
  /** Current road joins another on the left. */
  MERGE_LEFT(8),
  /** Current road joins another on the right. */
  MERGE_RIGHT(9),
  /** Current road joins another. */
  MERGE_UNSPECIFIED(10),
  /** The street name changes. */
  NAME_CHANGE(11),
  /** Keep to the left side of the road when exiting a turnpike or freeway as the road diverges. */
  OFF_RAMP_KEEP_LEFT(12),
  /** Keep to the right side of the road when exiting a turnpike or freeway as the road diverges. */
  OFF_RAMP_KEEP_RIGHT(13),
  /** Regular left turn to exit a turnpike or freeway. */
  OFF_RAMP_LEFT(14),
  /** Regular right turn to exit a turnpike or freeway. */
  OFF_RAMP_RIGHT(15),
  /** Sharp left turn to exit a turnpike or freeway. */
  OFF_RAMP_SHARP_LEFT(16),
  /** Sharp right turn to exit a turnpike or freeway. */
  OFF_RAMP_SHARP_RIGHT(17),
  /** Slight left turn to exit a turnpike or freeway. */
  OFF_RAMP_SLIGHT_LEFT(18),
  /** Slight right turn to exit a turnpike or freeway. */
  OFF_RAMP_SLIGHT_RIGHT(19),
  /** Exit a turnpike or freeway. */
  OFF_RAMP_UNSPECIFIED(20),
  /** Clockwise turn onto the opposite side of the street to exit a turnpike or freeway. */
  OFF_RAMP_UTURN_CLOCKWISE(21),
  /** Counterclockwise turn onto the opposite side of the street to exit a turnpike or freeway. */
  OFF_RAMP_UTURN_COUNTERCLOCKWISE(22),
  /** Keep to the left side of the road when entering a turnpike or freeway as the road diverges. */
  ON_RAMP_KEEP_LEFT(23),
  /**
   * Keep to the right side of the road when entering a turnpike or freeway as the road diverges.
   */
  ON_RAMP_KEEP_RIGHT(24),
  /** Regular left turn to enter a turnpike or freeway. */
  ON_RAMP_LEFT(25),
  /** Regular right turn to enter a turnpike or freeway. */
  ON_RAMP_RIGHT(26),
  /** Sharp left turn to enter a turnpike or freeway. */
  ON_RAMP_SHARP_LEFT(27),
  /** Sharp right turn to enter a turnpike or freeway. */
  ON_RAMP_SHARP_RIGHT(28),
  /** Slight left turn to enter a turnpike or freeway. */
  ON_RAMP_SLIGHT_LEFT(29),
  /** Slight right turn to enter a turnpike or freeway. */
  ON_RAMP_SLIGHT_RIGHT(30),
  /** Enter a turnpike or freeway. */
  ON_RAMP_UNSPECIFIED(31),
  /** Clockwise turn onto the opposite side of the street to enter a turnpike or freeway. */
  ON_RAMP_UTURN_CLOCKWISE(32),
  /** Counterclockwise turn onto the opposite side of the street to enter a turnpike or freeway. */
  ON_RAMP_UTURN_COUNTERCLOCKWISE(33),
  /** Enter a roundabout in the clockwise direction. */
  ROUNDABOUT_CLOCKWISE(34),
  /** Enter a roundabout in the counterclockwise direction. */
  ROUNDABOUT_COUNTERCLOCKWISE(35),
  /** Exit a roundabout in the clockwise direction. */
  ROUNDABOUT_EXIT_CLOCKWISE(36),
  /** Exit a roundabout in the counterclockwise direction. */
  ROUNDABOUT_EXIT_COUNTERCLOCKWISE(37),
  /** Enter a roundabout in the clockwise direction and turn left. */
  ROUNDABOUT_LEFT_CLOCKWISE(38),
  /** Enter a roundabout in the counterclockwise direction and turn left. */
  ROUNDABOUT_LEFT_COUNTERCLOCKWISE(39),
  /** Enter a roundabout in the clockwise direction and turn right. */
  ROUNDABOUT_RIGHT_CLOCKWISE(40),
  /** Enter a roundabout in the counterclockwise direction and turn right. */
  ROUNDABOUT_RIGHT_COUNTERCLOCKWISE(41),
  /** Enter a roundabout in the clockwise direction and turn sharply to the left. */
  ROUNDABOUT_SHARP_LEFT_CLOCKWISE(42),
  /** Enter a roundabout in the counterclockwise direction and turn sharply to the left. */
  ROUNDABOUT_SHARP_LEFT_COUNTERCLOCKWISE(43),
  /** Enter a roundabout in the clockwise direction and turn sharply to the right. */
  ROUNDABOUT_SHARP_RIGHT_CLOCKWISE(44),
  /** Enter a roundabout in the counterclockwise direction and turn sharply to the right. */
  ROUNDABOUT_SHARP_RIGHT_COUNTERCLOCKWISE(45),
  /** Enter a roundabout in the clockwise direction and turn slightly left. */
  ROUNDABOUT_SLIGHT_LEFT_CLOCKWISE(46),
  /** Enter a roundabout in the counterclockwise direction and turn slightly to the left. */
  ROUNDABOUT_SLIGHT_LEFT_COUNTERCLOCKWISE(47),
  /** Enter a roundabout in the clockwise direction and turn slightly to the right. */
  ROUNDABOUT_SLIGHT_RIGHT_CLOCKWISE(48),
  /** Enter a roundabout in the counterclockwise direction and turn slightly to the right. */
  ROUNDABOUT_SLIGHT_RIGHT_COUNTERCLOCKWISE(49),
  /** Enter a roundabout in the clockwise direction and continue straight. */
  ROUNDABOUT_STRAIGHT_CLOCKWISE(50),
  /** Enter a roundabout in the counterclockwise direction and continue straight. */
  ROUNDABOUT_STRAIGHT_COUNTERCLOCKWISE(51),
  /**
   * Enter a roundabout in the clockwise direction and turn clockwise onto the opposite side of the
   * street.
   */
  ROUNDABOUT_UTURN_CLOCKWISE(52),
  /**
   * Enter a roundabout in the counterclockwise direction and turn counterclockwise onto the
   * opposite side of the street.
   */
  ROUNDABOUT_UTURN_COUNTERCLOCKWISE(53),
  /** Continue straight. */
  STRAIGHT(54),
  /** Keep left as the road diverges. */
  TURN_KEEP_LEFT(55),
  /** Keep right as the road diverges. */
  TURN_KEEP_RIGHT(56),
  /** Regular left turn at an intersection. */
  TURN_LEFT(57),
  /** Regular right turn at an intersection. */
  TURN_RIGHT(58),
  /** Sharp left turn at an intersection. */
  TURN_SHARP_LEFT(59),
  /** Sharp right turn at an intersection. */
  TURN_SHARP_RIGHT(60),
  /** Slight left turn at an intersection. */
  TURN_SLIGHT_LEFT(61),
  /** Slight right turn at an intersection. */
  TURN_SLIGHT_RIGHT(62),
  /** Clockwise turn onto the opposite side of the street. */
  TURN_UTURN_CLOCKWISE(63),
  /** Counterclockwise turn onto the opposite side of the street. */
  TURN_UTURN_COUNTERCLOCKWISE(64),
  /** Unknown maneuver. */
  UNKNOWN(65);

  companion object {
    fun ofRaw(raw: Int): ManeuverDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Whether this step is on a drive-on-right or drive-on-left route. */
enum class DrivingSideDto(val raw: Int) {
  /** Drive-on-left side. */
  LEFT(0),
  /** Unspecified side. */
  NONE(1),
  /** Drive-on-right side. */
  RIGHT(2);

  companion object {
    fun ofRaw(raw: Int): DrivingSideDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The state of navigation. */
enum class NavStateDto(val raw: Int) {
  /** Actively navigating. */
  ENROUTE(0),
  /** Actively navigating but searching for a new route. */
  REROUTING(1),
  /** Navigation has ended. */
  STOPPED(2),
  /** Error or unspecified state. */
  UNKNOWN(3);

  companion object {
    fun ofRaw(raw: Int): NavStateDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** A set of values that specify the shape of the road path continuing from the Lane. */
enum class LaneShapeDto(val raw: Int) {
  /** Normal left turn (45-135 degrees). */
  NORMAL_LEFT(0),
  /** Normal right turn (45-135 degrees). */
  NORMAL_RIGHT(1),
  /** Sharp left turn (135-175 degrees). */
  SHARP_LEFT(2),
  /** Sharp right turn (135-175 degrees). */
  SHARP_RIGHT(3),
  /** Slight left turn (10-45 degrees). */
  SLIGHT_LEFT(4),
  /** Slight right turn (10-45 degrees). */
  SLIGHT_RIGHT(5),
  /** No turn. */
  STRAIGHT(6),
  /** Shape is unknown. */
  UNKNOWN(7),
  /** A left turn onto the opposite side of the same street (175-180 degrees). */
  U_TURN_LEFT(8),
  /** A right turn onto the opposite side of the same street (175-180 degrees). */
  U_TURN_RIGHT(9);

  companion object {
    fun ofRaw(raw: Int): LaneShapeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Determines how application should behave when a application task is removed. */
enum class TaskRemovedBehaviorDto(val raw: Int) {
  /**
   * The default state, indicating that navigation guidance, location updates, and notification
   * should persist after user removes the application task.
   */
  CONTINUE_SERVICE(0),
  /**
   * Indicates that navigation guidance, location updates, and notification should shut down
   * immediately when the user removes the application task.
   */
  QUIT_SERVICE(1);

  companion object {
    fun ofRaw(raw: Int): TaskRemovedBehaviorDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Object containing map options used to initialize Google Map view.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MapOptionsDto(
  /** The initial positioning of the camera in the map view. */
  val cameraPosition: CameraPositionDto,
  /** The type of map to display (e.g., satellite, terrain, hybrid, etc.). */
  val mapType: MapTypeDto,
  /** If true, enables the compass. */
  val compassEnabled: Boolean,
  /** If true, enables the rotation gestures. */
  val rotateGesturesEnabled: Boolean,
  /** If true, enables the scroll gestures. */
  val scrollGesturesEnabled: Boolean,
  /** If true, enables the tilt gestures. */
  val tiltGesturesEnabled: Boolean,
  /** If true, enables the zoom gestures. */
  val zoomGesturesEnabled: Boolean,
  /** If true, enables the scroll gestures during rotate or zoom. */
  val scrollGesturesEnabledDuringRotateOrZoom: Boolean,
  /** If true, enables the map toolbar. */
  val mapToolbarEnabled: Boolean,
  /** The minimum zoom level that can be set for the map. */
  val minZoomPreference: Double? = null,
  /** The maximum zoom level that can be set for the map. */
  val maxZoomPreference: Double? = null,
  /** If true, enables zoom controls for the map. */
  val zoomControlsEnabled: Boolean,
  /**
   * Specifies a bounds to constrain the camera target, so that when users scroll and pan the map,
   * the camera target does not move outside these bounds.
   */
  val cameraTargetBounds: LatLngBoundsDto? = null,
  /** Specifies the padding for the map. */
  val padding: MapPaddingDto? = null,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): MapOptionsDto {
      val cameraPosition = pigeonVar_list[0] as CameraPositionDto
      val mapType = pigeonVar_list[1] as MapTypeDto
      val compassEnabled = pigeonVar_list[2] as Boolean
      val rotateGesturesEnabled = pigeonVar_list[3] as Boolean
      val scrollGesturesEnabled = pigeonVar_list[4] as Boolean
      val tiltGesturesEnabled = pigeonVar_list[5] as Boolean
      val zoomGesturesEnabled = pigeonVar_list[6] as Boolean
      val scrollGesturesEnabledDuringRotateOrZoom = pigeonVar_list[7] as Boolean
      val mapToolbarEnabled = pigeonVar_list[8] as Boolean
      val minZoomPreference = pigeonVar_list[9] as Double?
      val maxZoomPreference = pigeonVar_list[10] as Double?
      val zoomControlsEnabled = pigeonVar_list[11] as Boolean
      val cameraTargetBounds = pigeonVar_list[12] as LatLngBoundsDto?
      val padding = pigeonVar_list[13] as MapPaddingDto?
      return MapOptionsDto(
        cameraPosition,
        mapType,
        compassEnabled,
        rotateGesturesEnabled,
        scrollGesturesEnabled,
        tiltGesturesEnabled,
        zoomGesturesEnabled,
        scrollGesturesEnabledDuringRotateOrZoom,
        mapToolbarEnabled,
        minZoomPreference,
        maxZoomPreference,
        zoomControlsEnabled,
        cameraTargetBounds,
        padding,
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf(
      cameraPosition,
      mapType,
      compassEnabled,
      rotateGesturesEnabled,
      scrollGesturesEnabled,
      tiltGesturesEnabled,
      zoomGesturesEnabled,
      scrollGesturesEnabledDuringRotateOrZoom,
      mapToolbarEnabled,
      minZoomPreference,
      maxZoomPreference,
      zoomControlsEnabled,
      cameraTargetBounds,
      padding,
    )
  }

  override fun equals(other: Any?): Boolean {
    if (other !is MapOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Object containing navigation options used to initialize Google Navigation view.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class NavigationViewOptionsDto(
  /** Determines the initial visibility of the navigation UI on map initialization. */
  val navigationUIEnabledPreference: NavigationUIEnabledPreferenceDto
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): NavigationViewOptionsDto {
      val navigationUIEnabledPreference = pigeonVar_list[0] as NavigationUIEnabledPreferenceDto
      return NavigationViewOptionsDto(navigationUIEnabledPreference)
    }
  }

  fun toList(): List<Any?> {
    return listOf(navigationUIEnabledPreference)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is NavigationViewOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * A message for creating a new navigation view.
 *
 * This message is used to initialize a new navigation view with a specified initial parameters.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ViewCreationOptionsDto(
  val mapViewType: MapViewTypeDto,
  val mapOptions: MapOptionsDto,
  val navigationViewOptions: NavigationViewOptionsDto? = null,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ViewCreationOptionsDto {
      val mapViewType = pigeonVar_list[0] as MapViewTypeDto
      val mapOptions = pigeonVar_list[1] as MapOptionsDto
      val navigationViewOptions = pigeonVar_list[2] as NavigationViewOptionsDto?
      return ViewCreationOptionsDto(mapViewType, mapOptions, navigationViewOptions)
    }
  }

  fun toList(): List<Any?> {
    return listOf(mapViewType, mapOptions, navigationViewOptions)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is ViewCreationOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class CameraPositionDto(
  val bearing: Double,
  val target: LatLngDto,
  val tilt: Double,
  val zoom: Double,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CameraPositionDto {
      val bearing = pigeonVar_list[0] as Double
      val target = pigeonVar_list[1] as LatLngDto
      val tilt = pigeonVar_list[2] as Double
      val zoom = pigeonVar_list[3] as Double
      return CameraPositionDto(bearing, target, tilt, zoom)
    }
  }

  fun toList(): List<Any?> {
    return listOf(bearing, target, tilt, zoom)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is CameraPositionDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class MarkerDto(
  /** Identifies marker */
  val markerId: String,
  /** Options for marker */
  val options: MarkerOptionsDto,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): MarkerDto {
      val markerId = pigeonVar_list[0] as String
      val options = pigeonVar_list[1] as MarkerOptionsDto
      return MarkerDto(markerId, options)
    }
  }

  fun toList(): List<Any?> {
    return listOf(markerId, options)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is MarkerDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class MarkerOptionsDto(
  val alpha: Double,
  val anchor: MarkerAnchorDto,
  val draggable: Boolean,
  val flat: Boolean,
  val consumeTapEvents: Boolean,
  val position: LatLngDto,
  val rotation: Double,
  val infoWindow: InfoWindowDto,
  val visible: Boolean,
  val zIndex: Double,
  val icon: ImageDescriptorDto,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): MarkerOptionsDto {
      val alpha = pigeonVar_list[0] as Double
      val anchor = pigeonVar_list[1] as MarkerAnchorDto
      val draggable = pigeonVar_list[2] as Boolean
      val flat = pigeonVar_list[3] as Boolean
      val consumeTapEvents = pigeonVar_list[4] as Boolean
      val position = pigeonVar_list[5] as LatLngDto
      val rotation = pigeonVar_list[6] as Double
      val infoWindow = pigeonVar_list[7] as InfoWindowDto
      val visible = pigeonVar_list[8] as Boolean
      val zIndex = pigeonVar_list[9] as Double
      val icon = pigeonVar_list[10] as ImageDescriptorDto
      return MarkerOptionsDto(
        alpha,
        anchor,
        draggable,
        flat,
        consumeTapEvents,
        position,
        rotation,
        infoWindow,
        visible,
        zIndex,
        icon,
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf(
      alpha,
      anchor,
      draggable,
      flat,
      consumeTapEvents,
      position,
      rotation,
      infoWindow,
      visible,
      zIndex,
      icon,
    )
  }

  override fun equals(other: Any?): Boolean {
    if (other !is MarkerOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ImageDescriptorDto(
  val registeredImageId: String? = null,
  val imagePixelRatio: Double? = null,
  val width: Double? = null,
  val height: Double? = null,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ImageDescriptorDto {
      val registeredImageId = pigeonVar_list[0] as String?
      val imagePixelRatio = pigeonVar_list[1] as Double?
      val width = pigeonVar_list[2] as Double?
      val height = pigeonVar_list[3] as Double?
      return ImageDescriptorDto(registeredImageId, imagePixelRatio, width, height)
    }
  }

  fun toList(): List<Any?> {
    return listOf(registeredImageId, imagePixelRatio, width, height)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is ImageDescriptorDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class InfoWindowDto(
  val title: String? = null,
  val snippet: String? = null,
  val anchor: MarkerAnchorDto,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): InfoWindowDto {
      val title = pigeonVar_list[0] as String?
      val snippet = pigeonVar_list[1] as String?
      val anchor = pigeonVar_list[2] as MarkerAnchorDto
      return InfoWindowDto(title, snippet, anchor)
    }
  }

  fun toList(): List<Any?> {
    return listOf(title, snippet, anchor)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is InfoWindowDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class MarkerAnchorDto(val u: Double, val v: Double) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): MarkerAnchorDto {
      val u = pigeonVar_list[0] as Double
      val v = pigeonVar_list[1] as Double
      return MarkerAnchorDto(u, v)
    }
  }

  fun toList(): List<Any?> {
    return listOf(u, v)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is MarkerAnchorDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PolygonDto(val polygonId: String, val options: PolygonOptionsDto) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PolygonDto {
      val polygonId = pigeonVar_list[0] as String
      val options = pigeonVar_list[1] as PolygonOptionsDto
      return PolygonDto(polygonId, options)
    }
  }

  fun toList(): List<Any?> {
    return listOf(polygonId, options)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is PolygonDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PolygonOptionsDto(
  val points: List<LatLngDto?>,
  val holes: List<PolygonHoleDto?>,
  val clickable: Boolean,
  val fillColor: Long,
  val geodesic: Boolean,
  val strokeColor: Long,
  val strokeWidth: Double,
  val visible: Boolean,
  val zIndex: Double,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PolygonOptionsDto {
      val points = pigeonVar_list[0] as List<LatLngDto?>
      val holes = pigeonVar_list[1] as List<PolygonHoleDto?>
      val clickable = pigeonVar_list[2] as Boolean
      val fillColor = pigeonVar_list[3] as Long
      val geodesic = pigeonVar_list[4] as Boolean
      val strokeColor = pigeonVar_list[5] as Long
      val strokeWidth = pigeonVar_list[6] as Double
      val visible = pigeonVar_list[7] as Boolean
      val zIndex = pigeonVar_list[8] as Double
      return PolygonOptionsDto(
        points,
        holes,
        clickable,
        fillColor,
        geodesic,
        strokeColor,
        strokeWidth,
        visible,
        zIndex,
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf(
      points,
      holes,
      clickable,
      fillColor,
      geodesic,
      strokeColor,
      strokeWidth,
      visible,
      zIndex,
    )
  }

  override fun equals(other: Any?): Boolean {
    if (other !is PolygonOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PolygonHoleDto(val points: List<LatLngDto?>) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PolygonHoleDto {
      val points = pigeonVar_list[0] as List<LatLngDto?>
      return PolygonHoleDto(points)
    }
  }

  fun toList(): List<Any?> {
    return listOf(points)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is PolygonHoleDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class StyleSpanStrokeStyleDto(
  val solidColor: Long? = null,
  val fromColor: Long? = null,
  val toColor: Long? = null,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): StyleSpanStrokeStyleDto {
      val solidColor = pigeonVar_list[0] as Long?
      val fromColor = pigeonVar_list[1] as Long?
      val toColor = pigeonVar_list[2] as Long?
      return StyleSpanStrokeStyleDto(solidColor, fromColor, toColor)
    }
  }

  fun toList(): List<Any?> {
    return listOf(solidColor, fromColor, toColor)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is StyleSpanStrokeStyleDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class StyleSpanDto(val length: Double, val style: StyleSpanStrokeStyleDto) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): StyleSpanDto {
      val length = pigeonVar_list[0] as Double
      val style = pigeonVar_list[1] as StyleSpanStrokeStyleDto
      return StyleSpanDto(length, style)
    }
  }

  fun toList(): List<Any?> {
    return listOf(length, style)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is StyleSpanDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PolylineDto(val polylineId: String, val options: PolylineOptionsDto) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PolylineDto {
      val polylineId = pigeonVar_list[0] as String
      val options = pigeonVar_list[1] as PolylineOptionsDto
      return PolylineDto(polylineId, options)
    }
  }

  fun toList(): List<Any?> {
    return listOf(polylineId, options)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is PolylineDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PatternItemDto(val type: PatternTypeDto, val length: Double? = null) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PatternItemDto {
      val type = pigeonVar_list[0] as PatternTypeDto
      val length = pigeonVar_list[1] as Double?
      return PatternItemDto(type, length)
    }
  }

  fun toList(): List<Any?> {
    return listOf(type, length)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is PatternItemDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PolylineOptionsDto(
  val points: List<LatLngDto?>? = null,
  val clickable: Boolean? = null,
  val geodesic: Boolean? = null,
  val strokeColor: Long? = null,
  val strokeJointType: StrokeJointTypeDto? = null,
  val strokePattern: List<PatternItemDto?>? = null,
  val strokeWidth: Double? = null,
  val visible: Boolean? = null,
  val zIndex: Double? = null,
  val spans: List<StyleSpanDto?>,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PolylineOptionsDto {
      val points = pigeonVar_list[0] as List<LatLngDto?>?
      val clickable = pigeonVar_list[1] as Boolean?
      val geodesic = pigeonVar_list[2] as Boolean?
      val strokeColor = pigeonVar_list[3] as Long?
      val strokeJointType = pigeonVar_list[4] as StrokeJointTypeDto?
      val strokePattern = pigeonVar_list[5] as List<PatternItemDto?>?
      val strokeWidth = pigeonVar_list[6] as Double?
      val visible = pigeonVar_list[7] as Boolean?
      val zIndex = pigeonVar_list[8] as Double?
      val spans = pigeonVar_list[9] as List<StyleSpanDto?>
      return PolylineOptionsDto(
        points,
        clickable,
        geodesic,
        strokeColor,
        strokeJointType,
        strokePattern,
        strokeWidth,
        visible,
        zIndex,
        spans,
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf(
      points,
      clickable,
      geodesic,
      strokeColor,
      strokeJointType,
      strokePattern,
      strokeWidth,
      visible,
      zIndex,
      spans,
    )
  }

  override fun equals(other: Any?): Boolean {
    if (other !is PolylineOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class CircleDto(
  /** Identifies circle. */
  val circleId: String,
  /** Options for circle. */
  val options: CircleOptionsDto,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CircleDto {
      val circleId = pigeonVar_list[0] as String
      val options = pigeonVar_list[1] as CircleOptionsDto
      return CircleDto(circleId, options)
    }
  }

  fun toList(): List<Any?> {
    return listOf(circleId, options)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is CircleDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class CircleOptionsDto(
  val position: LatLngDto,
  val radius: Double,
  val strokeWidth: Double,
  val strokeColor: Long,
  val strokePattern: List<PatternItemDto?>,
  val fillColor: Long,
  val zIndex: Double,
  val visible: Boolean,
  val clickable: Boolean,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CircleOptionsDto {
      val position = pigeonVar_list[0] as LatLngDto
      val radius = pigeonVar_list[1] as Double
      val strokeWidth = pigeonVar_list[2] as Double
      val strokeColor = pigeonVar_list[3] as Long
      val strokePattern = pigeonVar_list[4] as List<PatternItemDto?>
      val fillColor = pigeonVar_list[5] as Long
      val zIndex = pigeonVar_list[6] as Double
      val visible = pigeonVar_list[7] as Boolean
      val clickable = pigeonVar_list[8] as Boolean
      return CircleOptionsDto(
        position,
        radius,
        strokeWidth,
        strokeColor,
        strokePattern,
        fillColor,
        zIndex,
        visible,
        clickable,
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf(
      position,
      radius,
      strokeWidth,
      strokeColor,
      strokePattern,
      fillColor,
      zIndex,
      visible,
      clickable,
    )
  }

  override fun equals(other: Any?): Boolean {
    if (other !is CircleOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class MapPaddingDto(val top: Long, val left: Long, val bottom: Long, val right: Long) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): MapPaddingDto {
      val top = pigeonVar_list[0] as Long
      val left = pigeonVar_list[1] as Long
      val bottom = pigeonVar_list[2] as Long
      val right = pigeonVar_list[3] as Long
      return MapPaddingDto(top, left, bottom, right)
    }
  }

  fun toList(): List<Any?> {
    return listOf(top, left, bottom, right)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is MapPaddingDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RouteTokenOptionsDto(val routeToken: String, val travelMode: TravelModeDto? = null) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RouteTokenOptionsDto {
      val routeToken = pigeonVar_list[0] as String
      val travelMode = pigeonVar_list[1] as TravelModeDto?
      return RouteTokenOptionsDto(routeToken, travelMode)
    }
  }

  fun toList(): List<Any?> {
    return listOf(routeToken, travelMode)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is RouteTokenOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class DestinationsDto(
  val waypoints: List<NavigationWaypointDto?>,
  val displayOptions: NavigationDisplayOptionsDto,
  val routingOptions: RoutingOptionsDto? = null,
  val routeTokenOptions: RouteTokenOptionsDto? = null,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): DestinationsDto {
      val waypoints = pigeonVar_list[0] as List<NavigationWaypointDto?>
      val displayOptions = pigeonVar_list[1] as NavigationDisplayOptionsDto
      val routingOptions = pigeonVar_list[2] as RoutingOptionsDto?
      val routeTokenOptions = pigeonVar_list[3] as RouteTokenOptionsDto?
      return DestinationsDto(waypoints, displayOptions, routingOptions, routeTokenOptions)
    }
  }

  fun toList(): List<Any?> {
    return listOf(waypoints, displayOptions, routingOptions, routeTokenOptions)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is DestinationsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RoutingOptionsDto(
  val alternateRoutesStrategy: AlternateRoutesStrategyDto? = null,
  val routingStrategy: RoutingStrategyDto? = null,
  val targetDistanceMeters: List<Long?>? = null,
  val travelMode: TravelModeDto? = null,
  val avoidTolls: Boolean? = null,
  val avoidFerries: Boolean? = null,
  val avoidHighways: Boolean? = null,
  val locationTimeoutMs: Long? = null,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RoutingOptionsDto {
      val alternateRoutesStrategy = pigeonVar_list[0] as AlternateRoutesStrategyDto?
      val routingStrategy = pigeonVar_list[1] as RoutingStrategyDto?
      val targetDistanceMeters = pigeonVar_list[2] as List<Long?>?
      val travelMode = pigeonVar_list[3] as TravelModeDto?
      val avoidTolls = pigeonVar_list[4] as Boolean?
      val avoidFerries = pigeonVar_list[5] as Boolean?
      val avoidHighways = pigeonVar_list[6] as Boolean?
      val locationTimeoutMs = pigeonVar_list[7] as Long?
      return RoutingOptionsDto(
        alternateRoutesStrategy,
        routingStrategy,
        targetDistanceMeters,
        travelMode,
        avoidTolls,
        avoidFerries,
        avoidHighways,
        locationTimeoutMs,
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf(
      alternateRoutesStrategy,
      routingStrategy,
      targetDistanceMeters,
      travelMode,
      avoidTolls,
      avoidFerries,
      avoidHighways,
      locationTimeoutMs,
    )
  }

  override fun equals(other: Any?): Boolean {
    if (other !is RoutingOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class NavigationDisplayOptionsDto(
  val showDestinationMarkers: Boolean? = null,
  val showStopSigns: Boolean? = null,
  val showTrafficLights: Boolean? = null,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): NavigationDisplayOptionsDto {
      val showDestinationMarkers = pigeonVar_list[0] as Boolean?
      val showStopSigns = pigeonVar_list[1] as Boolean?
      val showTrafficLights = pigeonVar_list[2] as Boolean?
      return NavigationDisplayOptionsDto(showDestinationMarkers, showStopSigns, showTrafficLights)
    }
  }

  fun toList(): List<Any?> {
    return listOf(showDestinationMarkers, showStopSigns, showTrafficLights)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is NavigationDisplayOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class NavigationWaypointDto(
  val title: String,
  val target: LatLngDto? = null,
  val placeID: String? = null,
  val preferSameSideOfRoad: Boolean? = null,
  val preferredSegmentHeading: Long? = null,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): NavigationWaypointDto {
      val title = pigeonVar_list[0] as String
      val target = pigeonVar_list[1] as LatLngDto?
      val placeID = pigeonVar_list[2] as String?
      val preferSameSideOfRoad = pigeonVar_list[3] as Boolean?
      val preferredSegmentHeading = pigeonVar_list[4] as Long?
      return NavigationWaypointDto(
        title,
        target,
        placeID,
        preferSameSideOfRoad,
        preferredSegmentHeading,
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf(title, target, placeID, preferSameSideOfRoad, preferredSegmentHeading)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is NavigationWaypointDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class NavigationTimeAndDistanceDto(val time: Double, val distance: Double) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): NavigationTimeAndDistanceDto {
      val time = pigeonVar_list[0] as Double
      val distance = pigeonVar_list[1] as Double
      return NavigationTimeAndDistanceDto(time, distance)
    }
  }

  fun toList(): List<Any?> {
    return listOf(time, distance)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is NavigationTimeAndDistanceDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class NavigationAudioGuidanceSettingsDto(
  val isBluetoothAudioEnabled: Boolean? = null,
  val isVibrationEnabled: Boolean? = null,
  val guidanceType: AudioGuidanceTypeDto? = null,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): NavigationAudioGuidanceSettingsDto {
      val isBluetoothAudioEnabled = pigeonVar_list[0] as Boolean?
      val isVibrationEnabled = pigeonVar_list[1] as Boolean?
      val guidanceType = pigeonVar_list[2] as AudioGuidanceTypeDto?
      return NavigationAudioGuidanceSettingsDto(
        isBluetoothAudioEnabled,
        isVibrationEnabled,
        guidanceType,
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf(isBluetoothAudioEnabled, isVibrationEnabled, guidanceType)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is NavigationAudioGuidanceSettingsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SimulationOptionsDto(val speedMultiplier: Double) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SimulationOptionsDto {
      val speedMultiplier = pigeonVar_list[0] as Double
      return SimulationOptionsDto(speedMultiplier)
    }
  }

  fun toList(): List<Any?> {
    return listOf(speedMultiplier)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is SimulationOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LatLngDto(val latitude: Double, val longitude: Double) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LatLngDto {
      val latitude = pigeonVar_list[0] as Double
      val longitude = pigeonVar_list[1] as Double
      return LatLngDto(latitude, longitude)
    }
  }

  fun toList(): List<Any?> {
    return listOf(latitude, longitude)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is LatLngDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LatLngBoundsDto(val southwest: LatLngDto, val northeast: LatLngDto) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LatLngBoundsDto {
      val southwest = pigeonVar_list[0] as LatLngDto
      val northeast = pigeonVar_list[1] as LatLngDto
      return LatLngBoundsDto(southwest, northeast)
    }
  }

  fun toList(): List<Any?> {
    return listOf(southwest, northeast)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is LatLngBoundsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SpeedingUpdatedEventDto(
  val percentageAboveLimit: Double,
  val severity: SpeedAlertSeverityDto,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SpeedingUpdatedEventDto {
      val percentageAboveLimit = pigeonVar_list[0] as Double
      val severity = pigeonVar_list[1] as SpeedAlertSeverityDto
      return SpeedingUpdatedEventDto(percentageAboveLimit, severity)
    }
  }

  fun toList(): List<Any?> {
    return listOf(percentageAboveLimit, severity)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is SpeedingUpdatedEventDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SpeedAlertOptionsThresholdPercentageDto(
  val percentage: Double,
  val severity: SpeedAlertSeverityDto,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SpeedAlertOptionsThresholdPercentageDto {
      val percentage = pigeonVar_list[0] as Double
      val severity = pigeonVar_list[1] as SpeedAlertSeverityDto
      return SpeedAlertOptionsThresholdPercentageDto(percentage, severity)
    }
  }

  fun toList(): List<Any?> {
    return listOf(percentage, severity)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is SpeedAlertOptionsThresholdPercentageDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SpeedAlertOptionsDto(
  val severityUpgradeDurationSeconds: Double,
  val minorSpeedAlertThresholdPercentage: Double,
  val majorSpeedAlertThresholdPercentage: Double,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SpeedAlertOptionsDto {
      val severityUpgradeDurationSeconds = pigeonVar_list[0] as Double
      val minorSpeedAlertThresholdPercentage = pigeonVar_list[1] as Double
      val majorSpeedAlertThresholdPercentage = pigeonVar_list[2] as Double
      return SpeedAlertOptionsDto(
        severityUpgradeDurationSeconds,
        minorSpeedAlertThresholdPercentage,
        majorSpeedAlertThresholdPercentage,
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf(
      severityUpgradeDurationSeconds,
      minorSpeedAlertThresholdPercentage,
      majorSpeedAlertThresholdPercentage,
    )
  }

  override fun equals(other: Any?): Boolean {
    if (other !is SpeedAlertOptionsDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RouteSegmentTrafficDataRoadStretchRenderingDataDto(
  val style: RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto,
  val lengthMeters: Long,
  val offsetMeters: Long,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RouteSegmentTrafficDataRoadStretchRenderingDataDto {
      val style = pigeonVar_list[0] as RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto
      val lengthMeters = pigeonVar_list[1] as Long
      val offsetMeters = pigeonVar_list[2] as Long
      return RouteSegmentTrafficDataRoadStretchRenderingDataDto(style, lengthMeters, offsetMeters)
    }
  }

  fun toList(): List<Any?> {
    return listOf(style, lengthMeters, offsetMeters)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is RouteSegmentTrafficDataRoadStretchRenderingDataDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RouteSegmentTrafficDataDto(
  val status: RouteSegmentTrafficDataStatusDto,
  val roadStretchRenderingDataList: List<RouteSegmentTrafficDataRoadStretchRenderingDataDto?>,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RouteSegmentTrafficDataDto {
      val status = pigeonVar_list[0] as RouteSegmentTrafficDataStatusDto
      val roadStretchRenderingDataList =
        pigeonVar_list[1] as List<RouteSegmentTrafficDataRoadStretchRenderingDataDto?>
      return RouteSegmentTrafficDataDto(status, roadStretchRenderingDataList)
    }
  }

  fun toList(): List<Any?> {
    return listOf(status, roadStretchRenderingDataList)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is RouteSegmentTrafficDataDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RouteSegmentDto(
  val trafficData: RouteSegmentTrafficDataDto? = null,
  val destinationLatLng: LatLngDto,
  val latLngs: List<LatLngDto?>? = null,
  val destinationWaypoint: NavigationWaypointDto? = null,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RouteSegmentDto {
      val trafficData = pigeonVar_list[0] as RouteSegmentTrafficDataDto?
      val destinationLatLng = pigeonVar_list[1] as LatLngDto
      val latLngs = pigeonVar_list[2] as List<LatLngDto?>?
      val destinationWaypoint = pigeonVar_list[3] as NavigationWaypointDto?
      return RouteSegmentDto(trafficData, destinationLatLng, latLngs, destinationWaypoint)
    }
  }

  fun toList(): List<Any?> {
    return listOf(trafficData, destinationLatLng, latLngs, destinationWaypoint)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is RouteSegmentDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * One of the possible directions from a lane at the end of a route step, and whether it is on the
 * recommended route.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LaneDirectionDto(
  /** Shape for this lane direction. */
  val laneShape: LaneShapeDto,
  /** Whether this lane is recommended. */
  val isRecommended: Boolean,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LaneDirectionDto {
      val laneShape = pigeonVar_list[0] as LaneShapeDto
      val isRecommended = pigeonVar_list[1] as Boolean
      return LaneDirectionDto(laneShape, isRecommended)
    }
  }

  fun toList(): List<Any?> {
    return listOf(laneShape, isRecommended)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is LaneDirectionDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Single lane on the road at the end of a route step.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LaneDto(
  /**
   * List of possible directions a driver can follow when using this lane at the end of the
   * respective route step
   */
  val laneDirections: List<LaneDirectionDto?>
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LaneDto {
      val laneDirections = pigeonVar_list[0] as List<LaneDirectionDto?>
      return LaneDto(laneDirections)
    }
  }

  fun toList(): List<Any?> {
    return listOf(laneDirections)
  }

  override fun equals(other: Any?): Boolean {
    if (other !is LaneDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Information about a single step along a navigation route.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class StepInfoDto(
  /** Distance in meters from the previous step to this step. */
  val distanceFromPrevStepMeters: Long,
  /** Time in seconds from the previous step to this step. */
  val timeFromPrevStepSeconds: Long,
  /** Whether this step is on a drive-on-right or drive-on-left route. */
  val drivingSide: DrivingSideDto,
  /** The exit number if it exists. */
  val exitNumber: String? = null,
  /** The full text of the instruction for this step. */
  val fullInstructions: String,
  /** The full road name for this step. */
  val fullRoadName: String,
  /** The simplified version of the road name. */
  val simpleRoadName: String,
  /**
   * The counted number of the exit to take relative to the location where the roundabout was
   * entered.
   */
  val roundaboutTurnNumber: Long,
  /** The list of available lanes at the end of this route step. */
  val lanes: List<LaneDto?>,
  /** The maneuver for this step. */
  val maneuver: ManeuverDto,
  /** The index of the step in the list of all steps in the route. */
  val stepNumber: Long,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): StepInfoDto {
      val distanceFromPrevStepMeters = pigeonVar_list[0] as Long
      val timeFromPrevStepSeconds = pigeonVar_list[1] as Long
      val drivingSide = pigeonVar_list[2] as DrivingSideDto
      val exitNumber = pigeonVar_list[3] as String?
      val fullInstructions = pigeonVar_list[4] as String
      val fullRoadName = pigeonVar_list[5] as String
      val simpleRoadName = pigeonVar_list[6] as String
      val roundaboutTurnNumber = pigeonVar_list[7] as Long
      val lanes = pigeonVar_list[8] as List<LaneDto?>
      val maneuver = pigeonVar_list[9] as ManeuverDto
      val stepNumber = pigeonVar_list[10] as Long
      return StepInfoDto(
        distanceFromPrevStepMeters,
        timeFromPrevStepSeconds,
        drivingSide,
        exitNumber,
        fullInstructions,
        fullRoadName,
        simpleRoadName,
        roundaboutTurnNumber,
        lanes,
        maneuver,
        stepNumber,
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf(
      distanceFromPrevStepMeters,
      timeFromPrevStepSeconds,
      drivingSide,
      exitNumber,
      fullInstructions,
      fullRoadName,
      simpleRoadName,
      roundaboutTurnNumber,
      lanes,
      maneuver,
      stepNumber,
    )
  }

  override fun equals(other: Any?): Boolean {
    if (other !is StepInfoDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Contains information about the state of navigation, the current nav step if available, and
 * remaining steps if available.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class NavInfoDto(
  /** The current state of navigation. */
  val navState: NavStateDto,
  /** Information about the upcoming maneuver step. */
  val currentStep: StepInfoDto? = null,
  /** The remaining steps after the current step. */
  val remainingSteps: List<StepInfoDto?>,
  /** Whether the route has changed since the last sent message. */
  val routeChanged: Boolean,
  /** Estimated remaining distance in meters along the route to the current step. */
  val distanceToCurrentStepMeters: Long? = null,
  /**
   * The estimated remaining distance in meters to the final destination which is the last
   * destination in a multi-destination trip.
   */
  val distanceToFinalDestinationMeters: Long? = null,
  /**
   * The estimated remaining distance in meters to the next destination.
   *
   * Android only.
   */
  val distanceToNextDestinationMeters: Long? = null,
  /** The estimated remaining time in seconds along the route to the current step. */
  val timeToCurrentStepSeconds: Long? = null,
  /**
   * The estimated remaining time in seconds to the final destination which is the last destination
   * in a multi-destination trip.
   */
  val timeToFinalDestinationSeconds: Long? = null,
  /**
   * The estimated remaining time in seconds to the next destination.
   *
   * Android only.
   */
  val timeToNextDestinationSeconds: Long? = null,
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): NavInfoDto {
      val navState = pigeonVar_list[0] as NavStateDto
      val currentStep = pigeonVar_list[1] as StepInfoDto?
      val remainingSteps = pigeonVar_list[2] as List<StepInfoDto?>
      val routeChanged = pigeonVar_list[3] as Boolean
      val distanceToCurrentStepMeters = pigeonVar_list[4] as Long?
      val distanceToFinalDestinationMeters = pigeonVar_list[5] as Long?
      val distanceToNextDestinationMeters = pigeonVar_list[6] as Long?
      val timeToCurrentStepSeconds = pigeonVar_list[7] as Long?
      val timeToFinalDestinationSeconds = pigeonVar_list[8] as Long?
      val timeToNextDestinationSeconds = pigeonVar_list[9] as Long?
      return NavInfoDto(
        navState,
        currentStep,
        remainingSteps,
        routeChanged,
        distanceToCurrentStepMeters,
        distanceToFinalDestinationMeters,
        distanceToNextDestinationMeters,
        timeToCurrentStepSeconds,
        timeToFinalDestinationSeconds,
        timeToNextDestinationSeconds,
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf(
      navState,
      currentStep,
      remainingSteps,
      routeChanged,
      distanceToCurrentStepMeters,
      distanceToFinalDestinationMeters,
      distanceToNextDestinationMeters,
      timeToCurrentStepSeconds,
      timeToFinalDestinationSeconds,
      timeToNextDestinationSeconds,
    )
  }

  override fun equals(other: Any?): Boolean {
    if (other !is NavInfoDto) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())
  }

  override fun hashCode(): Int = toList().hashCode()
}

private open class messagesPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let { MapViewTypeDto.ofRaw(it.toInt()) }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          NavigationUIEnabledPreferenceDto.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let { MapTypeDto.ofRaw(it.toInt()) }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let { CameraPerspectiveDto.ofRaw(it.toInt()) }
      }
      133.toByte() -> {
        return (readValue(buffer) as Long?)?.let { MarkerEventTypeDto.ofRaw(it.toInt()) }
      }
      134.toByte() -> {
        return (readValue(buffer) as Long?)?.let { MarkerDragEventTypeDto.ofRaw(it.toInt()) }
      }
      135.toByte() -> {
        return (readValue(buffer) as Long?)?.let { StrokeJointTypeDto.ofRaw(it.toInt()) }
      }
      136.toByte() -> {
        return (readValue(buffer) as Long?)?.let { PatternTypeDto.ofRaw(it.toInt()) }
      }
      137.toByte() -> {
        return (readValue(buffer) as Long?)?.let { CameraEventTypeDto.ofRaw(it.toInt()) }
      }
      138.toByte() -> {
        return (readValue(buffer) as Long?)?.let { AlternateRoutesStrategyDto.ofRaw(it.toInt()) }
      }
      139.toByte() -> {
        return (readValue(buffer) as Long?)?.let { RoutingStrategyDto.ofRaw(it.toInt()) }
      }
      140.toByte() -> {
        return (readValue(buffer) as Long?)?.let { TravelModeDto.ofRaw(it.toInt()) }
      }
      141.toByte() -> {
        return (readValue(buffer) as Long?)?.let { RouteStatusDto.ofRaw(it.toInt()) }
      }
      142.toByte() -> {
        return (readValue(buffer) as Long?)?.let { AudioGuidanceTypeDto.ofRaw(it.toInt()) }
      }
      143.toByte() -> {
        return (readValue(buffer) as Long?)?.let { SpeedAlertSeverityDto.ofRaw(it.toInt()) }
      }
      144.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RouteSegmentTrafficDataStatusDto.ofRaw(it.toInt())
        }
      }
      145.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto.ofRaw(it.toInt())
        }
      }
      146.toByte() -> {
        return (readValue(buffer) as Long?)?.let { ManeuverDto.ofRaw(it.toInt()) }
      }
      147.toByte() -> {
        return (readValue(buffer) as Long?)?.let { DrivingSideDto.ofRaw(it.toInt()) }
      }
      148.toByte() -> {
        return (readValue(buffer) as Long?)?.let { NavStateDto.ofRaw(it.toInt()) }
      }
      149.toByte() -> {
        return (readValue(buffer) as Long?)?.let { LaneShapeDto.ofRaw(it.toInt()) }
      }
      150.toByte() -> {
        return (readValue(buffer) as Long?)?.let { TaskRemovedBehaviorDto.ofRaw(it.toInt()) }
      }
      151.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { MapOptionsDto.fromList(it) }
      }
      152.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavigationViewOptionsDto.fromList(it) }
      }
      153.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { ViewCreationOptionsDto.fromList(it) }
      }
      154.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { CameraPositionDto.fromList(it) }
      }
      155.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { MarkerDto.fromList(it) }
      }
      156.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { MarkerOptionsDto.fromList(it) }
      }
      157.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { ImageDescriptorDto.fromList(it) }
      }
      158.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { InfoWindowDto.fromList(it) }
      }
      159.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { MarkerAnchorDto.fromList(it) }
      }
      160.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PolygonDto.fromList(it) }
      }
      161.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PolygonOptionsDto.fromList(it) }
      }
      162.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PolygonHoleDto.fromList(it) }
      }
      163.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { StyleSpanStrokeStyleDto.fromList(it) }
      }
      164.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { StyleSpanDto.fromList(it) }
      }
      165.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PolylineDto.fromList(it) }
      }
      166.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PatternItemDto.fromList(it) }
      }
      167.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PolylineOptionsDto.fromList(it) }
      }
      168.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { CircleDto.fromList(it) }
      }
      169.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { CircleOptionsDto.fromList(it) }
      }
      170.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { MapPaddingDto.fromList(it) }
      }
      171.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { RouteTokenOptionsDto.fromList(it) }
      }
      172.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { DestinationsDto.fromList(it) }
      }
      173.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { RoutingOptionsDto.fromList(it) }
      }
      174.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavigationDisplayOptionsDto.fromList(it) }
      }
      175.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavigationWaypointDto.fromList(it) }
      }
      176.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavigationTimeAndDistanceDto.fromList(it) }
      }
      177.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          NavigationAudioGuidanceSettingsDto.fromList(it)
        }
      }
      178.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { SimulationOptionsDto.fromList(it) }
      }
      179.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LatLngDto.fromList(it) }
      }
      180.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LatLngBoundsDto.fromList(it) }
      }
      181.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { SpeedingUpdatedEventDto.fromList(it) }
      }
      182.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SpeedAlertOptionsThresholdPercentageDto.fromList(it)
        }
      }
      183.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { SpeedAlertOptionsDto.fromList(it) }
      }
      184.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RouteSegmentTrafficDataRoadStretchRenderingDataDto.fromList(it)
        }
      }
      185.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { RouteSegmentTrafficDataDto.fromList(it) }
      }
      186.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { RouteSegmentDto.fromList(it) }
      }
      187.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LaneDirectionDto.fromList(it) }
      }
      188.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LaneDto.fromList(it) }
      }
      189.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { StepInfoDto.fromList(it) }
      }
      190.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavInfoDto.fromList(it) }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }

  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is MapViewTypeDto -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is NavigationUIEnabledPreferenceDto -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is MapTypeDto -> {
        stream.write(131)
        writeValue(stream, value.raw)
      }
      is CameraPerspectiveDto -> {
        stream.write(132)
        writeValue(stream, value.raw)
      }
      is MarkerEventTypeDto -> {
        stream.write(133)
        writeValue(stream, value.raw)
      }
      is MarkerDragEventTypeDto -> {
        stream.write(134)
        writeValue(stream, value.raw)
      }
      is StrokeJointTypeDto -> {
        stream.write(135)
        writeValue(stream, value.raw)
      }
      is PatternTypeDto -> {
        stream.write(136)
        writeValue(stream, value.raw)
      }
      is CameraEventTypeDto -> {
        stream.write(137)
        writeValue(stream, value.raw)
      }
      is AlternateRoutesStrategyDto -> {
        stream.write(138)
        writeValue(stream, value.raw)
      }
      is RoutingStrategyDto -> {
        stream.write(139)
        writeValue(stream, value.raw)
      }
      is TravelModeDto -> {
        stream.write(140)
        writeValue(stream, value.raw)
      }
      is RouteStatusDto -> {
        stream.write(141)
        writeValue(stream, value.raw)
      }
      is AudioGuidanceTypeDto -> {
        stream.write(142)
        writeValue(stream, value.raw)
      }
      is SpeedAlertSeverityDto -> {
        stream.write(143)
        writeValue(stream, value.raw)
      }
      is RouteSegmentTrafficDataStatusDto -> {
        stream.write(144)
        writeValue(stream, value.raw)
      }
      is RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto -> {
        stream.write(145)
        writeValue(stream, value.raw)
      }
      is ManeuverDto -> {
        stream.write(146)
        writeValue(stream, value.raw)
      }
      is DrivingSideDto -> {
        stream.write(147)
        writeValue(stream, value.raw)
      }
      is NavStateDto -> {
        stream.write(148)
        writeValue(stream, value.raw)
      }
      is LaneShapeDto -> {
        stream.write(149)
        writeValue(stream, value.raw)
      }
      is TaskRemovedBehaviorDto -> {
        stream.write(150)
        writeValue(stream, value.raw)
      }
      is MapOptionsDto -> {
        stream.write(151)
        writeValue(stream, value.toList())
      }
      is NavigationViewOptionsDto -> {
        stream.write(152)
        writeValue(stream, value.toList())
      }
      is ViewCreationOptionsDto -> {
        stream.write(153)
        writeValue(stream, value.toList())
      }
      is CameraPositionDto -> {
        stream.write(154)
        writeValue(stream, value.toList())
      }
      is MarkerDto -> {
        stream.write(155)
        writeValue(stream, value.toList())
      }
      is MarkerOptionsDto -> {
        stream.write(156)
        writeValue(stream, value.toList())
      }
      is ImageDescriptorDto -> {
        stream.write(157)
        writeValue(stream, value.toList())
      }
      is InfoWindowDto -> {
        stream.write(158)
        writeValue(stream, value.toList())
      }
      is MarkerAnchorDto -> {
        stream.write(159)
        writeValue(stream, value.toList())
      }
      is PolygonDto -> {
        stream.write(160)
        writeValue(stream, value.toList())
      }
      is PolygonOptionsDto -> {
        stream.write(161)
        writeValue(stream, value.toList())
      }
      is PolygonHoleDto -> {
        stream.write(162)
        writeValue(stream, value.toList())
      }
      is StyleSpanStrokeStyleDto -> {
        stream.write(163)
        writeValue(stream, value.toList())
      }
      is StyleSpanDto -> {
        stream.write(164)
        writeValue(stream, value.toList())
      }
      is PolylineDto -> {
        stream.write(165)
        writeValue(stream, value.toList())
      }
      is PatternItemDto -> {
        stream.write(166)
        writeValue(stream, value.toList())
      }
      is PolylineOptionsDto -> {
        stream.write(167)
        writeValue(stream, value.toList())
      }
      is CircleDto -> {
        stream.write(168)
        writeValue(stream, value.toList())
      }
      is CircleOptionsDto -> {
        stream.write(169)
        writeValue(stream, value.toList())
      }
      is MapPaddingDto -> {
        stream.write(170)
        writeValue(stream, value.toList())
      }
      is RouteTokenOptionsDto -> {
        stream.write(171)
        writeValue(stream, value.toList())
      }
      is DestinationsDto -> {
        stream.write(172)
        writeValue(stream, value.toList())
      }
      is RoutingOptionsDto -> {
        stream.write(173)
        writeValue(stream, value.toList())
      }
      is NavigationDisplayOptionsDto -> {
        stream.write(174)
        writeValue(stream, value.toList())
      }
      is NavigationWaypointDto -> {
        stream.write(175)
        writeValue(stream, value.toList())
      }
      is NavigationTimeAndDistanceDto -> {
        stream.write(176)
        writeValue(stream, value.toList())
      }
      is NavigationAudioGuidanceSettingsDto -> {
        stream.write(177)
        writeValue(stream, value.toList())
      }
      is SimulationOptionsDto -> {
        stream.write(178)
        writeValue(stream, value.toList())
      }
      is LatLngDto -> {
        stream.write(179)
        writeValue(stream, value.toList())
      }
      is LatLngBoundsDto -> {
        stream.write(180)
        writeValue(stream, value.toList())
      }
      is SpeedingUpdatedEventDto -> {
        stream.write(181)
        writeValue(stream, value.toList())
      }
      is SpeedAlertOptionsThresholdPercentageDto -> {
        stream.write(182)
        writeValue(stream, value.toList())
      }
      is SpeedAlertOptionsDto -> {
        stream.write(183)
        writeValue(stream, value.toList())
      }
      is RouteSegmentTrafficDataRoadStretchRenderingDataDto -> {
        stream.write(184)
        writeValue(stream, value.toList())
      }
      is RouteSegmentTrafficDataDto -> {
        stream.write(185)
        writeValue(stream, value.toList())
      }
      is RouteSegmentDto -> {
        stream.write(186)
        writeValue(stream, value.toList())
      }
      is LaneDirectionDto -> {
        stream.write(187)
        writeValue(stream, value.toList())
      }
      is LaneDto -> {
        stream.write(188)
        writeValue(stream, value.toList())
      }
      is StepInfoDto -> {
        stream.write(189)
        writeValue(stream, value.toList())
      }
      is NavInfoDto -> {
        stream.write(190)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Dummy interface to force generation of the platform view creation params. Pigeon only generates
 * messages if the messages are used in API. [ViewCreationOptionsDto] is encoded and decoded
 * directly to generate a PlatformView creation message.
 *
 * This API should never be used directly.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface ViewCreationApi {
  fun create(msg: ViewCreationOptionsDto)

  companion object {
    /** The codec used by ViewCreationApi. */
    val codec: MessageCodec<Any?> by lazy { messagesPigeonCodec() }

    /**
     * Sets up an instance of `ViewCreationApi` to handle messages through the `binaryMessenger`.
     */
    @JvmOverloads
    fun setUp(
      binaryMessenger: BinaryMessenger,
      api: ViewCreationApi?,
      messageChannelSuffix: String = "",
    ) {
      val separatedMessageChannelSuffix =
        if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.ViewCreationApi.create$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val msgArg = args[0] as ViewCreationOptionsDto
            val wrapped: List<Any?> =
              try {
                api.create(msgArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface MapViewApi {
  fun awaitMapReady(viewId: Long, callback: (Result<Unit>) -> Unit)

  fun isMyLocationEnabled(viewId: Long): Boolean

  fun setMyLocationEnabled(viewId: Long, enabled: Boolean)

  fun getMyLocation(viewId: Long): LatLngDto?

  fun getMapType(viewId: Long): MapTypeDto

  fun setMapType(viewId: Long, mapType: MapTypeDto)

  fun setMapStyle(viewId: Long, styleJson: String)

  fun isNavigationTripProgressBarEnabled(viewId: Long): Boolean

  fun setNavigationTripProgressBarEnabled(viewId: Long, enabled: Boolean)

  fun isNavigationHeaderEnabled(viewId: Long): Boolean

  fun setNavigationHeaderEnabled(viewId: Long, enabled: Boolean)

  fun isNavigationFooterEnabled(viewId: Long): Boolean

  fun setNavigationFooterEnabled(viewId: Long, enabled: Boolean)

  fun isRecenterButtonEnabled(viewId: Long): Boolean

  fun setRecenterButtonEnabled(viewId: Long, enabled: Boolean)

  fun isSpeedLimitIconEnabled(viewId: Long): Boolean

  fun setSpeedLimitIconEnabled(viewId: Long, enabled: Boolean)

  fun isSpeedometerEnabled(viewId: Long): Boolean

  fun setSpeedometerEnabled(viewId: Long, enabled: Boolean)

  fun isNavigationUIEnabled(viewId: Long): Boolean

  fun setNavigationUIEnabled(viewId: Long, enabled: Boolean)

  fun isMyLocationButtonEnabled(viewId: Long): Boolean

  fun setMyLocationButtonEnabled(viewId: Long, enabled: Boolean)

  fun isConsumeMyLocationButtonClickEventsEnabled(viewId: Long): Boolean

  fun setConsumeMyLocationButtonClickEventsEnabled(viewId: Long, enabled: Boolean)

  fun isZoomGesturesEnabled(viewId: Long): Boolean

  fun setZoomGesturesEnabled(viewId: Long, enabled: Boolean)

  fun isZoomControlsEnabled(viewId: Long): Boolean

  fun setZoomControlsEnabled(viewId: Long, enabled: Boolean)

  fun isCompassEnabled(viewId: Long): Boolean

  fun setCompassEnabled(viewId: Long, enabled: Boolean)

  fun isRotateGesturesEnabled(viewId: Long): Boolean

  fun setRotateGesturesEnabled(viewId: Long, enabled: Boolean)

  fun isScrollGesturesEnabled(viewId: Long): Boolean

  fun setScrollGesturesEnabled(viewId: Long, enabled: Boolean)

  fun isScrollGesturesEnabledDuringRotateOrZoom(viewId: Long): Boolean

  fun setScrollGesturesDuringRotateOrZoomEnabled(viewId: Long, enabled: Boolean)

  fun isTiltGesturesEnabled(viewId: Long): Boolean

  fun setTiltGesturesEnabled(viewId: Long, enabled: Boolean)

  fun isMapToolbarEnabled(viewId: Long): Boolean

  fun setMapToolbarEnabled(viewId: Long, enabled: Boolean)

  fun isTrafficEnabled(viewId: Long): Boolean

  fun setTrafficEnabled(viewId: Long, enabled: Boolean)

  fun isTrafficIncidentCardsEnabled(viewId: Long): Boolean

  fun setTrafficIncidentCardsEnabled(viewId: Long, enabled: Boolean)

  fun isTrafficPromptsEnabled(viewId: Long): Boolean

  fun setTrafficPromptsEnabled(viewId: Long, enabled: Boolean)

  fun isReportIncidentButtonEnabled(viewId: Long): Boolean

  fun setReportIncidentButtonEnabled(viewId: Long, enabled: Boolean)

  fun getCameraPosition(viewId: Long): CameraPositionDto

  fun getVisibleRegion(viewId: Long): LatLngBoundsDto

  fun followMyLocation(viewId: Long, perspective: CameraPerspectiveDto, zoomLevel: Double?)

  fun animateCameraToCameraPosition(
    viewId: Long,
    cameraPosition: CameraPositionDto,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun animateCameraToLatLng(
    viewId: Long,
    point: LatLngDto,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun animateCameraToLatLngBounds(
    viewId: Long,
    bounds: LatLngBoundsDto,
    padding: Double,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun animateCameraToLatLngZoom(
    viewId: Long,
    point: LatLngDto,
    zoom: Double,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun animateCameraByScroll(
    viewId: Long,
    scrollByDx: Double,
    scrollByDy: Double,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun animateCameraByZoom(
    viewId: Long,
    zoomBy: Double,
    focusDx: Double?,
    focusDy: Double?,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun animateCameraToZoom(
    viewId: Long,
    zoom: Double,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun moveCameraToCameraPosition(viewId: Long, cameraPosition: CameraPositionDto)

  fun moveCameraToLatLng(viewId: Long, point: LatLngDto)

  fun moveCameraToLatLngBounds(viewId: Long, bounds: LatLngBoundsDto, padding: Double)

  fun moveCameraToLatLngZoom(viewId: Long, point: LatLngDto, zoom: Double)

  fun moveCameraByScroll(viewId: Long, scrollByDx: Double, scrollByDy: Double)

  fun moveCameraByZoom(viewId: Long, zoomBy: Double, focusDx: Double?, focusDy: Double?)

  fun moveCameraToZoom(viewId: Long, zoom: Double)

  fun showRouteOverview(viewId: Long)

  fun getMinZoomPreference(viewId: Long): Double

  fun getMaxZoomPreference(viewId: Long): Double

  fun resetMinMaxZoomPreference(viewId: Long)

  fun setMinZoomPreference(viewId: Long, minZoomPreference: Double)

  fun setMaxZoomPreference(viewId: Long, maxZoomPreference: Double)

  fun getMarkers(viewId: Long): List<MarkerDto>

  fun addMarkers(viewId: Long, markers: List<MarkerDto>): List<MarkerDto>

  fun updateMarkers(viewId: Long, markers: List<MarkerDto>): List<MarkerDto>

  fun removeMarkers(viewId: Long, markers: List<MarkerDto>)

  fun clearMarkers(viewId: Long)

  fun clear(viewId: Long)

  fun getPolygons(viewId: Long): List<PolygonDto>

  fun addPolygons(viewId: Long, polygons: List<PolygonDto>): List<PolygonDto>

  fun updatePolygons(viewId: Long, polygons: List<PolygonDto>): List<PolygonDto>

  fun removePolygons(viewId: Long, polygons: List<PolygonDto>)

  fun clearPolygons(viewId: Long)

  fun getPolylines(viewId: Long): List<PolylineDto>

  fun addPolylines(viewId: Long, polylines: List<PolylineDto>): List<PolylineDto>

  fun updatePolylines(viewId: Long, polylines: List<PolylineDto>): List<PolylineDto>

  fun removePolylines(viewId: Long, polylines: List<PolylineDto>)

  fun clearPolylines(viewId: Long)

  fun getCircles(viewId: Long): List<CircleDto>

  fun addCircles(viewId: Long, circles: List<CircleDto>): List<CircleDto>

  fun updateCircles(viewId: Long, circles: List<CircleDto>): List<CircleDto>

  fun removeCircles(viewId: Long, circles: List<CircleDto>)

  fun clearCircles(viewId: Long)

  fun enableOnCameraChangedEvents(viewId: Long)

  fun setPadding(viewId: Long, padding: MapPaddingDto)

  fun getPadding(viewId: Long): MapPaddingDto

  companion object {
    /** The codec used by MapViewApi. */
    val codec: MessageCodec<Any?> by lazy { messagesPigeonCodec() }

    /** Sets up an instance of `MapViewApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(
      binaryMessenger: BinaryMessenger,
      api: MapViewApi?,
      messageChannelSuffix: String = "",
    ) {
      val separatedMessageChannelSuffix =
        if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.awaitMapReady$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            api.awaitMapReady(viewIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                reply.reply(MessagesPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isMyLocationEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isMyLocationEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setMyLocationEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setMyLocationEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.getMyLocation$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.getMyLocation(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.getMapType$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.getMapType(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setMapType$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val mapTypeArg = args[1] as MapTypeDto
            val wrapped: List<Any?> =
              try {
                api.setMapType(viewIdArg, mapTypeArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setMapStyle$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val styleJsonArg = args[1] as String
            val wrapped: List<Any?> =
              try {
                api.setMapStyle(viewIdArg, styleJsonArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isNavigationTripProgressBarEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isNavigationTripProgressBarEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setNavigationTripProgressBarEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setNavigationTripProgressBarEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isNavigationHeaderEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isNavigationHeaderEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setNavigationHeaderEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setNavigationHeaderEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isNavigationFooterEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isNavigationFooterEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setNavigationFooterEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setNavigationFooterEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isRecenterButtonEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isRecenterButtonEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setRecenterButtonEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setRecenterButtonEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isSpeedLimitIconEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isSpeedLimitIconEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setSpeedLimitIconEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setSpeedLimitIconEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isSpeedometerEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isSpeedometerEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setSpeedometerEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setSpeedometerEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isNavigationUIEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isNavigationUIEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setNavigationUIEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setNavigationUIEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isMyLocationButtonEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isMyLocationButtonEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setMyLocationButtonEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setMyLocationButtonEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isConsumeMyLocationButtonClickEventsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isConsumeMyLocationButtonClickEventsEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setConsumeMyLocationButtonClickEventsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setConsumeMyLocationButtonClickEventsEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isZoomGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isZoomGesturesEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setZoomGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setZoomGesturesEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isZoomControlsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isZoomControlsEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setZoomControlsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setZoomControlsEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isCompassEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isCompassEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setCompassEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setCompassEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isRotateGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isRotateGesturesEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setRotateGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setRotateGesturesEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isScrollGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isScrollGesturesEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setScrollGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setScrollGesturesEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isScrollGesturesEnabledDuringRotateOrZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isScrollGesturesEnabledDuringRotateOrZoom(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setScrollGesturesDuringRotateOrZoomEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setScrollGesturesDuringRotateOrZoomEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isTiltGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isTiltGesturesEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setTiltGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setTiltGesturesEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isMapToolbarEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isMapToolbarEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setMapToolbarEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setMapToolbarEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isTrafficEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isTrafficEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setTrafficEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setTrafficEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isTrafficIncidentCardsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isTrafficIncidentCardsEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setTrafficIncidentCardsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setTrafficIncidentCardsEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isTrafficPromptsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isTrafficPromptsEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setTrafficPromptsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setTrafficPromptsEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.isReportIncidentButtonEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isReportIncidentButtonEnabled(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setReportIncidentButtonEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setReportIncidentButtonEnabled(viewIdArg, enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.getCameraPosition$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.getCameraPosition(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.getVisibleRegion$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.getVisibleRegion(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.followMyLocation$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val perspectiveArg = args[1] as CameraPerspectiveDto
            val zoomLevelArg = args[2] as Double?
            val wrapped: List<Any?> =
              try {
                api.followMyLocation(viewIdArg, perspectiveArg, zoomLevelArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.animateCameraToCameraPosition$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val cameraPositionArg = args[1] as CameraPositionDto
            val durationArg = args[2] as Long?
            api.animateCameraToCameraPosition(viewIdArg, cameraPositionArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.animateCameraToLatLng$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val pointArg = args[1] as LatLngDto
            val durationArg = args[2] as Long?
            api.animateCameraToLatLng(viewIdArg, pointArg, durationArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.animateCameraToLatLngBounds$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val boundsArg = args[1] as LatLngBoundsDto
            val paddingArg = args[2] as Double
            val durationArg = args[3] as Long?
            api.animateCameraToLatLngBounds(viewIdArg, boundsArg, paddingArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.animateCameraToLatLngZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val pointArg = args[1] as LatLngDto
            val zoomArg = args[2] as Double
            val durationArg = args[3] as Long?
            api.animateCameraToLatLngZoom(viewIdArg, pointArg, zoomArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.animateCameraByScroll$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val scrollByDxArg = args[1] as Double
            val scrollByDyArg = args[2] as Double
            val durationArg = args[3] as Long?
            api.animateCameraByScroll(viewIdArg, scrollByDxArg, scrollByDyArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.animateCameraByZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val zoomByArg = args[1] as Double
            val focusDxArg = args[2] as Double?
            val focusDyArg = args[3] as Double?
            val durationArg = args[4] as Long?
            api.animateCameraByZoom(viewIdArg, zoomByArg, focusDxArg, focusDyArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.animateCameraToZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val zoomArg = args[1] as Double
            val durationArg = args[2] as Long?
            api.animateCameraToZoom(viewIdArg, zoomArg, durationArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.moveCameraToCameraPosition$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val cameraPositionArg = args[1] as CameraPositionDto
            val wrapped: List<Any?> =
              try {
                api.moveCameraToCameraPosition(viewIdArg, cameraPositionArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.moveCameraToLatLng$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val pointArg = args[1] as LatLngDto
            val wrapped: List<Any?> =
              try {
                api.moveCameraToLatLng(viewIdArg, pointArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.moveCameraToLatLngBounds$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val boundsArg = args[1] as LatLngBoundsDto
            val paddingArg = args[2] as Double
            val wrapped: List<Any?> =
              try {
                api.moveCameraToLatLngBounds(viewIdArg, boundsArg, paddingArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.moveCameraToLatLngZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val pointArg = args[1] as LatLngDto
            val zoomArg = args[2] as Double
            val wrapped: List<Any?> =
              try {
                api.moveCameraToLatLngZoom(viewIdArg, pointArg, zoomArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.moveCameraByScroll$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val scrollByDxArg = args[1] as Double
            val scrollByDyArg = args[2] as Double
            val wrapped: List<Any?> =
              try {
                api.moveCameraByScroll(viewIdArg, scrollByDxArg, scrollByDyArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.moveCameraByZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val zoomByArg = args[1] as Double
            val focusDxArg = args[2] as Double?
            val focusDyArg = args[3] as Double?
            val wrapped: List<Any?> =
              try {
                api.moveCameraByZoom(viewIdArg, zoomByArg, focusDxArg, focusDyArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.moveCameraToZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val zoomArg = args[1] as Double
            val wrapped: List<Any?> =
              try {
                api.moveCameraToZoom(viewIdArg, zoomArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.showRouteOverview$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                api.showRouteOverview(viewIdArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.getMinZoomPreference$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.getMinZoomPreference(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.getMaxZoomPreference$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.getMaxZoomPreference(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.resetMinMaxZoomPreference$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                api.resetMinMaxZoomPreference(viewIdArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setMinZoomPreference$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val minZoomPreferenceArg = args[1] as Double
            val wrapped: List<Any?> =
              try {
                api.setMinZoomPreference(viewIdArg, minZoomPreferenceArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setMaxZoomPreference$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val maxZoomPreferenceArg = args[1] as Double
            val wrapped: List<Any?> =
              try {
                api.setMaxZoomPreference(viewIdArg, maxZoomPreferenceArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.getMarkers$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.getMarkers(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.addMarkers$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val markersArg = args[1] as List<MarkerDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.addMarkers(viewIdArg, markersArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.updateMarkers$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val markersArg = args[1] as List<MarkerDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.updateMarkers(viewIdArg, markersArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.removeMarkers$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val markersArg = args[1] as List<MarkerDto>
            val wrapped: List<Any?> =
              try {
                api.removeMarkers(viewIdArg, markersArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.clearMarkers$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                api.clearMarkers(viewIdArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.clear$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                api.clear(viewIdArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.getPolygons$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.getPolygons(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.addPolygons$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val polygonsArg = args[1] as List<PolygonDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.addPolygons(viewIdArg, polygonsArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.updatePolygons$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val polygonsArg = args[1] as List<PolygonDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.updatePolygons(viewIdArg, polygonsArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.removePolygons$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val polygonsArg = args[1] as List<PolygonDto>
            val wrapped: List<Any?> =
              try {
                api.removePolygons(viewIdArg, polygonsArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.clearPolygons$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                api.clearPolygons(viewIdArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.getPolylines$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.getPolylines(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.addPolylines$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val polylinesArg = args[1] as List<PolylineDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.addPolylines(viewIdArg, polylinesArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.updatePolylines$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val polylinesArg = args[1] as List<PolylineDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.updatePolylines(viewIdArg, polylinesArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.removePolylines$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val polylinesArg = args[1] as List<PolylineDto>
            val wrapped: List<Any?> =
              try {
                api.removePolylines(viewIdArg, polylinesArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.clearPolylines$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                api.clearPolylines(viewIdArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.getCircles$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.getCircles(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.addCircles$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val circlesArg = args[1] as List<CircleDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.addCircles(viewIdArg, circlesArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.updateCircles$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val circlesArg = args[1] as List<CircleDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.updateCircles(viewIdArg, circlesArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.removeCircles$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val circlesArg = args[1] as List<CircleDto>
            val wrapped: List<Any?> =
              try {
                api.removeCircles(viewIdArg, circlesArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.clearCircles$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                api.clearCircles(viewIdArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.enableOnCameraChangedEvents$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                api.enableOnCameraChangedEvents(viewIdArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.setPadding$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val paddingArg = args[1] as MapPaddingDto
            val wrapped: List<Any?> =
              try {
                api.setPadding(viewIdArg, paddingArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.MapViewApi.getPadding$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.getPadding(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface ImageRegistryApi {
  fun registerBitmapImage(
    imageId: String,
    bytes: ByteArray,
    imagePixelRatio: Double,
    width: Double?,
    height: Double?,
  ): ImageDescriptorDto

  fun unregisterImage(imageDescriptor: ImageDescriptorDto)

  fun getRegisteredImages(): List<ImageDescriptorDto>

  fun clearRegisteredImages()

  companion object {
    /** The codec used by ImageRegistryApi. */
    val codec: MessageCodec<Any?> by lazy { messagesPigeonCodec() }

    /**
     * Sets up an instance of `ImageRegistryApi` to handle messages through the `binaryMessenger`.
     */
    @JvmOverloads
    fun setUp(
      binaryMessenger: BinaryMessenger,
      api: ImageRegistryApi?,
      messageChannelSuffix: String = "",
    ) {
      val separatedMessageChannelSuffix =
        if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.ImageRegistryApi.registerBitmapImage$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imageIdArg = args[0] as String
            val bytesArg = args[1] as ByteArray
            val imagePixelRatioArg = args[2] as Double
            val widthArg = args[3] as Double?
            val heightArg = args[4] as Double?
            val wrapped: List<Any?> =
              try {
                listOf(
                  api.registerBitmapImage(
                    imageIdArg,
                    bytesArg,
                    imagePixelRatioArg,
                    widthArg,
                    heightArg,
                  )
                )
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.ImageRegistryApi.unregisterImage$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imageDescriptorArg = args[0] as ImageDescriptorDto
            val wrapped: List<Any?> =
              try {
                api.unregisterImage(imageDescriptorArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.ImageRegistryApi.getRegisteredImages$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getRegisteredImages())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.ImageRegistryApi.clearRegisteredImages$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.clearRegisteredImages()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class ViewEventApi(
  private val binaryMessenger: BinaryMessenger,
  private val messageChannelSuffix: String = "",
) {
  companion object {
    /** The codec used by ViewEventApi. */
    val codec: MessageCodec<Any?> by lazy { messagesPigeonCodec() }
  }

  fun onMapClickEvent(viewIdArg: Long, latLngArg: LatLngDto, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onMapClickEvent$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, latLngArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onMapLongClickEvent(viewIdArg: Long, latLngArg: LatLngDto, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onMapLongClickEvent$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, latLngArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onRecenterButtonClicked(viewIdArg: Long, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onRecenterButtonClicked$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onMarkerEvent(
    viewIdArg: Long,
    markerIdArg: String,
    eventTypeArg: MarkerEventTypeDto,
    callback: (Result<Unit>) -> Unit,
  ) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onMarkerEvent$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, markerIdArg, eventTypeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onMarkerDragEvent(
    viewIdArg: Long,
    markerIdArg: String,
    eventTypeArg: MarkerDragEventTypeDto,
    positionArg: LatLngDto,
    callback: (Result<Unit>) -> Unit,
  ) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onMarkerDragEvent$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, markerIdArg, eventTypeArg, positionArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onPolygonClicked(viewIdArg: Long, polygonIdArg: String, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onPolygonClicked$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, polygonIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onPolylineClicked(viewIdArg: Long, polylineIdArg: String, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onPolylineClicked$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, polylineIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onCircleClicked(viewIdArg: Long, circleIdArg: String, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onCircleClicked$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, circleIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onNavigationUIEnabledChanged(
    viewIdArg: Long,
    navigationUIEnabledArg: Boolean,
    callback: (Result<Unit>) -> Unit,
  ) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onNavigationUIEnabledChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, navigationUIEnabledArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onMyLocationClicked(viewIdArg: Long, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onMyLocationClicked$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onMyLocationButtonClicked(viewIdArg: Long, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onMyLocationButtonClicked$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onCameraChanged(
    viewIdArg: Long,
    eventTypeArg: CameraEventTypeDto,
    positionArg: CameraPositionDto,
    callback: (Result<Unit>) -> Unit,
  ) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.ViewEventApi.onCameraChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, eventTypeArg, positionArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface NavigationSessionApi {
  /** General. */
  fun createNavigationSession(
    abnormalTerminationReportingEnabled: Boolean,
    behavior: TaskRemovedBehaviorDto,
    callback: (Result<Unit>) -> Unit,
  )

  fun isInitialized(): Boolean

  fun cleanup()

  fun showTermsAndConditionsDialog(
    title: String,
    companyName: String,
    shouldOnlyShowDriverAwarenessDisclaimer: Boolean,
    callback: (Result<Boolean>) -> Unit,
  )

  fun areTermsAccepted(): Boolean

  fun resetTermsAccepted()

  fun getNavSDKVersion(): String

  /** Navigation. */
  fun isGuidanceRunning(): Boolean

  fun startGuidance()

  fun stopGuidance()

  fun setDestinations(destinations: DestinationsDto, callback: (Result<RouteStatusDto>) -> Unit)

  fun clearDestinations()

  fun continueToNextDestination(): NavigationWaypointDto?

  fun getCurrentTimeAndDistance(): NavigationTimeAndDistanceDto

  fun setAudioGuidance(settings: NavigationAudioGuidanceSettingsDto)

  fun setSpeedAlertOptions(options: SpeedAlertOptionsDto)

  fun getRouteSegments(): List<RouteSegmentDto>

  fun getTraveledRoute(): List<LatLngDto>

  fun getCurrentRouteSegment(): RouteSegmentDto?

  /** Simulation */
  fun setUserLocation(location: LatLngDto)

  fun removeUserLocation()

  fun simulateLocationsAlongExistingRoute()

  fun simulateLocationsAlongExistingRouteWithOptions(options: SimulationOptionsDto)

  fun simulateLocationsAlongNewRoute(
    waypoints: List<NavigationWaypointDto>,
    callback: (Result<RouteStatusDto>) -> Unit,
  )

  fun simulateLocationsAlongNewRouteWithRoutingOptions(
    waypoints: List<NavigationWaypointDto>,
    routingOptions: RoutingOptionsDto,
    callback: (Result<RouteStatusDto>) -> Unit,
  )

  fun simulateLocationsAlongNewRouteWithRoutingAndSimulationOptions(
    waypoints: List<NavigationWaypointDto>,
    routingOptions: RoutingOptionsDto,
    simulationOptions: SimulationOptionsDto,
    callback: (Result<RouteStatusDto>) -> Unit,
  )

  fun pauseSimulation()

  fun resumeSimulation()

  /** Simulation (iOS only) */
  fun allowBackgroundLocationUpdates(allow: Boolean)

  /** Road snapped location updates. */
  fun enableRoadSnappedLocationUpdates()

  fun disableRoadSnappedLocationUpdates()

  /** Enable Turn-by-Turn navigation events. */
  fun enableTurnByTurnNavigationEvents(numNextStepsToPreview: Long?)

  fun disableTurnByTurnNavigationEvents()

  fun registerRemainingTimeOrDistanceChangedListener(
    remainingTimeThresholdSeconds: Long,
    remainingDistanceThresholdMeters: Long,
  )

  companion object {
    /** The codec used by NavigationSessionApi. */
    val codec: MessageCodec<Any?> by lazy { messagesPigeonCodec() }

    /**
     * Sets up an instance of `NavigationSessionApi` to handle messages through the
     * `binaryMessenger`.
     */
    @JvmOverloads
    fun setUp(
      binaryMessenger: BinaryMessenger,
      api: NavigationSessionApi?,
      messageChannelSuffix: String = "",
    ) {
      val separatedMessageChannelSuffix =
        if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.createNavigationSession$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val abnormalTerminationReportingEnabledArg = args[0] as Boolean
            val behaviorArg = args[1] as TaskRemovedBehaviorDto
            api.createNavigationSession(abnormalTerminationReportingEnabledArg, behaviorArg) {
              result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                reply.reply(MessagesPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.isInitialized$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isInitialized())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.cleanup$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.cleanup()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.showTermsAndConditionsDialog$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val titleArg = args[0] as String
            val companyNameArg = args[1] as String
            val shouldOnlyShowDriverAwarenessDisclaimerArg = args[2] as Boolean
            api.showTermsAndConditionsDialog(
              titleArg,
              companyNameArg,
              shouldOnlyShowDriverAwarenessDisclaimerArg,
            ) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.areTermsAccepted$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.areTermsAccepted())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.resetTermsAccepted$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.resetTermsAccepted()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.getNavSDKVersion$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getNavSDKVersion())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.isGuidanceRunning$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isGuidanceRunning())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.startGuidance$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.startGuidance()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.stopGuidance$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.stopGuidance()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.setDestinations$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val destinationsArg = args[0] as DestinationsDto
            api.setDestinations(destinationsArg) { result: Result<RouteStatusDto> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.clearDestinations$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.clearDestinations()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.continueToNextDestination$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.continueToNextDestination())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.getCurrentTimeAndDistance$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getCurrentTimeAndDistance())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.setAudioGuidance$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as NavigationAudioGuidanceSettingsDto
            val wrapped: List<Any?> =
              try {
                api.setAudioGuidance(settingsArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.setSpeedAlertOptions$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val optionsArg = args[0] as SpeedAlertOptionsDto
            val wrapped: List<Any?> =
              try {
                api.setSpeedAlertOptions(optionsArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.getRouteSegments$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getRouteSegments())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.getTraveledRoute$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getTraveledRoute())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.getCurrentRouteSegment$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getCurrentRouteSegment())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.setUserLocation$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val locationArg = args[0] as LatLngDto
            val wrapped: List<Any?> =
              try {
                api.setUserLocation(locationArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.removeUserLocation$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.removeUserLocation()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.simulateLocationsAlongExistingRoute$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.simulateLocationsAlongExistingRoute()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.simulateLocationsAlongExistingRouteWithOptions$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val optionsArg = args[0] as SimulationOptionsDto
            val wrapped: List<Any?> =
              try {
                api.simulateLocationsAlongExistingRouteWithOptions(optionsArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.simulateLocationsAlongNewRoute$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val waypointsArg = args[0] as List<NavigationWaypointDto>
            api.simulateLocationsAlongNewRoute(waypointsArg) { result: Result<RouteStatusDto> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.simulateLocationsAlongNewRouteWithRoutingOptions$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val waypointsArg = args[0] as List<NavigationWaypointDto>
            val routingOptionsArg = args[1] as RoutingOptionsDto
            api.simulateLocationsAlongNewRouteWithRoutingOptions(waypointsArg, routingOptionsArg) {
              result: Result<RouteStatusDto> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.simulateLocationsAlongNewRouteWithRoutingAndSimulationOptions$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val waypointsArg = args[0] as List<NavigationWaypointDto>
            val routingOptionsArg = args[1] as RoutingOptionsDto
            val simulationOptionsArg = args[2] as SimulationOptionsDto
            api.simulateLocationsAlongNewRouteWithRoutingAndSimulationOptions(
              waypointsArg,
              routingOptionsArg,
              simulationOptionsArg,
            ) { result: Result<RouteStatusDto> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.pauseSimulation$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.pauseSimulation()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.resumeSimulation$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.resumeSimulation()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.allowBackgroundLocationUpdates$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val allowArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.allowBackgroundLocationUpdates(allowArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.enableRoadSnappedLocationUpdates$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.enableRoadSnappedLocationUpdates()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.disableRoadSnappedLocationUpdates$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.disableRoadSnappedLocationUpdates()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.enableTurnByTurnNavigationEvents$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val numNextStepsToPreviewArg = args[0] as Long?
            val wrapped: List<Any?> =
              try {
                api.enableTurnByTurnNavigationEvents(numNextStepsToPreviewArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.disableTurnByTurnNavigationEvents$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.disableTurnByTurnNavigationEvents()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionApi.registerRemainingTimeOrDistanceChangedListener$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val remainingTimeThresholdSecondsArg = args[0] as Long
            val remainingDistanceThresholdMetersArg = args[1] as Long
            val wrapped: List<Any?> =
              try {
                api.registerRemainingTimeOrDistanceChangedListener(
                  remainingTimeThresholdSecondsArg,
                  remainingDistanceThresholdMetersArg,
                )
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class NavigationSessionEventApi(
  private val binaryMessenger: BinaryMessenger,
  private val messageChannelSuffix: String = "",
) {
  companion object {
    /** The codec used by NavigationSessionEventApi. */
    val codec: MessageCodec<Any?> by lazy { messagesPigeonCodec() }
  }

  fun onSpeedingUpdated(msgArg: SpeedingUpdatedEventDto, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionEventApi.onSpeedingUpdated$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(msgArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onRoadSnappedLocationUpdated(locationArg: LatLngDto, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionEventApi.onRoadSnappedLocationUpdated$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(locationArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onRoadSnappedRawLocationUpdated(locationArg: LatLngDto, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionEventApi.onRoadSnappedRawLocationUpdated$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(locationArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onArrival(waypointArg: NavigationWaypointDto, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionEventApi.onArrival$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(waypointArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onRouteChanged(callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionEventApi.onRouteChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onRemainingTimeOrDistanceChanged(
    remainingTimeArg: Double,
    remainingDistanceArg: Double,
    callback: (Result<Unit>) -> Unit,
  ) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionEventApi.onRemainingTimeOrDistanceChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(remainingTimeArg, remainingDistanceArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  /** Android-only event. */
  fun onTrafficUpdated(callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionEventApi.onTrafficUpdated$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  /** Android-only event. */
  fun onRerouting(callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionEventApi.onRerouting$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  /** Android-only event. */
  fun onGpsAvailabilityUpdate(availableArg: Boolean, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionEventApi.onGpsAvailabilityUpdate$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(availableArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  /** Turn-by-Turn navigation events. */
  fun onNavInfo(navInfoArg: NavInfoDto, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.NavigationSessionEventApi.onNavInfo$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(navInfoArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface AutoMapViewApi {
  fun isMyLocationEnabled(): Boolean

  fun setMyLocationEnabled(enabled: Boolean)

  fun getMyLocation(): LatLngDto?

  fun getMapType(): MapTypeDto

  fun setMapType(mapType: MapTypeDto)

  fun setMapStyle(styleJson: String)

  fun getCameraPosition(): CameraPositionDto

  fun getVisibleRegion(): LatLngBoundsDto

  fun followMyLocation(perspective: CameraPerspectiveDto, zoomLevel: Double?)

  fun animateCameraToCameraPosition(
    cameraPosition: CameraPositionDto,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun animateCameraToLatLng(point: LatLngDto, duration: Long?, callback: (Result<Boolean>) -> Unit)

  fun animateCameraToLatLngBounds(
    bounds: LatLngBoundsDto,
    padding: Double,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun animateCameraToLatLngZoom(
    point: LatLngDto,
    zoom: Double,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun animateCameraByScroll(
    scrollByDx: Double,
    scrollByDy: Double,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun animateCameraByZoom(
    zoomBy: Double,
    focusDx: Double?,
    focusDy: Double?,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit,
  )

  fun animateCameraToZoom(zoom: Double, duration: Long?, callback: (Result<Boolean>) -> Unit)

  fun moveCameraToCameraPosition(cameraPosition: CameraPositionDto)

  fun moveCameraToLatLng(point: LatLngDto)

  fun moveCameraToLatLngBounds(bounds: LatLngBoundsDto, padding: Double)

  fun moveCameraToLatLngZoom(point: LatLngDto, zoom: Double)

  fun moveCameraByScroll(scrollByDx: Double, scrollByDy: Double)

  fun moveCameraByZoom(zoomBy: Double, focusDx: Double?, focusDy: Double?)

  fun moveCameraToZoom(zoom: Double)

  fun getMinZoomPreference(): Double

  fun getMaxZoomPreference(): Double

  fun resetMinMaxZoomPreference()

  fun setMinZoomPreference(minZoomPreference: Double)

  fun setMaxZoomPreference(maxZoomPreference: Double)

  fun setMyLocationButtonEnabled(enabled: Boolean)

  fun setConsumeMyLocationButtonClickEventsEnabled(enabled: Boolean)

  fun setZoomGesturesEnabled(enabled: Boolean)

  fun setZoomControlsEnabled(enabled: Boolean)

  fun setCompassEnabled(enabled: Boolean)

  fun setRotateGesturesEnabled(enabled: Boolean)

  fun setScrollGesturesEnabled(enabled: Boolean)

  fun setScrollGesturesDuringRotateOrZoomEnabled(enabled: Boolean)

  fun setTiltGesturesEnabled(enabled: Boolean)

  fun setMapToolbarEnabled(enabled: Boolean)

  fun setTrafficEnabled(enabled: Boolean)

  fun isMyLocationButtonEnabled(): Boolean

  fun isConsumeMyLocationButtonClickEventsEnabled(): Boolean

  fun isZoomGesturesEnabled(): Boolean

  fun isZoomControlsEnabled(): Boolean

  fun isCompassEnabled(): Boolean

  fun isRotateGesturesEnabled(): Boolean

  fun isScrollGesturesEnabled(): Boolean

  fun isScrollGesturesEnabledDuringRotateOrZoom(): Boolean

  fun isTiltGesturesEnabled(): Boolean

  fun isMapToolbarEnabled(): Boolean

  fun isTrafficEnabled(): Boolean

  fun getMarkers(): List<MarkerDto>

  fun addMarkers(markers: List<MarkerDto>): List<MarkerDto>

  fun updateMarkers(markers: List<MarkerDto>): List<MarkerDto>

  fun removeMarkers(markers: List<MarkerDto>)

  fun clearMarkers()

  fun clear()

  fun getPolygons(): List<PolygonDto>

  fun addPolygons(polygons: List<PolygonDto>): List<PolygonDto>

  fun updatePolygons(polygons: List<PolygonDto>): List<PolygonDto>

  fun removePolygons(polygons: List<PolygonDto>)

  fun clearPolygons()

  fun getPolylines(): List<PolylineDto>

  fun addPolylines(polylines: List<PolylineDto>): List<PolylineDto>

  fun updatePolylines(polylines: List<PolylineDto>): List<PolylineDto>

  fun removePolylines(polylines: List<PolylineDto>)

  fun clearPolylines()

  fun getCircles(): List<CircleDto>

  fun addCircles(circles: List<CircleDto>): List<CircleDto>

  fun updateCircles(circles: List<CircleDto>): List<CircleDto>

  fun removeCircles(circles: List<CircleDto>)

  fun clearCircles()

  fun enableOnCameraChangedEvents()

  fun isAutoScreenAvailable(): Boolean

  fun setPadding(padding: MapPaddingDto)

  fun getPadding(): MapPaddingDto

  companion object {
    /** The codec used by AutoMapViewApi. */
    val codec: MessageCodec<Any?> by lazy { messagesPigeonCodec() }

    /** Sets up an instance of `AutoMapViewApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(
      binaryMessenger: BinaryMessenger,
      api: AutoMapViewApi?,
      messageChannelSuffix: String = "",
    ) {
      val separatedMessageChannelSuffix =
        if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isMyLocationEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isMyLocationEnabled())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setMyLocationEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setMyLocationEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.getMyLocation$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getMyLocation())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.getMapType$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getMapType())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setMapType$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val mapTypeArg = args[0] as MapTypeDto
            val wrapped: List<Any?> =
              try {
                api.setMapType(mapTypeArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setMapStyle$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val styleJsonArg = args[0] as String
            val wrapped: List<Any?> =
              try {
                api.setMapStyle(styleJsonArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.getCameraPosition$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getCameraPosition())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.getVisibleRegion$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getVisibleRegion())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.followMyLocation$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val perspectiveArg = args[0] as CameraPerspectiveDto
            val zoomLevelArg = args[1] as Double?
            val wrapped: List<Any?> =
              try {
                api.followMyLocation(perspectiveArg, zoomLevelArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.animateCameraToCameraPosition$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val cameraPositionArg = args[0] as CameraPositionDto
            val durationArg = args[1] as Long?
            api.animateCameraToCameraPosition(cameraPositionArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.animateCameraToLatLng$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pointArg = args[0] as LatLngDto
            val durationArg = args[1] as Long?
            api.animateCameraToLatLng(pointArg, durationArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.animateCameraToLatLngBounds$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val boundsArg = args[0] as LatLngBoundsDto
            val paddingArg = args[1] as Double
            val durationArg = args[2] as Long?
            api.animateCameraToLatLngBounds(boundsArg, paddingArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.animateCameraToLatLngZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pointArg = args[0] as LatLngDto
            val zoomArg = args[1] as Double
            val durationArg = args[2] as Long?
            api.animateCameraToLatLngZoom(pointArg, zoomArg, durationArg) { result: Result<Boolean>
              ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.animateCameraByScroll$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val scrollByDxArg = args[0] as Double
            val scrollByDyArg = args[1] as Double
            val durationArg = args[2] as Long?
            api.animateCameraByScroll(scrollByDxArg, scrollByDyArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.animateCameraByZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val zoomByArg = args[0] as Double
            val focusDxArg = args[1] as Double?
            val focusDyArg = args[2] as Double?
            val durationArg = args[3] as Long?
            api.animateCameraByZoom(zoomByArg, focusDxArg, focusDyArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.animateCameraToZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val zoomArg = args[0] as Double
            val durationArg = args[1] as Long?
            api.animateCameraToZoom(zoomArg, durationArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.moveCameraToCameraPosition$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val cameraPositionArg = args[0] as CameraPositionDto
            val wrapped: List<Any?> =
              try {
                api.moveCameraToCameraPosition(cameraPositionArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.moveCameraToLatLng$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pointArg = args[0] as LatLngDto
            val wrapped: List<Any?> =
              try {
                api.moveCameraToLatLng(pointArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.moveCameraToLatLngBounds$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val boundsArg = args[0] as LatLngBoundsDto
            val paddingArg = args[1] as Double
            val wrapped: List<Any?> =
              try {
                api.moveCameraToLatLngBounds(boundsArg, paddingArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.moveCameraToLatLngZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pointArg = args[0] as LatLngDto
            val zoomArg = args[1] as Double
            val wrapped: List<Any?> =
              try {
                api.moveCameraToLatLngZoom(pointArg, zoomArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.moveCameraByScroll$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val scrollByDxArg = args[0] as Double
            val scrollByDyArg = args[1] as Double
            val wrapped: List<Any?> =
              try {
                api.moveCameraByScroll(scrollByDxArg, scrollByDyArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.moveCameraByZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val zoomByArg = args[0] as Double
            val focusDxArg = args[1] as Double?
            val focusDyArg = args[2] as Double?
            val wrapped: List<Any?> =
              try {
                api.moveCameraByZoom(zoomByArg, focusDxArg, focusDyArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.moveCameraToZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val zoomArg = args[0] as Double
            val wrapped: List<Any?> =
              try {
                api.moveCameraToZoom(zoomArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.getMinZoomPreference$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getMinZoomPreference())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.getMaxZoomPreference$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getMaxZoomPreference())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.resetMinMaxZoomPreference$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.resetMinMaxZoomPreference()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setMinZoomPreference$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val minZoomPreferenceArg = args[0] as Double
            val wrapped: List<Any?> =
              try {
                api.setMinZoomPreference(minZoomPreferenceArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setMaxZoomPreference$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val maxZoomPreferenceArg = args[0] as Double
            val wrapped: List<Any?> =
              try {
                api.setMaxZoomPreference(maxZoomPreferenceArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setMyLocationButtonEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setMyLocationButtonEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setConsumeMyLocationButtonClickEventsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setConsumeMyLocationButtonClickEventsEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setZoomGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setZoomGesturesEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setZoomControlsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setZoomControlsEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setCompassEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setCompassEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setRotateGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setRotateGesturesEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setScrollGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setScrollGesturesEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setScrollGesturesDuringRotateOrZoomEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setScrollGesturesDuringRotateOrZoomEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setTiltGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setTiltGesturesEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setMapToolbarEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setMapToolbarEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setTrafficEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> =
              try {
                api.setTrafficEnabled(enabledArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isMyLocationButtonEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isMyLocationButtonEnabled())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isConsumeMyLocationButtonClickEventsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isConsumeMyLocationButtonClickEventsEnabled())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isZoomGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isZoomGesturesEnabled())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isZoomControlsEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isZoomControlsEnabled())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isCompassEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isCompassEnabled())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isRotateGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isRotateGesturesEnabled())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isScrollGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isScrollGesturesEnabled())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isScrollGesturesEnabledDuringRotateOrZoom$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isScrollGesturesEnabledDuringRotateOrZoom())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isTiltGesturesEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isTiltGesturesEnabled())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isMapToolbarEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isMapToolbarEnabled())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isTrafficEnabled$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isTrafficEnabled())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.getMarkers$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getMarkers())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.addMarkers$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val markersArg = args[0] as List<MarkerDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.addMarkers(markersArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.updateMarkers$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val markersArg = args[0] as List<MarkerDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.updateMarkers(markersArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.removeMarkers$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val markersArg = args[0] as List<MarkerDto>
            val wrapped: List<Any?> =
              try {
                api.removeMarkers(markersArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.clearMarkers$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.clearMarkers()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.clear$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.clear()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.getPolygons$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getPolygons())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.addPolygons$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val polygonsArg = args[0] as List<PolygonDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.addPolygons(polygonsArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.updatePolygons$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val polygonsArg = args[0] as List<PolygonDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.updatePolygons(polygonsArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.removePolygons$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val polygonsArg = args[0] as List<PolygonDto>
            val wrapped: List<Any?> =
              try {
                api.removePolygons(polygonsArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.clearPolygons$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.clearPolygons()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.getPolylines$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getPolylines())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.addPolylines$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val polylinesArg = args[0] as List<PolylineDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.addPolylines(polylinesArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.updatePolylines$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val polylinesArg = args[0] as List<PolylineDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.updatePolylines(polylinesArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.removePolylines$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val polylinesArg = args[0] as List<PolylineDto>
            val wrapped: List<Any?> =
              try {
                api.removePolylines(polylinesArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.clearPolylines$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.clearPolylines()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.getCircles$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getCircles())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.addCircles$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val circlesArg = args[0] as List<CircleDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.addCircles(circlesArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.updateCircles$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val circlesArg = args[0] as List<CircleDto>
            val wrapped: List<Any?> =
              try {
                listOf(api.updateCircles(circlesArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.removeCircles$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val circlesArg = args[0] as List<CircleDto>
            val wrapped: List<Any?> =
              try {
                api.removeCircles(circlesArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.clearCircles$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.clearCircles()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.enableOnCameraChangedEvents$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                api.enableOnCameraChangedEvents()
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.isAutoScreenAvailable$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.isAutoScreenAvailable())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.setPadding$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val paddingArg = args[0] as MapPaddingDto
            val wrapped: List<Any?> =
              try {
                api.setPadding(paddingArg)
                listOf(null)
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.AutoMapViewApi.getPadding$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
              try {
                listOf(api.getPadding())
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class AutoViewEventApi(
  private val binaryMessenger: BinaryMessenger,
  private val messageChannelSuffix: String = "",
) {
  companion object {
    /** The codec used by AutoViewEventApi. */
    val codec: MessageCodec<Any?> by lazy { messagesPigeonCodec() }
  }

  fun onCustomNavigationAutoEvent(
    eventArg: String,
    dataArg: Any,
    callback: (Result<Unit>) -> Unit,
  ) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.AutoViewEventApi.onCustomNavigationAutoEvent$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(eventArg, dataArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }

  fun onAutoScreenAvailabilityChanged(isAvailableArg: Boolean, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix =
      if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName =
      "dev.flutter.pigeon.google_navigation_flutter.AutoViewEventApi.onAutoScreenAvailabilityChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(isAvailableArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      }
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface NavigationInspector {
  fun isViewAttachedToSession(viewId: Long): Boolean

  companion object {
    /** The codec used by NavigationInspector. */
    val codec: MessageCodec<Any?> by lazy { messagesPigeonCodec() }

    /**
     * Sets up an instance of `NavigationInspector` to handle messages through the
     * `binaryMessenger`.
     */
    @JvmOverloads
    fun setUp(
      binaryMessenger: BinaryMessenger,
      api: NavigationInspector?,
      messageChannelSuffix: String = "",
    ) {
      val separatedMessageChannelSuffix =
        if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_navigation_flutter.NavigationInspector.isViewAttachedToSession$separatedMessageChannelSuffix",
            codec,
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0] as Long
            val wrapped: List<Any?> =
              try {
                listOf(api.isViewAttachedToSession(viewIdArg))
              } catch (exception: Throwable) {
                MessagesPigeonUtils.wrapError(exception)
              }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
