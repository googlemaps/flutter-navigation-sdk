// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Autogenerated from Pigeon (v15.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.google.maps.flutter.navigation

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(exception.code, exception.message, exception.details)
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): FlutterError {
  return FlutterError(
    "channel-error",
    "Unable to establish connection on channel: '$channelName'.",
    ""
  )
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 *
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError(
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Determines the initial visibility of the navigation UI on map initialization. */
enum class NavigationUIEnabledPreferenceDto(val raw: Int) {
  /** Navigation UI gets enabled if the navigation session has already been successfully started. */
  AUTOMATIC(0),
  /** Navigation UI is disabled. */
  DISABLED(1);

  companion object {
    fun ofRaw(raw: Int): NavigationUIEnabledPreferenceDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class MapTypeDto(val raw: Int) {
  NONE(0),
  NORMAL(1),
  SATELLITE(2),
  TERRAIN(3),
  HYBRID(4);

  companion object {
    fun ofRaw(raw: Int): MapTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class CameraPerspectiveDto(val raw: Int) {
  TILTED(0),
  TOPDOWNHEADINGUP(1),
  TOPDOWNNORTHUP(2);

  companion object {
    fun ofRaw(raw: Int): CameraPerspectiveDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class MarkerEventTypeDto(val raw: Int) {
  CLICKED(0),
  INFOWINDOWCLICKED(1),
  INFOWINDOWCLOSED(2),
  INFOWINDOWLONGCLICKED(3);

  companion object {
    fun ofRaw(raw: Int): MarkerEventTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class MarkerDragEventTypeDto(val raw: Int) {
  DRAG(0),
  DRAGSTART(1),
  DRAGEND(2);

  companion object {
    fun ofRaw(raw: Int): MarkerDragEventTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class StrokeJointTypeDto(val raw: Int) {
  BEVEL(0),
  DEFAULTJOINT(1),
  ROUND(2);

  companion object {
    fun ofRaw(raw: Int): StrokeJointTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PatternTypeDto(val raw: Int) {
  DASH(0),
  DOT(1),
  GAP(2);

  companion object {
    fun ofRaw(raw: Int): PatternTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class CameraEventTypeDto(val raw: Int) {
  MOVESTARTEDBYAPI(0),
  MOVESTARTEDBYGESTURE(1),
  ONCAMERAMOVE(2),
  ONCAMERAIDLE(3);

  companion object {
    fun ofRaw(raw: Int): CameraEventTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class NavigationSessionEventTypeDto(val raw: Int) {
  ARRIVALEVENT(0),
  ROUTECHANGED(1),
  ERRORRECEIVED(2);

  companion object {
    fun ofRaw(raw: Int): NavigationSessionEventTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class AlternateRoutesStrategyDto(val raw: Int) {
  ALL(0),
  NONE(1),
  ONE(2);

  companion object {
    fun ofRaw(raw: Int): AlternateRoutesStrategyDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RoutingStrategyDto(val raw: Int) {
  DEFAULTBEST(0),
  DELTATOTARGETDISTANCE(1),
  SHORTER(2);

  companion object {
    fun ofRaw(raw: Int): RoutingStrategyDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class TravelModeDto(val raw: Int) {
  DRIVING(0),
  CYCLING(1),
  WALKING(2),
  TWOWHEELER(3),
  TAXI(4);

  companion object {
    fun ofRaw(raw: Int): TravelModeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RouteStatusDto(val raw: Int) {
  INTERNALERROR(0),
  STATUSOK(1),
  ROUTENOTFOUND(2),
  NETWORKERROR(3),
  QUOTAEXCEEDED(4),
  APIKEYNOTAUTHORIZED(5),
  STATUSCANCELED(6),
  DUPLICATEWAYPOINTSERROR(7),
  NOWAYPOINTSERROR(8),
  LOCATIONUNAVAILABLE(9),
  WAYPOINTERROR(10),
  TRAVELMODEUNSUPPORTED(11),
  LOCATIONUNKNOWN(12),
  QUOTACHECKFAILED(13),
  UNKNOWN(14);

  companion object {
    fun ofRaw(raw: Int): RouteStatusDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class AudioGuidanceTypeDto(val raw: Int) {
  SILENT(0),
  ALERTSONLY(1),
  ALERTSANDGUIDANCE(2);

  companion object {
    fun ofRaw(raw: Int): AudioGuidanceTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class SpeedAlertSeverityDto(val raw: Int) {
  UNKNOWN(0),
  NOTSPEEDING(1),
  MINOR(2),
  MAJOR(3);

  companion object {
    fun ofRaw(raw: Int): SpeedAlertSeverityDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RouteSegmentTrafficDataStatusDto(val raw: Int) {
  OK(0),
  UNAVAILABLE(1);

  companion object {
    fun ofRaw(raw: Int): RouteSegmentTrafficDataStatusDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto(val raw: Int) {
  UNKNOWN(0),
  SLOWERTRAFFIC(1),
  TRAFFICJAM(2);

  companion object {
    fun ofRaw(raw: Int): RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Object containing map options used to initialize Google Map view.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MapOptionsDto(
  /** The initial positioning of the camera in the map view. */
  val cameraPosition: CameraPositionDto,
  /** The type of map to display (e.g., satellite, terrain, hybrid, etc.). */
  val mapType: MapTypeDto,
  /** If true, enables the compass. */
  val compassEnabled: Boolean,
  /** If true, enables the rotation gestures. */
  val rotateGesturesEnabled: Boolean,
  /** If true, enables the scroll gestures. */
  val scrollGesturesEnabled: Boolean,
  /** If true, enables the tilt gestures. */
  val tiltGesturesEnabled: Boolean,
  /** If true, enables the zoom gestures. */
  val zoomGesturesEnabled: Boolean,
  /** If true, enables the scroll gestures during rotate or zoom. */
  val scrollGesturesEnabledDuringRotateOrZoom: Boolean,
  /** If true, enables the map toolbar. */
  val mapToolbarEnabled: Boolean,
  /** The minimum zoom level that can be set for the map. */
  val minZoomPreference: Double? = null,
  /** The maximum zoom level that can be set for the map. */
  val maxZoomPreference: Double? = null,
  /** If true, enables zoom controls for the map. */
  val zoomControlsEnabled: Boolean,
  /**
   * Specifies a bounds to constrain the camera target, so that when users scroll and pan the map,
   * the camera target does not move outside these bounds.
   */
  val cameraTargetBounds: LatLngBoundsDto? = null
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): MapOptionsDto {
      val cameraPosition = CameraPositionDto.fromList(list[0] as List<Any?>)
      val mapType = MapTypeDto.ofRaw(list[1] as Int)!!
      val compassEnabled = list[2] as Boolean
      val rotateGesturesEnabled = list[3] as Boolean
      val scrollGesturesEnabled = list[4] as Boolean
      val tiltGesturesEnabled = list[5] as Boolean
      val zoomGesturesEnabled = list[6] as Boolean
      val scrollGesturesEnabledDuringRotateOrZoom = list[7] as Boolean
      val mapToolbarEnabled = list[8] as Boolean
      val minZoomPreference = list[9] as Double?
      val maxZoomPreference = list[10] as Double?
      val zoomControlsEnabled = list[11] as Boolean
      val cameraTargetBounds: LatLngBoundsDto? =
        (list[12] as List<Any?>?)?.let { LatLngBoundsDto.fromList(it) }
      return MapOptionsDto(
        cameraPosition,
        mapType,
        compassEnabled,
        rotateGesturesEnabled,
        scrollGesturesEnabled,
        tiltGesturesEnabled,
        zoomGesturesEnabled,
        scrollGesturesEnabledDuringRotateOrZoom,
        mapToolbarEnabled,
        minZoomPreference,
        maxZoomPreference,
        zoomControlsEnabled,
        cameraTargetBounds
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      cameraPosition.toList(),
      mapType.raw,
      compassEnabled,
      rotateGesturesEnabled,
      scrollGesturesEnabled,
      tiltGesturesEnabled,
      zoomGesturesEnabled,
      scrollGesturesEnabledDuringRotateOrZoom,
      mapToolbarEnabled,
      minZoomPreference,
      maxZoomPreference,
      zoomControlsEnabled,
      cameraTargetBounds?.toList(),
    )
  }
}

/**
 * Object containing navigation options used to initialize Google Navigation view.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class NavigationViewOptionsDto(
  /** Determines the initial visibility of the navigation UI on map initialization. */
  val navigationUIEnabledPreference: NavigationUIEnabledPreferenceDto
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): NavigationViewOptionsDto {
      val navigationUIEnabledPreference = NavigationUIEnabledPreferenceDto.ofRaw(list[0] as Int)!!
      return NavigationViewOptionsDto(navigationUIEnabledPreference)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      navigationUIEnabledPreference.raw,
    )
  }
}

/**
 * A message for creating a new navigation view.
 *
 * This message is used to initialize a new navigation view with a specified initial parameters.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class NavigationViewCreationOptionsDto(
  val mapOptions: MapOptionsDto,
  val navigationViewOptions: NavigationViewOptionsDto
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): NavigationViewCreationOptionsDto {
      val mapOptions = MapOptionsDto.fromList(list[0] as List<Any?>)
      val navigationViewOptions = NavigationViewOptionsDto.fromList(list[1] as List<Any?>)
      return NavigationViewCreationOptionsDto(mapOptions, navigationViewOptions)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      mapOptions.toList(),
      navigationViewOptions.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class CameraPositionDto(
  val bearing: Double,
  val target: LatLngDto,
  val tilt: Double,
  val zoom: Double
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): CameraPositionDto {
      val bearing = list[0] as Double
      val target = LatLngDto.fromList(list[1] as List<Any?>)
      val tilt = list[2] as Double
      val zoom = list[3] as Double
      return CameraPositionDto(bearing, target, tilt, zoom)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      bearing,
      target.toList(),
      tilt,
      zoom,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class MarkerDto(
  /** Identifies marker */
  val markerId: String,
  /** Options for marker */
  val options: MarkerOptionsDto
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): MarkerDto {
      val markerId = list[0] as String
      val options = MarkerOptionsDto.fromList(list[1] as List<Any?>)
      return MarkerDto(markerId, options)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      markerId,
      options.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class MarkerOptionsDto(
  val alpha: Double,
  val anchor: MarkerAnchorDto,
  val draggable: Boolean,
  val flat: Boolean,
  val consumeTapEvents: Boolean,
  val position: LatLngDto,
  val rotation: Double,
  val infoWindow: InfoWindowDto,
  val visible: Boolean,
  val zIndex: Double,
  val icon: ImageDescriptorDto
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): MarkerOptionsDto {
      val alpha = list[0] as Double
      val anchor = MarkerAnchorDto.fromList(list[1] as List<Any?>)
      val draggable = list[2] as Boolean
      val flat = list[3] as Boolean
      val consumeTapEvents = list[4] as Boolean
      val position = LatLngDto.fromList(list[5] as List<Any?>)
      val rotation = list[6] as Double
      val infoWindow = InfoWindowDto.fromList(list[7] as List<Any?>)
      val visible = list[8] as Boolean
      val zIndex = list[9] as Double
      val icon = ImageDescriptorDto.fromList(list[10] as List<Any?>)
      return MarkerOptionsDto(
        alpha,
        anchor,
        draggable,
        flat,
        consumeTapEvents,
        position,
        rotation,
        infoWindow,
        visible,
        zIndex,
        icon
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      alpha,
      anchor.toList(),
      draggable,
      flat,
      consumeTapEvents,
      position.toList(),
      rotation,
      infoWindow.toList(),
      visible,
      zIndex,
      icon.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ImageDescriptorDto(
  val registeredImageId: String? = null,
  val imagePixelRatio: Double? = null,
  val width: Double? = null,
  val height: Double? = null
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ImageDescriptorDto {
      val registeredImageId = list[0] as String?
      val imagePixelRatio = list[1] as Double?
      val width = list[2] as Double?
      val height = list[3] as Double?
      return ImageDescriptorDto(registeredImageId, imagePixelRatio, width, height)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      registeredImageId,
      imagePixelRatio,
      width,
      height,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class InfoWindowDto(
  val title: String? = null,
  val snippet: String? = null,
  val anchor: MarkerAnchorDto
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): InfoWindowDto {
      val title = list[0] as String?
      val snippet = list[1] as String?
      val anchor = MarkerAnchorDto.fromList(list[2] as List<Any?>)
      return InfoWindowDto(title, snippet, anchor)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      title,
      snippet,
      anchor.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class MarkerAnchorDto(val u: Double, val v: Double) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): MarkerAnchorDto {
      val u = list[0] as Double
      val v = list[1] as Double
      return MarkerAnchorDto(u, v)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      u,
      v,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PolygonDto(val polygonId: String, val options: PolygonOptionsDto) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): PolygonDto {
      val polygonId = list[0] as String
      val options = PolygonOptionsDto.fromList(list[1] as List<Any?>)
      return PolygonDto(polygonId, options)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      polygonId,
      options.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PolygonOptionsDto(
  val points: List<LatLngDto?>,
  val holes: List<PolygonHoleDto?>,
  val clickable: Boolean,
  val fillColor: Long,
  val geodesic: Boolean,
  val strokeColor: Long,
  val strokeWidth: Double,
  val visible: Boolean,
  val zIndex: Double
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): PolygonOptionsDto {
      val points = list[0] as List<LatLngDto?>
      val holes = list[1] as List<PolygonHoleDto?>
      val clickable = list[2] as Boolean
      val fillColor = list[3].let { if (it is Int) it.toLong() else it as Long }
      val geodesic = list[4] as Boolean
      val strokeColor = list[5].let { if (it is Int) it.toLong() else it as Long }
      val strokeWidth = list[6] as Double
      val visible = list[7] as Boolean
      val zIndex = list[8] as Double
      return PolygonOptionsDto(
        points,
        holes,
        clickable,
        fillColor,
        geodesic,
        strokeColor,
        strokeWidth,
        visible,
        zIndex
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      points,
      holes,
      clickable,
      fillColor,
      geodesic,
      strokeColor,
      strokeWidth,
      visible,
      zIndex,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PolygonHoleDto(val points: List<LatLngDto?>) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): PolygonHoleDto {
      val points = list[0] as List<LatLngDto?>
      return PolygonHoleDto(points)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      points,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class StyleSpanStrokeStyleDto(
  val solidColor: Long? = null,
  val fromColor: Long? = null,
  val toColor: Long? = null
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): StyleSpanStrokeStyleDto {
      val solidColor = list[0].let { if (it is Int) it.toLong() else it as Long? }
      val fromColor = list[1].let { if (it is Int) it.toLong() else it as Long? }
      val toColor = list[2].let { if (it is Int) it.toLong() else it as Long? }
      return StyleSpanStrokeStyleDto(solidColor, fromColor, toColor)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      solidColor,
      fromColor,
      toColor,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class StyleSpanDto(val length: Double, val style: StyleSpanStrokeStyleDto) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): StyleSpanDto {
      val length = list[0] as Double
      val style = StyleSpanStrokeStyleDto.fromList(list[1] as List<Any?>)
      return StyleSpanDto(length, style)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      length,
      style.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PolylineDto(val polylineId: String, val options: PolylineOptionsDto) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): PolylineDto {
      val polylineId = list[0] as String
      val options = PolylineOptionsDto.fromList(list[1] as List<Any?>)
      return PolylineDto(polylineId, options)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      polylineId,
      options.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PatternItemDto(val type: PatternTypeDto, val length: Double? = null) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): PatternItemDto {
      val type = PatternTypeDto.ofRaw(list[0] as Int)!!
      val length = list[1] as Double?
      return PatternItemDto(type, length)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      type.raw,
      length,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PolylineOptionsDto(
  val points: List<LatLngDto?>? = null,
  val clickable: Boolean? = null,
  val geodesic: Boolean? = null,
  val strokeColor: Long? = null,
  val strokeJointType: StrokeJointTypeDto? = null,
  val strokePattern: List<PatternItemDto?>? = null,
  val strokeWidth: Double? = null,
  val visible: Boolean? = null,
  val zIndex: Double? = null,
  val spans: List<StyleSpanDto?>
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): PolylineOptionsDto {
      val points = list[0] as List<LatLngDto?>?
      val clickable = list[1] as Boolean?
      val geodesic = list[2] as Boolean?
      val strokeColor = list[3].let { if (it is Int) it.toLong() else it as Long? }
      val strokeJointType: StrokeJointTypeDto? =
        (list[4] as Int?)?.let { StrokeJointTypeDto.ofRaw(it) }
      val strokePattern = list[5] as List<PatternItemDto?>?
      val strokeWidth = list[6] as Double?
      val visible = list[7] as Boolean?
      val zIndex = list[8] as Double?
      val spans = list[9] as List<StyleSpanDto?>
      return PolylineOptionsDto(
        points,
        clickable,
        geodesic,
        strokeColor,
        strokeJointType,
        strokePattern,
        strokeWidth,
        visible,
        zIndex,
        spans
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      points,
      clickable,
      geodesic,
      strokeColor,
      strokeJointType?.raw,
      strokePattern,
      strokeWidth,
      visible,
      zIndex,
      spans,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class CircleDto(
  /** Identifies circle. */
  val circleId: String,
  /** Options for circle. */
  val options: CircleOptionsDto
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): CircleDto {
      val circleId = list[0] as String
      val options = CircleOptionsDto.fromList(list[1] as List<Any?>)
      return CircleDto(circleId, options)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      circleId,
      options.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class CircleOptionsDto(
  val position: LatLngDto,
  val radius: Double,
  val strokeWidth: Double,
  val strokeColor: Long,
  val strokePattern: List<PatternItemDto?>,
  val fillColor: Long,
  val zIndex: Double,
  val visible: Boolean,
  val clickable: Boolean
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): CircleOptionsDto {
      val position = LatLngDto.fromList(list[0] as List<Any?>)
      val radius = list[1] as Double
      val strokeWidth = list[2] as Double
      val strokeColor = list[3].let { if (it is Int) it.toLong() else it as Long }
      val strokePattern = list[4] as List<PatternItemDto?>
      val fillColor = list[5].let { if (it is Int) it.toLong() else it as Long }
      val zIndex = list[6] as Double
      val visible = list[7] as Boolean
      val clickable = list[8] as Boolean
      return CircleOptionsDto(
        position,
        radius,
        strokeWidth,
        strokeColor,
        strokePattern,
        fillColor,
        zIndex,
        visible,
        clickable
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      position.toList(),
      radius,
      strokeWidth,
      strokeColor,
      strokePattern,
      fillColor,
      zIndex,
      visible,
      clickable,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class NavigationSessionEventDto(val type: NavigationSessionEventTypeDto, val message: String) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): NavigationSessionEventDto {
      val type = NavigationSessionEventTypeDto.ofRaw(list[0] as Int)!!
      val message = list[1] as String
      return NavigationSessionEventDto(type, message)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      type.raw,
      message,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RouteTokenOptionsDto(val routeToken: String, val travelMode: TravelModeDto? = null) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): RouteTokenOptionsDto {
      val routeToken = list[0] as String
      val travelMode: TravelModeDto? = (list[1] as Int?)?.let { TravelModeDto.ofRaw(it) }
      return RouteTokenOptionsDto(routeToken, travelMode)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      routeToken,
      travelMode?.raw,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class DestinationsDto(
  val waypoints: List<NavigationWaypointDto?>,
  val displayOptions: NavigationDisplayOptionsDto,
  val routingOptions: RoutingOptionsDto? = null,
  val routeTokenOptions: RouteTokenOptionsDto? = null
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): DestinationsDto {
      val waypoints = list[0] as List<NavigationWaypointDto?>
      val displayOptions = NavigationDisplayOptionsDto.fromList(list[1] as List<Any?>)
      val routingOptions: RoutingOptionsDto? =
        (list[2] as List<Any?>?)?.let { RoutingOptionsDto.fromList(it) }
      val routeTokenOptions: RouteTokenOptionsDto? =
        (list[3] as List<Any?>?)?.let { RouteTokenOptionsDto.fromList(it) }
      return DestinationsDto(waypoints, displayOptions, routingOptions, routeTokenOptions)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      waypoints,
      displayOptions.toList(),
      routingOptions?.toList(),
      routeTokenOptions?.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RoutingOptionsDto(
  val alternateRoutesStrategy: AlternateRoutesStrategyDto? = null,
  val routingStrategy: RoutingStrategyDto? = null,
  val targetDistanceMeters: List<Long?>? = null,
  val travelMode: TravelModeDto? = null,
  val avoidTolls: Boolean? = null,
  val avoidFerries: Boolean? = null,
  val avoidHighways: Boolean? = null,
  val locationTimeoutMs: Long? = null
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): RoutingOptionsDto {
      val alternateRoutesStrategy: AlternateRoutesStrategyDto? =
        (list[0] as Int?)?.let { AlternateRoutesStrategyDto.ofRaw(it) }
      val routingStrategy: RoutingStrategyDto? =
        (list[1] as Int?)?.let { RoutingStrategyDto.ofRaw(it) }
      val targetDistanceMeters = list[2] as List<Long?>?
      val travelMode: TravelModeDto? = (list[3] as Int?)?.let { TravelModeDto.ofRaw(it) }
      val avoidTolls = list[4] as Boolean?
      val avoidFerries = list[5] as Boolean?
      val avoidHighways = list[6] as Boolean?
      val locationTimeoutMs = list[7].let { if (it is Int) it.toLong() else it as Long? }
      return RoutingOptionsDto(
        alternateRoutesStrategy,
        routingStrategy,
        targetDistanceMeters,
        travelMode,
        avoidTolls,
        avoidFerries,
        avoidHighways,
        locationTimeoutMs
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      alternateRoutesStrategy?.raw,
      routingStrategy?.raw,
      targetDistanceMeters,
      travelMode?.raw,
      avoidTolls,
      avoidFerries,
      avoidHighways,
      locationTimeoutMs,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class NavigationDisplayOptionsDto(
  val showDestinationMarkers: Boolean? = null,
  val showStopSigns: Boolean? = null,
  val showTrafficLights: Boolean? = null
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): NavigationDisplayOptionsDto {
      val showDestinationMarkers = list[0] as Boolean?
      val showStopSigns = list[1] as Boolean?
      val showTrafficLights = list[2] as Boolean?
      return NavigationDisplayOptionsDto(showDestinationMarkers, showStopSigns, showTrafficLights)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      showDestinationMarkers,
      showStopSigns,
      showTrafficLights,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class NavigationWaypointDto(
  val title: String,
  val target: LatLngDto? = null,
  val placeID: String? = null,
  val preferSameSideOfRoad: Boolean? = null,
  val preferredSegmentHeading: Long? = null
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): NavigationWaypointDto {
      val title = list[0] as String
      val target: LatLngDto? = (list[1] as List<Any?>?)?.let { LatLngDto.fromList(it) }
      val placeID = list[2] as String?
      val preferSameSideOfRoad = list[3] as Boolean?
      val preferredSegmentHeading = list[4].let { if (it is Int) it.toLong() else it as Long? }
      return NavigationWaypointDto(
        title,
        target,
        placeID,
        preferSameSideOfRoad,
        preferredSegmentHeading
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      title,
      target?.toList(),
      placeID,
      preferSameSideOfRoad,
      preferredSegmentHeading,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class NavigationTimeAndDistanceDto(val time: Double, val distance: Double) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): NavigationTimeAndDistanceDto {
      val time = list[0] as Double
      val distance = list[1] as Double
      return NavigationTimeAndDistanceDto(time, distance)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      time,
      distance,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class NavigationAudioGuidanceSettingsDto(
  val isBluetoothAudioEnabled: Boolean? = null,
  val isVibrationEnabled: Boolean? = null,
  val guidanceType: AudioGuidanceTypeDto? = null
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): NavigationAudioGuidanceSettingsDto {
      val isBluetoothAudioEnabled = list[0] as Boolean?
      val isVibrationEnabled = list[1] as Boolean?
      val guidanceType: AudioGuidanceTypeDto? =
        (list[2] as Int?)?.let { AudioGuidanceTypeDto.ofRaw(it) }
      return NavigationAudioGuidanceSettingsDto(
        isBluetoothAudioEnabled,
        isVibrationEnabled,
        guidanceType
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      isBluetoothAudioEnabled,
      isVibrationEnabled,
      guidanceType?.raw,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SimulationOptionsDto(val speedMultiplier: Double) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): SimulationOptionsDto {
      val speedMultiplier = list[0] as Double
      return SimulationOptionsDto(speedMultiplier)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      speedMultiplier,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LatLngDto(val latitude: Double, val longitude: Double) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): LatLngDto {
      val latitude = list[0] as Double
      val longitude = list[1] as Double
      return LatLngDto(latitude, longitude)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      latitude,
      longitude,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LatLngBoundsDto(val southwest: LatLngDto, val northeast: LatLngDto) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): LatLngBoundsDto {
      val southwest = LatLngDto.fromList(list[0] as List<Any?>)
      val northeast = LatLngDto.fromList(list[1] as List<Any?>)
      return LatLngBoundsDto(southwest, northeast)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      southwest.toList(),
      northeast.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SpeedingUpdatedEventDto(
  val percentageAboveLimit: Double,
  val severity: SpeedAlertSeverityDto
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): SpeedingUpdatedEventDto {
      val percentageAboveLimit = list[0] as Double
      val severity = SpeedAlertSeverityDto.ofRaw(list[1] as Int)!!
      return SpeedingUpdatedEventDto(percentageAboveLimit, severity)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      percentageAboveLimit,
      severity.raw,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class OnArrivalEventDto(val waypoint: NavigationWaypointDto) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): OnArrivalEventDto {
      val waypoint = NavigationWaypointDto.fromList(list[0] as List<Any?>)
      return OnArrivalEventDto(waypoint)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      waypoint.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RemainingTimeOrDistanceChangedEventDto(
  val remainingTime: Double,
  val remainingDistance: Double
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): RemainingTimeOrDistanceChangedEventDto {
      val remainingTime = list[0] as Double
      val remainingDistance = list[1] as Double
      return RemainingTimeOrDistanceChangedEventDto(remainingTime, remainingDistance)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      remainingTime,
      remainingDistance,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RouteChangedEventDto(val message: String) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): RouteChangedEventDto {
      val message = list[0] as String
      return RouteChangedEventDto(message)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      message,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ReroutingEventDto(val message: String) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ReroutingEventDto {
      val message = list[0] as String
      return ReroutingEventDto(message)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      message,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class TrafficUpdatedEventDto(val message: String) {

  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): TrafficUpdatedEventDto {
      val message = list[0] as String
      return TrafficUpdatedEventDto(message)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      message,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SpeedAlertOptionsDto(
  val severityUpgradeDurationSeconds: Double,
  val minorSpeedAlertThresholdPercentage: Double,
  val majorSpeedAlertThresholdPercentage: Double
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): SpeedAlertOptionsDto {
      val severityUpgradeDurationSeconds = list[0] as Double
      val minorSpeedAlertThresholdPercentage = list[1] as Double
      val majorSpeedAlertThresholdPercentage = list[2] as Double
      return SpeedAlertOptionsDto(
        severityUpgradeDurationSeconds,
        minorSpeedAlertThresholdPercentage,
        majorSpeedAlertThresholdPercentage
      )
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      severityUpgradeDurationSeconds,
      minorSpeedAlertThresholdPercentage,
      majorSpeedAlertThresholdPercentage,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RouteSegmentTrafficDataRoadStretchRenderingDataDto(
  val style: RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto,
  val lengthMeters: Long,
  val offsetMeters: Long
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): RouteSegmentTrafficDataRoadStretchRenderingDataDto {
      val style = RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto.ofRaw(list[0] as Int)!!
      val lengthMeters = list[1].let { if (it is Int) it.toLong() else it as Long }
      val offsetMeters = list[2].let { if (it is Int) it.toLong() else it as Long }
      return RouteSegmentTrafficDataRoadStretchRenderingDataDto(style, lengthMeters, offsetMeters)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      style.raw,
      lengthMeters,
      offsetMeters,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RouteSegmentTrafficDataDto(
  val status: RouteSegmentTrafficDataStatusDto,
  val roadStretchRenderingDataList: List<RouteSegmentTrafficDataRoadStretchRenderingDataDto?>
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): RouteSegmentTrafficDataDto {
      val status = RouteSegmentTrafficDataStatusDto.ofRaw(list[0] as Int)!!
      val roadStretchRenderingDataList =
        list[1] as List<RouteSegmentTrafficDataRoadStretchRenderingDataDto?>
      return RouteSegmentTrafficDataDto(status, roadStretchRenderingDataList)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      status.raw,
      roadStretchRenderingDataList,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RouteSegmentDto(
  val trafficData: RouteSegmentTrafficDataDto? = null,
  val destinationLatLng: LatLngDto,
  val latLngs: List<LatLngDto?>? = null,
  val destinationWaypoint: NavigationWaypointDto? = null
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): RouteSegmentDto {
      val trafficData: RouteSegmentTrafficDataDto? =
        (list[0] as List<Any?>?)?.let { RouteSegmentTrafficDataDto.fromList(it) }
      val destinationLatLng = LatLngDto.fromList(list[1] as List<Any?>)
      val latLngs = list[2] as List<LatLngDto?>?
      val destinationWaypoint: NavigationWaypointDto? =
        (list[3] as List<Any?>?)?.let { NavigationWaypointDto.fromList(it) }
      return RouteSegmentDto(trafficData, destinationLatLng, latLngs, destinationWaypoint)
    }
  }

  fun toList(): List<Any?> {
    return listOf<Any?>(
      trafficData?.toList(),
      destinationLatLng.toList(),
      latLngs,
      destinationWaypoint?.toList(),
    )
  }
}

@Suppress("UNCHECKED_CAST")
private object _NavigationViewCreationApiCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { CameraPositionDto.fromList(it) }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LatLngBoundsDto.fromList(it) }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LatLngDto.fromList(it) }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { MapOptionsDto.fromList(it) }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          NavigationViewCreationOptionsDto.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavigationViewOptionsDto.fromList(it) }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }

  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is CameraPositionDto -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is LatLngBoundsDto -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is LatLngDto -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is MapOptionsDto -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is NavigationViewCreationOptionsDto -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is NavigationViewOptionsDto -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Pigeon only generates messages if the messages are used in API. [MapOptionsDto] is encoded and
 * decoded directly to generate a PlatformView creation message. This API should never be used
 * directly.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface _NavigationViewCreationApi {
  fun _create(msg: NavigationViewCreationOptionsDto)

  companion object {
    /** The codec used by _NavigationViewCreationApi. */
    val codec: MessageCodec<Any?> by lazy { _NavigationViewCreationApiCodec }
    /**
     * Sets up an instance of `_NavigationViewCreationApi` to handle messages through the
     * `binaryMessenger`.
     */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: _NavigationViewCreationApi?) {
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation._NavigationViewCreationApi._create",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val msgArg = args[0] as NavigationViewCreationOptionsDto
            var wrapped: List<Any?>
            try {
              api._create(msgArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

@Suppress("UNCHECKED_CAST")
private object NavigationViewApiCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { CameraPositionDto.fromList(it) }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { CircleDto.fromList(it) }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { CircleOptionsDto.fromList(it) }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { ImageDescriptorDto.fromList(it) }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { InfoWindowDto.fromList(it) }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LatLngBoundsDto.fromList(it) }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LatLngDto.fromList(it) }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LatLngDto.fromList(it) }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { MarkerAnchorDto.fromList(it) }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { MarkerDto.fromList(it) }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { MarkerOptionsDto.fromList(it) }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PatternItemDto.fromList(it) }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PolygonDto.fromList(it) }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PolygonHoleDto.fromList(it) }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PolygonOptionsDto.fromList(it) }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PolylineDto.fromList(it) }
      }
      144.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PolylineOptionsDto.fromList(it) }
      }
      145.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { StyleSpanDto.fromList(it) }
      }
      146.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { StyleSpanStrokeStyleDto.fromList(it) }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }

  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is CameraPositionDto -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is CircleDto -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is CircleOptionsDto -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is ImageDescriptorDto -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is InfoWindowDto -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is LatLngBoundsDto -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is LatLngDto -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is LatLngDto -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is MarkerAnchorDto -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is MarkerDto -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is MarkerOptionsDto -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is PatternItemDto -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is PolygonDto -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is PolygonHoleDto -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is PolygonOptionsDto -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is PolylineDto -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      is PolylineOptionsDto -> {
        stream.write(144)
        writeValue(stream, value.toList())
      }
      is StyleSpanDto -> {
        stream.write(145)
        writeValue(stream, value.toList())
      }
      is StyleSpanStrokeStyleDto -> {
        stream.write(146)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface NavigationViewApi {
  fun awaitMapReady(viewId: Long, callback: (Result<Unit>) -> Unit)

  fun isMyLocationEnabled(viewId: Long): Boolean

  fun setMyLocationEnabled(viewId: Long, enabled: Boolean)

  fun getMyLocation(viewId: Long): LatLngDto?

  fun getMapType(viewId: Long): MapTypeDto

  fun setMapType(viewId: Long, mapType: MapTypeDto)

  fun setMapStyle(viewId: Long, styleJson: String)

  fun isNavigationTripProgressBarEnabled(viewId: Long): Boolean

  fun setNavigationTripProgressBarEnabled(viewId: Long, enabled: Boolean)

  fun isNavigationHeaderEnabled(viewId: Long): Boolean

  fun setNavigationHeaderEnabled(viewId: Long, enabled: Boolean)

  fun isNavigationFooterEnabled(viewId: Long): Boolean

  fun setNavigationFooterEnabled(viewId: Long, enabled: Boolean)

  fun isRecenterButtonEnabled(viewId: Long): Boolean

  fun setRecenterButtonEnabled(viewId: Long, enabled: Boolean)

  fun isSpeedLimitIconEnabled(viewId: Long): Boolean

  fun setSpeedLimitIconEnabled(viewId: Long, enabled: Boolean)

  fun isSpeedometerEnabled(viewId: Long): Boolean

  fun setSpeedometerEnabled(viewId: Long, enabled: Boolean)

  fun isIncidentCardsEnabled(viewId: Long): Boolean

  fun setIncidentCardsEnabled(viewId: Long, enabled: Boolean)

  fun isNavigationUIEnabled(viewId: Long): Boolean

  fun setNavigationUIEnabled(viewId: Long, enabled: Boolean)

  fun getCameraPosition(viewId: Long): CameraPositionDto

  fun getVisibleRegion(viewId: Long): LatLngBoundsDto

  fun followMyLocation(viewId: Long, perspective: CameraPerspectiveDto, zoomLevel: Double?)

  fun animateCameraToCameraPosition(
    viewId: Long,
    cameraPosition: CameraPositionDto,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit
  )

  fun animateCameraToLatLng(
    viewId: Long,
    point: LatLngDto,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit
  )

  fun animateCameraToLatLngBounds(
    viewId: Long,
    bounds: LatLngBoundsDto,
    padding: Double,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit
  )

  fun animateCameraToLatLngZoom(
    viewId: Long,
    point: LatLngDto,
    zoom: Double,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit
  )

  fun animateCameraByScroll(
    viewId: Long,
    scrollByDx: Double,
    scrollByDy: Double,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit
  )

  fun animateCameraByZoom(
    viewId: Long,
    zoomBy: Double,
    focusDx: Double?,
    focusDy: Double?,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit
  )

  fun animateCameraToZoom(
    viewId: Long,
    zoom: Double,
    duration: Long?,
    callback: (Result<Boolean>) -> Unit
  )

  fun moveCameraToCameraPosition(viewId: Long, cameraPosition: CameraPositionDto)

  fun moveCameraToLatLng(viewId: Long, point: LatLngDto)

  fun moveCameraToLatLngBounds(viewId: Long, bounds: LatLngBoundsDto, padding: Double)

  fun moveCameraToLatLngZoom(viewId: Long, point: LatLngDto, zoom: Double)

  fun moveCameraByScroll(viewId: Long, scrollByDx: Double, scrollByDy: Double)

  fun moveCameraByZoom(viewId: Long, zoomBy: Double, focusDx: Double?, focusDy: Double?)

  fun moveCameraToZoom(viewId: Long, zoom: Double)

  fun showRouteOverview(viewId: Long)

  fun getMinZoomPreference(viewId: Long): Double

  fun getMaxZoomPreference(viewId: Long): Double

  fun resetMinMaxZoomPreference(viewId: Long)

  fun setMinZoomPreference(viewId: Long, minZoomPreference: Double)

  fun setMaxZoomPreference(viewId: Long, maxZoomPreference: Double)

  fun setMyLocationButtonEnabled(viewId: Long, enabled: Boolean)

  fun setConsumeMyLocationButtonClickEventsEnabled(viewId: Long, enabled: Boolean)

  fun setZoomGesturesEnabled(viewId: Long, enabled: Boolean)

  fun setZoomControlsEnabled(viewId: Long, enabled: Boolean)

  fun setCompassEnabled(viewId: Long, enabled: Boolean)

  fun setRotateGesturesEnabled(viewId: Long, enabled: Boolean)

  fun setScrollGesturesEnabled(viewId: Long, enabled: Boolean)

  fun setScrollGesturesDuringRotateOrZoomEnabled(viewId: Long, enabled: Boolean)

  fun setTiltGesturesEnabled(viewId: Long, enabled: Boolean)

  fun setMapToolbarEnabled(viewId: Long, enabled: Boolean)

  fun setTrafficEnabled(viewId: Long, enabled: Boolean)

  fun isMyLocationButtonEnabled(viewId: Long): Boolean

  fun isConsumeMyLocationButtonClickEventsEnabled(viewId: Long): Boolean

  fun isZoomGesturesEnabled(viewId: Long): Boolean

  fun isZoomControlsEnabled(viewId: Long): Boolean

  fun isCompassEnabled(viewId: Long): Boolean

  fun isRotateGesturesEnabled(viewId: Long): Boolean

  fun isScrollGesturesEnabled(viewId: Long): Boolean

  fun isScrollGesturesEnabledDuringRotateOrZoom(viewId: Long): Boolean

  fun isTiltGesturesEnabled(viewId: Long): Boolean

  fun isMapToolbarEnabled(viewId: Long): Boolean

  fun isTrafficEnabled(viewId: Long): Boolean

  fun getMarkers(viewId: Long): List<MarkerDto>

  fun addMarkers(viewId: Long, markers: List<MarkerDto>): List<MarkerDto>

  fun updateMarkers(viewId: Long, markers: List<MarkerDto>): List<MarkerDto>

  fun removeMarkers(viewId: Long, markers: List<MarkerDto>)

  fun clearMarkers(viewId: Long)

  fun clear(viewId: Long)

  fun getPolygons(viewId: Long): List<PolygonDto>

  fun addPolygons(viewId: Long, polygons: List<PolygonDto>): List<PolygonDto>

  fun updatePolygons(viewId: Long, polygons: List<PolygonDto>): List<PolygonDto>

  fun removePolygons(viewId: Long, polygons: List<PolygonDto>)

  fun clearPolygons(viewId: Long)

  fun getPolylines(viewId: Long): List<PolylineDto>

  fun addPolylines(viewId: Long, polylines: List<PolylineDto>): List<PolylineDto>

  fun updatePolylines(viewId: Long, polylines: List<PolylineDto>): List<PolylineDto>

  fun removePolylines(viewId: Long, polylines: List<PolylineDto>)

  fun clearPolylines(viewId: Long)

  fun getCircles(viewId: Long): List<CircleDto>

  fun addCircles(viewId: Long, circles: List<CircleDto>): List<CircleDto>

  fun updateCircles(viewId: Long, circles: List<CircleDto>): List<CircleDto>

  fun removeCircles(viewId: Long, circles: List<CircleDto>)

  fun clearCircles(viewId: Long)

  fun registerOnCameraChangedListener(viewId: Long)

  companion object {
    /** The codec used by NavigationViewApi. */
    val codec: MessageCodec<Any?> by lazy { NavigationViewApiCodec }
    /**
     * Sets up an instance of `NavigationViewApi` to handle messages through the `binaryMessenger`.
     */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: NavigationViewApi?) {
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.awaitMapReady",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            api.awaitMapReady(viewIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isMyLocationEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isMyLocationEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMyLocationEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setMyLocationEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMyLocation",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getMyLocation(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMapType",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getMapType(viewIdArg).raw)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMapType",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val mapTypeArg = MapTypeDto.ofRaw(args[1] as Int)!!
            var wrapped: List<Any?>
            try {
              api.setMapType(viewIdArg, mapTypeArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMapStyle",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val styleJsonArg = args[1] as String
            var wrapped: List<Any?>
            try {
              api.setMapStyle(viewIdArg, styleJsonArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationTripProgressBarEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isNavigationTripProgressBarEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationTripProgressBarEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setNavigationTripProgressBarEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationHeaderEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isNavigationHeaderEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationHeaderEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setNavigationHeaderEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationFooterEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isNavigationFooterEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationFooterEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setNavigationFooterEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isRecenterButtonEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isRecenterButtonEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setRecenterButtonEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setRecenterButtonEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isSpeedLimitIconEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isSpeedLimitIconEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setSpeedLimitIconEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setSpeedLimitIconEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isSpeedometerEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isSpeedometerEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setSpeedometerEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setSpeedometerEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isIncidentCardsEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isIncidentCardsEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setIncidentCardsEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setIncidentCardsEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationUIEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isNavigationUIEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationUIEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setNavigationUIEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getCameraPosition",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getCameraPosition(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getVisibleRegion",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getVisibleRegion(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.followMyLocation",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val perspectiveArg = CameraPerspectiveDto.ofRaw(args[1] as Int)!!
            val zoomLevelArg = args[2] as Double?
            var wrapped: List<Any?>
            try {
              api.followMyLocation(viewIdArg, perspectiveArg, zoomLevelArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToCameraPosition",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val cameraPositionArg = args[1] as CameraPositionDto
            val durationArg = args[2].let { if (it is Int) it.toLong() else it as Long? }
            api.animateCameraToCameraPosition(viewIdArg, cameraPositionArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToLatLng",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val pointArg = args[1] as LatLngDto
            val durationArg = args[2].let { if (it is Int) it.toLong() else it as Long? }
            api.animateCameraToLatLng(viewIdArg, pointArg, durationArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToLatLngBounds",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val boundsArg = args[1] as LatLngBoundsDto
            val paddingArg = args[2] as Double
            val durationArg = args[3].let { if (it is Int) it.toLong() else it as Long? }
            api.animateCameraToLatLngBounds(viewIdArg, boundsArg, paddingArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToLatLngZoom",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val pointArg = args[1] as LatLngDto
            val zoomArg = args[2] as Double
            val durationArg = args[3].let { if (it is Int) it.toLong() else it as Long? }
            api.animateCameraToLatLngZoom(viewIdArg, pointArg, zoomArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraByScroll",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val scrollByDxArg = args[1] as Double
            val scrollByDyArg = args[2] as Double
            val durationArg = args[3].let { if (it is Int) it.toLong() else it as Long? }
            api.animateCameraByScroll(viewIdArg, scrollByDxArg, scrollByDyArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraByZoom",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val zoomByArg = args[1] as Double
            val focusDxArg = args[2] as Double?
            val focusDyArg = args[3] as Double?
            val durationArg = args[4].let { if (it is Int) it.toLong() else it as Long? }
            api.animateCameraByZoom(viewIdArg, zoomByArg, focusDxArg, focusDyArg, durationArg) {
              result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToZoom",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val zoomArg = args[1] as Double
            val durationArg = args[2].let { if (it is Int) it.toLong() else it as Long? }
            api.animateCameraToZoom(viewIdArg, zoomArg, durationArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToCameraPosition",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val cameraPositionArg = args[1] as CameraPositionDto
            var wrapped: List<Any?>
            try {
              api.moveCameraToCameraPosition(viewIdArg, cameraPositionArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToLatLng",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val pointArg = args[1] as LatLngDto
            var wrapped: List<Any?>
            try {
              api.moveCameraToLatLng(viewIdArg, pointArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToLatLngBounds",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val boundsArg = args[1] as LatLngBoundsDto
            val paddingArg = args[2] as Double
            var wrapped: List<Any?>
            try {
              api.moveCameraToLatLngBounds(viewIdArg, boundsArg, paddingArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToLatLngZoom",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val pointArg = args[1] as LatLngDto
            val zoomArg = args[2] as Double
            var wrapped: List<Any?>
            try {
              api.moveCameraToLatLngZoom(viewIdArg, pointArg, zoomArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraByScroll",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val scrollByDxArg = args[1] as Double
            val scrollByDyArg = args[2] as Double
            var wrapped: List<Any?>
            try {
              api.moveCameraByScroll(viewIdArg, scrollByDxArg, scrollByDyArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraByZoom",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val zoomByArg = args[1] as Double
            val focusDxArg = args[2] as Double?
            val focusDyArg = args[3] as Double?
            var wrapped: List<Any?>
            try {
              api.moveCameraByZoom(viewIdArg, zoomByArg, focusDxArg, focusDyArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToZoom",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val zoomArg = args[1] as Double
            var wrapped: List<Any?>
            try {
              api.moveCameraToZoom(viewIdArg, zoomArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.showRouteOverview",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.showRouteOverview(viewIdArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMinZoomPreference",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getMinZoomPreference(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMaxZoomPreference",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getMaxZoomPreference(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.resetMinMaxZoomPreference",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.resetMinMaxZoomPreference(viewIdArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMinZoomPreference",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val minZoomPreferenceArg = args[1] as Double
            var wrapped: List<Any?>
            try {
              api.setMinZoomPreference(viewIdArg, minZoomPreferenceArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMaxZoomPreference",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val maxZoomPreferenceArg = args[1] as Double
            var wrapped: List<Any?>
            try {
              api.setMaxZoomPreference(viewIdArg, maxZoomPreferenceArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMyLocationButtonEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setMyLocationButtonEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setConsumeMyLocationButtonClickEventsEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setConsumeMyLocationButtonClickEventsEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setZoomGesturesEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setZoomGesturesEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setZoomControlsEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setZoomControlsEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setCompassEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setCompassEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setRotateGesturesEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setRotateGesturesEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setScrollGesturesEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setScrollGesturesEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setScrollGesturesDuringRotateOrZoomEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setScrollGesturesDuringRotateOrZoomEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setTiltGesturesEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setTiltGesturesEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMapToolbarEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setMapToolbarEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setTrafficEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setTrafficEnabled(viewIdArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isMyLocationButtonEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isMyLocationButtonEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isConsumeMyLocationButtonClickEventsEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isConsumeMyLocationButtonClickEventsEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isZoomGesturesEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isZoomGesturesEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isZoomControlsEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isZoomControlsEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isCompassEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isCompassEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isRotateGesturesEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isRotateGesturesEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isScrollGesturesEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isScrollGesturesEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isScrollGesturesEnabledDuringRotateOrZoom",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isScrollGesturesEnabledDuringRotateOrZoom(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isTiltGesturesEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isTiltGesturesEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isMapToolbarEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isMapToolbarEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isTrafficEnabled",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isTrafficEnabled(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMarkers",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getMarkers(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addMarkers",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val markersArg = args[1] as List<MarkerDto>
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.addMarkers(viewIdArg, markersArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updateMarkers",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val markersArg = args[1] as List<MarkerDto>
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.updateMarkers(viewIdArg, markersArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removeMarkers",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val markersArg = args[1] as List<MarkerDto>
            var wrapped: List<Any?>
            try {
              api.removeMarkers(viewIdArg, markersArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearMarkers",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.clearMarkers(viewIdArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clear",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.clear(viewIdArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getPolygons",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getPolygons(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addPolygons",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val polygonsArg = args[1] as List<PolygonDto>
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.addPolygons(viewIdArg, polygonsArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updatePolygons",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val polygonsArg = args[1] as List<PolygonDto>
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.updatePolygons(viewIdArg, polygonsArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removePolygons",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val polygonsArg = args[1] as List<PolygonDto>
            var wrapped: List<Any?>
            try {
              api.removePolygons(viewIdArg, polygonsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearPolygons",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.clearPolygons(viewIdArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getPolylines",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getPolylines(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addPolylines",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val polylinesArg = args[1] as List<PolylineDto>
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.addPolylines(viewIdArg, polylinesArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updatePolylines",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val polylinesArg = args[1] as List<PolylineDto>
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.updatePolylines(viewIdArg, polylinesArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removePolylines",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val polylinesArg = args[1] as List<PolylineDto>
            var wrapped: List<Any?>
            try {
              api.removePolylines(viewIdArg, polylinesArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearPolylines",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.clearPolylines(viewIdArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getCircles",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getCircles(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addCircles",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val circlesArg = args[1] as List<CircleDto>
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.addCircles(viewIdArg, circlesArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updateCircles",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val circlesArg = args[1] as List<CircleDto>
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.updateCircles(viewIdArg, circlesArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removeCircles",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val circlesArg = args[1] as List<CircleDto>
            var wrapped: List<Any?>
            try {
              api.removeCircles(viewIdArg, circlesArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearCircles",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.clearCircles(viewIdArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.registerOnCameraChangedListener",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.registerOnCameraChangedListener(viewIdArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

@Suppress("UNCHECKED_CAST")
private object ImageRegistryApiCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { ImageDescriptorDto.fromList(it) }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { ImageDescriptorDto.fromList(it) }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }

  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is ImageDescriptorDto -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is ImageDescriptorDto -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface ImageRegistryApi {
  fun registerBitmapImage(
    imageId: String,
    bytes: ByteArray,
    imagePixelRatio: Double,
    width: Double?,
    height: Double?
  ): ImageDescriptorDto

  fun unregisterImage(imageDescriptor: ImageDescriptorDto)

  fun getRegisteredImages(): List<ImageDescriptorDto>

  fun clearRegisteredImages()

  companion object {
    /** The codec used by ImageRegistryApi. */
    val codec: MessageCodec<Any?> by lazy { ImageRegistryApiCodec }
    /**
     * Sets up an instance of `ImageRegistryApi` to handle messages through the `binaryMessenger`.
     */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: ImageRegistryApi?) {
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.registerBitmapImage",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imageIdArg = args[0] as String
            val bytesArg = args[1] as ByteArray
            val imagePixelRatioArg = args[2] as Double
            val widthArg = args[3] as Double?
            val heightArg = args[4] as Double?
            var wrapped: List<Any?>
            try {
              wrapped =
                listOf<Any?>(
                  api.registerBitmapImage(
                    imageIdArg,
                    bytesArg,
                    imagePixelRatioArg,
                    widthArg,
                    heightArg
                  )
                )
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.unregisterImage",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imageDescriptorArg = args[0] as ImageDescriptorDto
            var wrapped: List<Any?>
            try {
              api.unregisterImage(imageDescriptorArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.getRegisteredImages",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getRegisteredImages())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.clearRegisteredImages",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.clearRegisteredImages()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

@Suppress("UNCHECKED_CAST")
private object NavigationViewEventApiCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { CameraPositionDto.fromList(it) }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LatLngDto.fromList(it) }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }

  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is CameraPositionDto -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is LatLngDto -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
@Suppress("UNCHECKED_CAST")
class NavigationViewEventApi(private val binaryMessenger: BinaryMessenger) {
  companion object {
    /** The codec used by NavigationViewEventApi. */
    val codec: MessageCodec<Any?> by lazy { NavigationViewEventApiCodec }
  }

  fun onMapClickEvent(viewIdArg: Long, latLngArg: LatLngDto, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapClickEvent"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, latLngArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onMapLongClickEvent(viewIdArg: Long, latLngArg: LatLngDto, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapLongClickEvent"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, latLngArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onRecenterButtonClicked(viewIdArg: Long, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onRecenterButtonClicked"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onMarkerEvent(
    viewIdArg: Long,
    markerIdArg: String,
    eventTypeArg: MarkerEventTypeDto,
    callback: (Result<Unit>) -> Unit
  ) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerEvent"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, markerIdArg, eventTypeArg.raw)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onMarkerDragEvent(
    viewIdArg: Long,
    markerIdArg: String,
    eventTypeArg: MarkerDragEventTypeDto,
    positionArg: LatLngDto,
    callback: (Result<Unit>) -> Unit
  ) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerDragEvent"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, markerIdArg, eventTypeArg.raw, positionArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onPolygonClicked(viewIdArg: Long, polygonIdArg: String, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolygonClicked"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, polygonIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onPolylineClicked(viewIdArg: Long, polylineIdArg: String, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolylineClicked"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, polylineIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onCircleClicked(viewIdArg: Long, circleIdArg: String, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCircleClicked"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, circleIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onNavigationUIEnabledChanged(
    viewIdArg: Long,
    navigationUIEnabledArg: Boolean,
    callback: (Result<Unit>) -> Unit
  ) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onNavigationUIEnabledChanged"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, navigationUIEnabledArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onMyLocationClicked(viewIdArg: Long, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMyLocationClicked"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onMyLocationButtonClicked(viewIdArg: Long, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMyLocationButtonClicked"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onCameraChanged(
    viewIdArg: Long,
    eventTypeArg: CameraEventTypeDto,
    positionArg: CameraPositionDto,
    callback: (Result<Unit>) -> Unit
  ) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCameraChanged"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(viewIdArg, eventTypeArg.raw, positionArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }
}

@Suppress("UNCHECKED_CAST")
private object NavigationSessionApiCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { DestinationsDto.fromList(it) }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LatLngDto.fromList(it) }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LatLngDto.fromList(it) }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          NavigationAudioGuidanceSettingsDto.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavigationDisplayOptionsDto.fromList(it) }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavigationTimeAndDistanceDto.fromList(it) }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavigationWaypointDto.fromList(it) }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavigationWaypointDto.fromList(it) }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { RouteSegmentDto.fromList(it) }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { RouteSegmentDto.fromList(it) }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { RouteSegmentTrafficDataDto.fromList(it) }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RouteSegmentTrafficDataRoadStretchRenderingDataDto.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { RouteTokenOptionsDto.fromList(it) }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { RoutingOptionsDto.fromList(it) }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { SimulationOptionsDto.fromList(it) }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { SpeedAlertOptionsDto.fromList(it) }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }

  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is DestinationsDto -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is LatLngDto -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is LatLngDto -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is NavigationAudioGuidanceSettingsDto -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is NavigationDisplayOptionsDto -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is NavigationTimeAndDistanceDto -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is NavigationWaypointDto -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is NavigationWaypointDto -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is RouteSegmentDto -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is RouteSegmentDto -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is RouteSegmentTrafficDataDto -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is RouteSegmentTrafficDataRoadStretchRenderingDataDto -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is RouteTokenOptionsDto -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is RoutingOptionsDto -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is SimulationOptionsDto -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is SpeedAlertOptionsDto -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface NavigationSessionApi {
  /** General. */
  fun createNavigationSession(
    abnormalTerminationReportingEnabled: Boolean,
    callback: (Result<Unit>) -> Unit
  )

  fun isInitialized(): Boolean

  fun cleanup()

  fun showTermsAndConditionsDialog(
    title: String,
    companyName: String,
    shouldOnlyShowDriverAwarenessDisclaimer: Boolean,
    callback: (Result<Boolean>) -> Unit
  )

  fun areTermsAccepted(): Boolean

  fun resetTermsAccepted()

  fun getNavSDKVersion(): String
  /** Navigation. */
  fun isGuidanceRunning(): Boolean

  fun startGuidance()

  fun stopGuidance()

  fun setDestinations(msg: DestinationsDto, callback: (Result<RouteStatusDto>) -> Unit)

  fun clearDestinations()

  fun continueToNextDestination(): NavigationWaypointDto?

  fun getCurrentTimeAndDistance(): NavigationTimeAndDistanceDto

  fun setAudioGuidance(settings: NavigationAudioGuidanceSettingsDto)

  fun setSpeedAlertOptions(options: SpeedAlertOptionsDto)

  fun getRouteSegments(): List<RouteSegmentDto>

  fun getTraveledRoute(): List<LatLngDto>

  fun getCurrentRouteSegment(): RouteSegmentDto?
  /** Simulation */
  fun setUserLocation(location: LatLngDto)

  fun removeUserLocation()

  fun simulateLocationsAlongExistingRoute()

  fun simulateLocationsAlongExistingRouteWithOptions(options: SimulationOptionsDto)

  fun simulateLocationsAlongNewRoute(
    waypoints: List<NavigationWaypointDto>,
    callback: (Result<RouteStatusDto>) -> Unit
  )

  fun simulateLocationsAlongNewRouteWithRoutingOptions(
    waypoints: List<NavigationWaypointDto>,
    routingOptions: RoutingOptionsDto,
    callback: (Result<RouteStatusDto>) -> Unit
  )

  fun simulateLocationsAlongNewRouteWithRoutingAndSimulationOptions(
    waypoints: List<NavigationWaypointDto>,
    routingOptions: RoutingOptionsDto,
    simulationOptions: SimulationOptionsDto,
    callback: (Result<RouteStatusDto>) -> Unit
  )

  fun pauseSimulation()

  fun resumeSimulation()
  /** Simulation (iOS only) */
  fun allowBackgroundLocationUpdates(allow: Boolean)
  /** Road snapped location updates. */
  fun enableRoadSnappedLocationUpdates()

  fun disableRoadSnappedLocationUpdates()

  fun registerRemainingTimeOrDistanceChangedListener(
    remainingTimeThresholdSeconds: Long,
    remainingDistanceThresholdMeters: Long
  )

  companion object {
    /** The codec used by NavigationSessionApi. */
    val codec: MessageCodec<Any?> by lazy { NavigationSessionApiCodec }
    /**
     * Sets up an instance of `NavigationSessionApi` to handle messages through the
     * `binaryMessenger`.
     */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: NavigationSessionApi?) {
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.createNavigationSession",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val abnormalTerminationReportingEnabledArg = args[0] as Boolean
            api.createNavigationSession(abnormalTerminationReportingEnabledArg) {
              result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.isInitialized",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isInitialized())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.cleanup",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.cleanup()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.showTermsAndConditionsDialog",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val titleArg = args[0] as String
            val companyNameArg = args[1] as String
            val shouldOnlyShowDriverAwarenessDisclaimerArg = args[2] as Boolean
            api.showTermsAndConditionsDialog(
              titleArg,
              companyNameArg,
              shouldOnlyShowDriverAwarenessDisclaimerArg
            ) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.areTermsAccepted",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.areTermsAccepted())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.resetTermsAccepted",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.resetTermsAccepted()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getNavSDKVersion",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getNavSDKVersion())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.isGuidanceRunning",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isGuidanceRunning())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.startGuidance",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.startGuidance()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.stopGuidance",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.stopGuidance()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setDestinations",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val msgArg = args[0] as DestinationsDto
            api.setDestinations(msgArg) { result: Result<RouteStatusDto> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data!!.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.clearDestinations",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.clearDestinations()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.continueToNextDestination",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.continueToNextDestination())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getCurrentTimeAndDistance",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getCurrentTimeAndDistance())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setAudioGuidance",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as NavigationAudioGuidanceSettingsDto
            var wrapped: List<Any?>
            try {
              api.setAudioGuidance(settingsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setSpeedAlertOptions",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val optionsArg = args[0] as SpeedAlertOptionsDto
            var wrapped: List<Any?>
            try {
              api.setSpeedAlertOptions(optionsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getRouteSegments",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getRouteSegments())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getTraveledRoute",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getTraveledRoute())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getCurrentRouteSegment",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getCurrentRouteSegment())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setUserLocation",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val locationArg = args[0] as LatLngDto
            var wrapped: List<Any?>
            try {
              api.setUserLocation(locationArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.removeUserLocation",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.removeUserLocation()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongExistingRoute",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.simulateLocationsAlongExistingRoute()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongExistingRouteWithOptions",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val optionsArg = args[0] as SimulationOptionsDto
            var wrapped: List<Any?>
            try {
              api.simulateLocationsAlongExistingRouteWithOptions(optionsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongNewRoute",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val waypointsArg = args[0] as List<NavigationWaypointDto>
            api.simulateLocationsAlongNewRoute(waypointsArg) { result: Result<RouteStatusDto> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data!!.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongNewRouteWithRoutingOptions",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val waypointsArg = args[0] as List<NavigationWaypointDto>
            val routingOptionsArg = args[1] as RoutingOptionsDto
            api.simulateLocationsAlongNewRouteWithRoutingOptions(waypointsArg, routingOptionsArg) {
              result: Result<RouteStatusDto> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data!!.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongNewRouteWithRoutingAndSimulationOptions",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val waypointsArg = args[0] as List<NavigationWaypointDto>
            val routingOptionsArg = args[1] as RoutingOptionsDto
            val simulationOptionsArg = args[2] as SimulationOptionsDto
            api.simulateLocationsAlongNewRouteWithRoutingAndSimulationOptions(
              waypointsArg,
              routingOptionsArg,
              simulationOptionsArg
            ) { result: Result<RouteStatusDto> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data!!.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.pauseSimulation",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.pauseSimulation()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.resumeSimulation",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.resumeSimulation()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.allowBackgroundLocationUpdates",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val allowArg = args[0] as Boolean
            var wrapped: List<Any?>
            try {
              api.allowBackgroundLocationUpdates(allowArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.enableRoadSnappedLocationUpdates",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.enableRoadSnappedLocationUpdates()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.disableRoadSnappedLocationUpdates",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.disableRoadSnappedLocationUpdates()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.registerRemainingTimeOrDistanceChangedListener",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val remainingTimeThresholdSecondsArg =
              args[0].let { if (it is Int) it.toLong() else it as Long }
            val remainingDistanceThresholdMetersArg =
              args[1].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.registerRemainingTimeOrDistanceChangedListener(
                remainingTimeThresholdSecondsArg,
                remainingDistanceThresholdMetersArg
              )
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

@Suppress("UNCHECKED_CAST")
private object NavigationSessionEventApiCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { LatLngDto.fromList(it) }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavigationSessionEventDto.fromList(it) }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { NavigationWaypointDto.fromList(it) }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { OnArrivalEventDto.fromList(it) }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RemainingTimeOrDistanceChangedEventDto.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { ReroutingEventDto.fromList(it) }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { RouteChangedEventDto.fromList(it) }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { SpeedingUpdatedEventDto.fromList(it) }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { TrafficUpdatedEventDto.fromList(it) }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }

  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is LatLngDto -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is NavigationSessionEventDto -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is NavigationWaypointDto -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is OnArrivalEventDto -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is RemainingTimeOrDistanceChangedEventDto -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is ReroutingEventDto -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is RouteChangedEventDto -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is SpeedingUpdatedEventDto -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is TrafficUpdatedEventDto -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
@Suppress("UNCHECKED_CAST")
class NavigationSessionEventApi(private val binaryMessenger: BinaryMessenger) {
  companion object {
    /** The codec used by NavigationSessionEventApi. */
    val codec: MessageCodec<Any?> by lazy { NavigationSessionEventApiCodec }
  }

  fun onNavigationSessionEvent(
    msgArg: NavigationSessionEventDto,
    callback: (Result<Unit>) -> Unit
  ) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onNavigationSessionEvent"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(msgArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onSpeedingUpdated(msgArg: SpeedingUpdatedEventDto, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onSpeedingUpdated"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(msgArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onRoadSnappedLocationUpdated(locationArg: LatLngDto, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRoadSnappedLocationUpdated"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(locationArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onRoadSnappedRawLocationUpdated(locationArg: LatLngDto, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRoadSnappedRawLocationUpdated"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(locationArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onArrival(msgArg: OnArrivalEventDto, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onArrival"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(msgArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onRouteChanged(msgArg: RouteChangedEventDto, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRouteChanged"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(msgArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }

  fun onRemainingTimeOrDistanceChanged(
    msgArg: RemainingTimeOrDistanceChangedEventDto,
    callback: (Result<Unit>) -> Unit
  ) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRemainingTimeOrDistanceChanged"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(msgArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }
  /** Android-only event. */
  fun onTrafficUpdated(msgArg: TrafficUpdatedEventDto, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onTrafficUpdated"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(msgArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }
  /** Android-only event. */
  fun onRerouting(msgArg: ReroutingEventDto, callback: (Result<Unit>) -> Unit) {
    val channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRerouting"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(msgArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface NavigationInspector {
  fun isViewAttachedToSession(viewId: Long): Boolean

  companion object {
    /** The codec used by NavigationInspector. */
    val codec: MessageCodec<Any?> by lazy { StandardMessageCodec() }
    /**
     * Sets up an instance of `NavigationInspector` to handle messages through the
     * `binaryMessenger`.
     */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: NavigationInspector?) {
      run {
        val channel =
          BasicMessageChannel<Any?>(
            binaryMessenger,
            "dev.flutter.pigeon.google_maps_navigation.NavigationInspector.isViewAttachedToSession",
            codec
          )
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val viewIdArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isViewAttachedToSession(viewIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
