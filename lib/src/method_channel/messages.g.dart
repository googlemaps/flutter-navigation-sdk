// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Autogenerated from Pigeon (v15.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse(
    {Object? result, PlatformException? error, bool empty = false}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

/// Determines the initial visibility of the navigation UI on map initialization.
enum NavigationUIEnabledPreferenceDto {
  /// Navigation UI gets enabled if the navigation
  /// session has already been successfully started.
  automatic,

  /// Navigation UI is disabled.
  disabled,
}

enum MapTypeDto {
  none,
  normal,
  satellite,
  terrain,
  hybrid,
}

enum CameraPerspectiveDto {
  tilted,
  topDownHeadingUp,
  topDownNorthUp,
}

enum MarkerEventTypeDto {
  clicked,
  infoWindowClicked,
  infoWindowClosed,
  infoWindowLongClicked,
}

enum MarkerDragEventTypeDto {
  drag,
  dragStart,
  dragEnd,
}

enum StrokeJointTypeDto {
  bevel,
  defaultJoint,
  round,
}

enum PatternTypeDto {
  dash,
  dot,
  gap,
}

enum CameraEventTypeDto {
  moveStartedByApi,
  moveStartedByGesture,
  onCameraMove,
  onCameraIdle,
  onCameraStartedFollowingLocation,
  onCameraStoppedFollowingLocation,
}

enum AlternateRoutesStrategyDto {
  all,
  none,
  one,
}

enum RoutingStrategyDto {
  defaultBest,
  deltaToTargetDistance,
  shorter,
}

enum TravelModeDto {
  driving,
  cycling,
  walking,
  twoWheeler,
  taxi,
}

enum RouteStatusDto {
  internalError,
  statusOk,
  routeNotFound,
  networkError,
  quotaExceeded,
  apiKeyNotAuthorized,
  statusCanceled,
  duplicateWaypointsError,
  noWaypointsError,
  locationUnavailable,
  waypointError,
  travelModeUnsupported,
  locationUnknown,
  quotaCheckFailed,
  unknown,
}

enum AudioGuidanceTypeDto {
  silent,
  alertsOnly,
  alertsAndGuidance,
}

enum SpeedAlertSeverityDto {
  unknown,
  notSpeeding,
  minor,
  major,
}

enum RouteSegmentTrafficDataStatusDto {
  ok,
  unavailable,
}

enum RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto {
  unknown,
  slowerTraffic,
  trafficJam,
}

/// A set of values that specify the navigation action to take.
enum ManeuverDto {
  /// Arrival at a destination.
  destination,

  /// Starting point of the maneuver.
  depart,

  /// Arrival at a destination located on the left side of the road.
  destinationLeft,

  /// Arrival at a destination located on the right side of the road.
  destinationRight,

  /// Take the boat ferry.
  ferryBoat,

  /// Take the train ferry.
  ferryTrain,

  /// Current road joins another road slightly on the left.
  forkLeft,

  /// Current road joins another road slightly on the right.
  forkRight,

  /// Current road joins another on the left.
  mergeLeft,

  /// Current road joins another on the right.
  mergeRight,

  /// Current road joins another.
  mergeUnspecified,

  /// The street name changes.
  nameChange,

  /// Keep to the left side of the road when exiting a turnpike or freeway as the road diverges.
  offRampKeepLeft,

  /// Keep to the right side of the road when exiting a turnpike or freeway as the road diverges.
  offRampKeepRight,

  /// Regular left turn to exit a turnpike or freeway.
  offRampLeft,

  /// Regular right turn to exit a turnpike or freeway.
  offRampRight,

  /// Sharp left turn to exit a turnpike or freeway.
  offRampSharpLeft,

  /// Sharp right turn to exit a turnpike or freeway.
  offRampSharpRight,

  /// Slight left turn to exit a turnpike or freeway.
  offRampSlightLeft,

  /// Slight right turn to exit a turnpike or freeway.
  offRampSlightRight,

  /// Exit a turnpike or freeway.
  offRampUnspecified,

  /// Clockwise turn onto the opposite side of the street to exit a turnpike or freeway.
  offRampUTurnClockwise,

  /// Counterclockwise turn onto the opposite side of the street to exit a turnpike or freeway.
  offRampUTurnCounterclockwise,

  /// Keep to the left side of the road when entering a turnpike or freeway as the road diverges.
  onRampKeepLeft,

  /// Keep to the right side of the road when entering a turnpike or freeway as the road diverges.
  onRampKeepRight,

  /// Regular left turn to enter a turnpike or freeway.
  onRampLeft,

  /// Regular right turn to enter a turnpike or freeway.
  onRampRight,

  /// Sharp left turn to enter a turnpike or freeway.
  onRampSharpLeft,

  /// Sharp right turn to enter a turnpike or freeway.
  onRampSharpRight,

  /// Slight left turn to enter a turnpike or freeway.
  onRampSlightLeft,

  /// Slight right turn to enter a turnpike or freeway.
  onRampSlightRight,

  /// Enter a turnpike or freeway.
  onRampUnspecified,

  /// Clockwise turn onto the opposite side of the street to enter a turnpike or freeway.
  onRampUTurnClockwise,

  /// Counterclockwise turn onto the opposite side of the street to enter a turnpike or freeway.
  onRampUTurnCounterclockwise,

  /// Enter a roundabout in the clockwise direction.
  roundaboutClockwise,

  /// Enter a roundabout in the counterclockwise direction.
  roundaboutCounterclockwise,

  /// Exit a roundabout in the clockwise direction.
  roundaboutExitClockwise,

  /// Exit a roundabout in the counterclockwise direction.
  roundaboutExitCounterclockwise,

  /// Enter a roundabout in the clockwise direction and turn left.
  roundaboutLeftClockwise,

  /// Enter a roundabout in the counterclockwise direction and turn left.
  roundaboutLeftCounterclockwise,

  /// Enter a roundabout in the clockwise direction and turn right.
  roundaboutRightClockwise,

  /// Enter a roundabout in the counterclockwise direction and turn right.
  roundaboutRightCounterclockwise,

  /// Enter a roundabout in the clockwise direction and turn sharply to the left.
  roundaboutSharpLeftClockwise,

  /// Enter a roundabout in the counterclockwise direction and turn sharply to the left.
  roundaboutSharpLeftCounterclockwise,

  /// Enter a roundabout in the clockwise direction and turn sharply to the right.
  roundaboutSharpRightClockwise,

  /// Enter a roundabout in the counterclockwise direction and turn sharply to the right.
  roundaboutSharpRightCounterclockwise,

  /// Enter a roundabout in the clockwise direction and turn slightly left.
  roundaboutSlightLeftClockwise,

  /// Enter a roundabout in the counterclockwise direction and turn slightly to the left.
  roundaboutSlightLeftCounterclockwise,

  /// Enter a roundabout in the clockwise direction and turn slightly to the right.
  roundaboutSlightRightClockwise,

  /// Enter a roundabout in the counterclockwise direction and turn slightly to the right.
  roundaboutSlightRightCounterclockwise,

  /// Enter a roundabout in the clockwise direction and continue straight.
  roundaboutStraightClockwise,

  /// Enter a roundabout in the counterclockwise direction and continue straight.
  roundaboutStraightCounterclockwise,

  /// Enter a roundabout in the clockwise direction and turn clockwise onto the opposite side of the street.
  roundaboutUTurnClockwise,

  /// Enter a roundabout in the counterclockwise direction and turn counterclockwise onto the opposite side of the street.
  roundaboutUTurnCounterclockwise,

  /// Continue straight.
  straight,

  /// Keep left as the road diverges.
  turnKeepLeft,

  /// Keep right as the road diverges.
  turnKeepRight,

  /// Regular left turn at an intersection.
  turnLeft,

  /// Regular right turn at an intersection.
  turnRight,

  /// Sharp left turn at an intersection.
  turnSharpLeft,

  /// Sharp right turn at an intersection.
  turnSharpRight,

  /// Slight left turn at an intersection.
  turnSlightLeft,

  /// Slight right turn at an intersection.
  turnSlightRight,

  /// Clockwise turn onto the opposite side of the street.
  turnUTurnClockwise,

  /// Counterclockwise turn onto the opposite side of the street.
  turnUTurnCounterclockwise,

  /// Unknown maneuver.
  unknown,
}

/// Whether this step is on a drive-on-right or drive-on-left route.
enum DrivingSideDto {
  /// Drive-on-left side.
  left,

  /// Unspecified side.
  none,

  /// Drive-on-right side.
  right,
}

/// The state of navigation.
enum NavStateDto {
  /// Actively navigating.
  enroute,

  /// Actively navigating but searching for a new route.
  rerouting,

  /// Navigation has ended.
  stopped,

  /// Error or unspecified state.
  unknown,
}

/// A set of values that specify the shape of the road path continuing from the Lane.
enum LaneShapeDto {
  /// Normal left turn (45-135 degrees).
  normalLeft,

  /// Normal right turn (45-135 degrees).
  normalRight,

  /// Sharp left turn (135-175 degrees).
  sharpLeft,

  /// Sharp right turn (135-175 degrees).
  sharpRight,

  /// Slight left turn (10-45 degrees).
  slightLeft,

  /// Slight right turn (10-45 degrees).
  slightRight,

  /// No turn.
  straight,

  /// Shape is unknown.
  unknown,

  /// A left turn onto the opposite side of the same street (175-180 degrees).
  uTurnLeft,

  /// A right turn onto the opposite side of the same street (175-180 degrees).
  uTurnRight,
}

/// Object containing map options used to initialize Google Map view.
class MapOptionsDto {
  MapOptionsDto({
    required this.cameraPosition,
    required this.mapType,
    required this.compassEnabled,
    required this.rotateGesturesEnabled,
    required this.scrollGesturesEnabled,
    required this.tiltGesturesEnabled,
    required this.zoomGesturesEnabled,
    required this.scrollGesturesEnabledDuringRotateOrZoom,
    required this.mapToolbarEnabled,
    this.minZoomPreference,
    this.maxZoomPreference,
    required this.zoomControlsEnabled,
    this.cameraTargetBounds,
  });

  /// The initial positioning of the camera in the map view.
  CameraPositionDto cameraPosition;

  /// The type of map to display (e.g., satellite, terrain, hybrid, etc.).
  MapTypeDto mapType;

  /// If true, enables the compass.
  bool compassEnabled;

  /// If true, enables the rotation gestures.
  bool rotateGesturesEnabled;

  /// If true, enables the scroll gestures.
  bool scrollGesturesEnabled;

  /// If true, enables the tilt gestures.
  bool tiltGesturesEnabled;

  /// If true, enables the zoom gestures.
  bool zoomGesturesEnabled;

  /// If true, enables the scroll gestures during rotate or zoom.
  bool scrollGesturesEnabledDuringRotateOrZoom;

  /// If true, enables the map toolbar.
  bool mapToolbarEnabled;

  /// The minimum zoom level that can be set for the map.
  double? minZoomPreference;

  /// The maximum zoom level that can be set for the map.
  double? maxZoomPreference;

  /// If true, enables zoom controls for the map.
  bool zoomControlsEnabled;

  /// Specifies a bounds to constrain the camera target, so that when users scroll and pan the map,
  /// the camera target does not move outside these bounds.
  LatLngBoundsDto? cameraTargetBounds;

  Object encode() {
    return <Object?>[
      cameraPosition.encode(),
      mapType.index,
      compassEnabled,
      rotateGesturesEnabled,
      scrollGesturesEnabled,
      tiltGesturesEnabled,
      zoomGesturesEnabled,
      scrollGesturesEnabledDuringRotateOrZoom,
      mapToolbarEnabled,
      minZoomPreference,
      maxZoomPreference,
      zoomControlsEnabled,
      cameraTargetBounds?.encode(),
    ];
  }

  static MapOptionsDto decode(Object result) {
    result as List<Object?>;
    return MapOptionsDto(
      cameraPosition: CameraPositionDto.decode(result[0]! as List<Object?>),
      mapType: MapTypeDto.values[result[1]! as int],
      compassEnabled: result[2]! as bool,
      rotateGesturesEnabled: result[3]! as bool,
      scrollGesturesEnabled: result[4]! as bool,
      tiltGesturesEnabled: result[5]! as bool,
      zoomGesturesEnabled: result[6]! as bool,
      scrollGesturesEnabledDuringRotateOrZoom: result[7]! as bool,
      mapToolbarEnabled: result[8]! as bool,
      minZoomPreference: result[9] as double?,
      maxZoomPreference: result[10] as double?,
      zoomControlsEnabled: result[11]! as bool,
      cameraTargetBounds: result[12] != null
          ? LatLngBoundsDto.decode(result[12]! as List<Object?>)
          : null,
    );
  }
}

/// Object containing navigation options used to initialize Google Navigation view.
class NavigationViewOptionsDto {
  NavigationViewOptionsDto({
    required this.navigationUIEnabledPreference,
  });

  /// Determines the initial visibility of the navigation UI on map initialization.
  NavigationUIEnabledPreferenceDto navigationUIEnabledPreference;

  Object encode() {
    return <Object?>[
      navigationUIEnabledPreference.index,
    ];
  }

  static NavigationViewOptionsDto decode(Object result) {
    result as List<Object?>;
    return NavigationViewOptionsDto(
      navigationUIEnabledPreference:
          NavigationUIEnabledPreferenceDto.values[result[0]! as int],
    );
  }
}

/// A message for creating a new navigation view.
///
/// This message is used to initialize a new navigation view with a
/// specified initial parameters.
class NavigationViewCreationOptionsDto {
  NavigationViewCreationOptionsDto({
    required this.mapOptions,
    required this.navigationViewOptions,
  });

  MapOptionsDto mapOptions;

  NavigationViewOptionsDto navigationViewOptions;

  Object encode() {
    return <Object?>[
      mapOptions.encode(),
      navigationViewOptions.encode(),
    ];
  }

  static NavigationViewCreationOptionsDto decode(Object result) {
    result as List<Object?>;
    return NavigationViewCreationOptionsDto(
      mapOptions: MapOptionsDto.decode(result[0]! as List<Object?>),
      navigationViewOptions:
          NavigationViewOptionsDto.decode(result[1]! as List<Object?>),
    );
  }
}

class CameraPositionDto {
  CameraPositionDto({
    required this.bearing,
    required this.target,
    required this.tilt,
    required this.zoom,
  });

  double bearing;

  LatLngDto target;

  double tilt;

  double zoom;

  Object encode() {
    return <Object?>[
      bearing,
      target.encode(),
      tilt,
      zoom,
    ];
  }

  static CameraPositionDto decode(Object result) {
    result as List<Object?>;
    return CameraPositionDto(
      bearing: result[0]! as double,
      target: LatLngDto.decode(result[1]! as List<Object?>),
      tilt: result[2]! as double,
      zoom: result[3]! as double,
    );
  }
}

class MarkerDto {
  MarkerDto({
    required this.markerId,
    required this.options,
  });

  /// Identifies marker
  String markerId;

  /// Options for marker
  MarkerOptionsDto options;

  Object encode() {
    return <Object?>[
      markerId,
      options.encode(),
    ];
  }

  static MarkerDto decode(Object result) {
    result as List<Object?>;
    return MarkerDto(
      markerId: result[0]! as String,
      options: MarkerOptionsDto.decode(result[1]! as List<Object?>),
    );
  }
}

class MarkerOptionsDto {
  MarkerOptionsDto({
    required this.alpha,
    required this.anchor,
    required this.draggable,
    required this.flat,
    required this.consumeTapEvents,
    required this.position,
    required this.rotation,
    required this.infoWindow,
    required this.visible,
    required this.zIndex,
    required this.icon,
  });

  double alpha;

  MarkerAnchorDto anchor;

  bool draggable;

  bool flat;

  bool consumeTapEvents;

  LatLngDto position;

  double rotation;

  InfoWindowDto infoWindow;

  bool visible;

  double zIndex;

  ImageDescriptorDto icon;

  Object encode() {
    return <Object?>[
      alpha,
      anchor.encode(),
      draggable,
      flat,
      consumeTapEvents,
      position.encode(),
      rotation,
      infoWindow.encode(),
      visible,
      zIndex,
      icon.encode(),
    ];
  }

  static MarkerOptionsDto decode(Object result) {
    result as List<Object?>;
    return MarkerOptionsDto(
      alpha: result[0]! as double,
      anchor: MarkerAnchorDto.decode(result[1]! as List<Object?>),
      draggable: result[2]! as bool,
      flat: result[3]! as bool,
      consumeTapEvents: result[4]! as bool,
      position: LatLngDto.decode(result[5]! as List<Object?>),
      rotation: result[6]! as double,
      infoWindow: InfoWindowDto.decode(result[7]! as List<Object?>),
      visible: result[8]! as bool,
      zIndex: result[9]! as double,
      icon: ImageDescriptorDto.decode(result[10]! as List<Object?>),
    );
  }
}

class ImageDescriptorDto {
  ImageDescriptorDto({
    this.registeredImageId,
    this.imagePixelRatio,
    this.width,
    this.height,
  });

  String? registeredImageId;

  double? imagePixelRatio;

  double? width;

  double? height;

  Object encode() {
    return <Object?>[
      registeredImageId,
      imagePixelRatio,
      width,
      height,
    ];
  }

  static ImageDescriptorDto decode(Object result) {
    result as List<Object?>;
    return ImageDescriptorDto(
      registeredImageId: result[0] as String?,
      imagePixelRatio: result[1] as double?,
      width: result[2] as double?,
      height: result[3] as double?,
    );
  }
}

class InfoWindowDto {
  InfoWindowDto({
    this.title,
    this.snippet,
    required this.anchor,
  });

  String? title;

  String? snippet;

  MarkerAnchorDto anchor;

  Object encode() {
    return <Object?>[
      title,
      snippet,
      anchor.encode(),
    ];
  }

  static InfoWindowDto decode(Object result) {
    result as List<Object?>;
    return InfoWindowDto(
      title: result[0] as String?,
      snippet: result[1] as String?,
      anchor: MarkerAnchorDto.decode(result[2]! as List<Object?>),
    );
  }
}

class MarkerAnchorDto {
  MarkerAnchorDto({
    required this.u,
    required this.v,
  });

  double u;

  double v;

  Object encode() {
    return <Object?>[
      u,
      v,
    ];
  }

  static MarkerAnchorDto decode(Object result) {
    result as List<Object?>;
    return MarkerAnchorDto(
      u: result[0]! as double,
      v: result[1]! as double,
    );
  }
}

class PolygonDto {
  PolygonDto({
    required this.polygonId,
    required this.options,
  });

  String polygonId;

  PolygonOptionsDto options;

  Object encode() {
    return <Object?>[
      polygonId,
      options.encode(),
    ];
  }

  static PolygonDto decode(Object result) {
    result as List<Object?>;
    return PolygonDto(
      polygonId: result[0]! as String,
      options: PolygonOptionsDto.decode(result[1]! as List<Object?>),
    );
  }
}

class PolygonOptionsDto {
  PolygonOptionsDto({
    required this.points,
    required this.holes,
    required this.clickable,
    required this.fillColor,
    required this.geodesic,
    required this.strokeColor,
    required this.strokeWidth,
    required this.visible,
    required this.zIndex,
  });

  List<LatLngDto?> points;

  List<PolygonHoleDto?> holes;

  bool clickable;

  int fillColor;

  bool geodesic;

  int strokeColor;

  double strokeWidth;

  bool visible;

  double zIndex;

  Object encode() {
    return <Object?>[
      points,
      holes,
      clickable,
      fillColor,
      geodesic,
      strokeColor,
      strokeWidth,
      visible,
      zIndex,
    ];
  }

  static PolygonOptionsDto decode(Object result) {
    result as List<Object?>;
    return PolygonOptionsDto(
      points: (result[0] as List<Object?>?)!.cast<LatLngDto?>(),
      holes: (result[1] as List<Object?>?)!.cast<PolygonHoleDto?>(),
      clickable: result[2]! as bool,
      fillColor: result[3]! as int,
      geodesic: result[4]! as bool,
      strokeColor: result[5]! as int,
      strokeWidth: result[6]! as double,
      visible: result[7]! as bool,
      zIndex: result[8]! as double,
    );
  }
}

class PolygonHoleDto {
  PolygonHoleDto({
    required this.points,
  });

  List<LatLngDto?> points;

  Object encode() {
    return <Object?>[
      points,
    ];
  }

  static PolygonHoleDto decode(Object result) {
    result as List<Object?>;
    return PolygonHoleDto(
      points: (result[0] as List<Object?>?)!.cast<LatLngDto?>(),
    );
  }
}

class StyleSpanStrokeStyleDto {
  StyleSpanStrokeStyleDto({
    this.solidColor,
    this.fromColor,
    this.toColor,
  });

  int? solidColor;

  int? fromColor;

  int? toColor;

  Object encode() {
    return <Object?>[
      solidColor,
      fromColor,
      toColor,
    ];
  }

  static StyleSpanStrokeStyleDto decode(Object result) {
    result as List<Object?>;
    return StyleSpanStrokeStyleDto(
      solidColor: result[0] as int?,
      fromColor: result[1] as int?,
      toColor: result[2] as int?,
    );
  }
}

class StyleSpanDto {
  StyleSpanDto({
    required this.length,
    required this.style,
  });

  double length;

  StyleSpanStrokeStyleDto style;

  Object encode() {
    return <Object?>[
      length,
      style.encode(),
    ];
  }

  static StyleSpanDto decode(Object result) {
    result as List<Object?>;
    return StyleSpanDto(
      length: result[0]! as double,
      style: StyleSpanStrokeStyleDto.decode(result[1]! as List<Object?>),
    );
  }
}

class PolylineDto {
  PolylineDto({
    required this.polylineId,
    required this.options,
  });

  String polylineId;

  PolylineOptionsDto options;

  Object encode() {
    return <Object?>[
      polylineId,
      options.encode(),
    ];
  }

  static PolylineDto decode(Object result) {
    result as List<Object?>;
    return PolylineDto(
      polylineId: result[0]! as String,
      options: PolylineOptionsDto.decode(result[1]! as List<Object?>),
    );
  }
}

class PatternItemDto {
  PatternItemDto({
    required this.type,
    this.length,
  });

  PatternTypeDto type;

  double? length;

  Object encode() {
    return <Object?>[
      type.index,
      length,
    ];
  }

  static PatternItemDto decode(Object result) {
    result as List<Object?>;
    return PatternItemDto(
      type: PatternTypeDto.values[result[0]! as int],
      length: result[1] as double?,
    );
  }
}

class PolylineOptionsDto {
  PolylineOptionsDto({
    this.points,
    this.clickable,
    this.geodesic,
    this.strokeColor,
    this.strokeJointType,
    this.strokePattern,
    this.strokeWidth,
    this.visible,
    this.zIndex,
    required this.spans,
  });

  List<LatLngDto?>? points;

  bool? clickable;

  bool? geodesic;

  int? strokeColor;

  StrokeJointTypeDto? strokeJointType;

  List<PatternItemDto?>? strokePattern;

  double? strokeWidth;

  bool? visible;

  double? zIndex;

  List<StyleSpanDto?> spans;

  Object encode() {
    return <Object?>[
      points,
      clickable,
      geodesic,
      strokeColor,
      strokeJointType?.index,
      strokePattern,
      strokeWidth,
      visible,
      zIndex,
      spans,
    ];
  }

  static PolylineOptionsDto decode(Object result) {
    result as List<Object?>;
    return PolylineOptionsDto(
      points: (result[0] as List<Object?>?)?.cast<LatLngDto?>(),
      clickable: result[1] as bool?,
      geodesic: result[2] as bool?,
      strokeColor: result[3] as int?,
      strokeJointType: result[4] != null
          ? StrokeJointTypeDto.values[result[4]! as int]
          : null,
      strokePattern: (result[5] as List<Object?>?)?.cast<PatternItemDto?>(),
      strokeWidth: result[6] as double?,
      visible: result[7] as bool?,
      zIndex: result[8] as double?,
      spans: (result[9] as List<Object?>?)!.cast<StyleSpanDto?>(),
    );
  }
}

class CircleDto {
  CircleDto({
    required this.circleId,
    required this.options,
  });

  /// Identifies circle.
  String circleId;

  /// Options for circle.
  CircleOptionsDto options;

  Object encode() {
    return <Object?>[
      circleId,
      options.encode(),
    ];
  }

  static CircleDto decode(Object result) {
    result as List<Object?>;
    return CircleDto(
      circleId: result[0]! as String,
      options: CircleOptionsDto.decode(result[1]! as List<Object?>),
    );
  }
}

class CircleOptionsDto {
  CircleOptionsDto({
    required this.position,
    required this.radius,
    required this.strokeWidth,
    required this.strokeColor,
    required this.strokePattern,
    required this.fillColor,
    required this.zIndex,
    required this.visible,
    required this.clickable,
  });

  LatLngDto position;

  double radius;

  double strokeWidth;

  int strokeColor;

  List<PatternItemDto?> strokePattern;

  int fillColor;

  double zIndex;

  bool visible;

  bool clickable;

  Object encode() {
    return <Object?>[
      position.encode(),
      radius,
      strokeWidth,
      strokeColor,
      strokePattern,
      fillColor,
      zIndex,
      visible,
      clickable,
    ];
  }

  static CircleOptionsDto decode(Object result) {
    result as List<Object?>;
    return CircleOptionsDto(
      position: LatLngDto.decode(result[0]! as List<Object?>),
      radius: result[1]! as double,
      strokeWidth: result[2]! as double,
      strokeColor: result[3]! as int,
      strokePattern: (result[4] as List<Object?>?)!.cast<PatternItemDto?>(),
      fillColor: result[5]! as int,
      zIndex: result[6]! as double,
      visible: result[7]! as bool,
      clickable: result[8]! as bool,
    );
  }
}

class RouteTokenOptionsDto {
  RouteTokenOptionsDto({
    required this.routeToken,
    this.travelMode,
  });

  String routeToken;

  TravelModeDto? travelMode;

  Object encode() {
    return <Object?>[
      routeToken,
      travelMode?.index,
    ];
  }

  static RouteTokenOptionsDto decode(Object result) {
    result as List<Object?>;
    return RouteTokenOptionsDto(
      routeToken: result[0]! as String,
      travelMode:
          result[1] != null ? TravelModeDto.values[result[1]! as int] : null,
    );
  }
}

class DestinationsDto {
  DestinationsDto({
    required this.waypoints,
    required this.displayOptions,
    this.routingOptions,
    this.routeTokenOptions,
  });

  List<NavigationWaypointDto?> waypoints;

  NavigationDisplayOptionsDto displayOptions;

  RoutingOptionsDto? routingOptions;

  RouteTokenOptionsDto? routeTokenOptions;

  Object encode() {
    return <Object?>[
      waypoints,
      displayOptions.encode(),
      routingOptions?.encode(),
      routeTokenOptions?.encode(),
    ];
  }

  static DestinationsDto decode(Object result) {
    result as List<Object?>;
    return DestinationsDto(
      waypoints: (result[0] as List<Object?>?)!.cast<NavigationWaypointDto?>(),
      displayOptions:
          NavigationDisplayOptionsDto.decode(result[1]! as List<Object?>),
      routingOptions: result[2] != null
          ? RoutingOptionsDto.decode(result[2]! as List<Object?>)
          : null,
      routeTokenOptions: result[3] != null
          ? RouteTokenOptionsDto.decode(result[3]! as List<Object?>)
          : null,
    );
  }
}

class RoutingOptionsDto {
  RoutingOptionsDto({
    this.alternateRoutesStrategy,
    this.routingStrategy,
    this.targetDistanceMeters,
    this.travelMode,
    this.avoidTolls,
    this.avoidFerries,
    this.avoidHighways,
    this.locationTimeoutMs,
  });

  AlternateRoutesStrategyDto? alternateRoutesStrategy;

  RoutingStrategyDto? routingStrategy;

  List<int?>? targetDistanceMeters;

  TravelModeDto? travelMode;

  bool? avoidTolls;

  bool? avoidFerries;

  bool? avoidHighways;

  int? locationTimeoutMs;

  Object encode() {
    return <Object?>[
      alternateRoutesStrategy?.index,
      routingStrategy?.index,
      targetDistanceMeters,
      travelMode?.index,
      avoidTolls,
      avoidFerries,
      avoidHighways,
      locationTimeoutMs,
    ];
  }

  static RoutingOptionsDto decode(Object result) {
    result as List<Object?>;
    return RoutingOptionsDto(
      alternateRoutesStrategy: result[0] != null
          ? AlternateRoutesStrategyDto.values[result[0]! as int]
          : null,
      routingStrategy: result[1] != null
          ? RoutingStrategyDto.values[result[1]! as int]
          : null,
      targetDistanceMeters: (result[2] as List<Object?>?)?.cast<int?>(),
      travelMode:
          result[3] != null ? TravelModeDto.values[result[3]! as int] : null,
      avoidTolls: result[4] as bool?,
      avoidFerries: result[5] as bool?,
      avoidHighways: result[6] as bool?,
      locationTimeoutMs: result[7] as int?,
    );
  }
}

class NavigationDisplayOptionsDto {
  NavigationDisplayOptionsDto({
    this.showDestinationMarkers,
    this.showStopSigns,
    this.showTrafficLights,
  });

  bool? showDestinationMarkers;

  bool? showStopSigns;

  bool? showTrafficLights;

  Object encode() {
    return <Object?>[
      showDestinationMarkers,
      showStopSigns,
      showTrafficLights,
    ];
  }

  static NavigationDisplayOptionsDto decode(Object result) {
    result as List<Object?>;
    return NavigationDisplayOptionsDto(
      showDestinationMarkers: result[0] as bool?,
      showStopSigns: result[1] as bool?,
      showTrafficLights: result[2] as bool?,
    );
  }
}

class NavigationWaypointDto {
  NavigationWaypointDto({
    required this.title,
    this.target,
    this.placeID,
    this.preferSameSideOfRoad,
    this.preferredSegmentHeading,
  });

  String title;

  LatLngDto? target;

  String? placeID;

  bool? preferSameSideOfRoad;

  int? preferredSegmentHeading;

  Object encode() {
    return <Object?>[
      title,
      target?.encode(),
      placeID,
      preferSameSideOfRoad,
      preferredSegmentHeading,
    ];
  }

  static NavigationWaypointDto decode(Object result) {
    result as List<Object?>;
    return NavigationWaypointDto(
      title: result[0]! as String,
      target: result[1] != null
          ? LatLngDto.decode(result[1]! as List<Object?>)
          : null,
      placeID: result[2] as String?,
      preferSameSideOfRoad: result[3] as bool?,
      preferredSegmentHeading: result[4] as int?,
    );
  }
}

class NavigationTimeAndDistanceDto {
  NavigationTimeAndDistanceDto({
    required this.time,
    required this.distance,
  });

  double time;

  double distance;

  Object encode() {
    return <Object?>[
      time,
      distance,
    ];
  }

  static NavigationTimeAndDistanceDto decode(Object result) {
    result as List<Object?>;
    return NavigationTimeAndDistanceDto(
      time: result[0]! as double,
      distance: result[1]! as double,
    );
  }
}

class NavigationAudioGuidanceSettingsDto {
  NavigationAudioGuidanceSettingsDto({
    this.isBluetoothAudioEnabled,
    this.isVibrationEnabled,
    this.guidanceType,
  });

  bool? isBluetoothAudioEnabled;

  bool? isVibrationEnabled;

  AudioGuidanceTypeDto? guidanceType;

  Object encode() {
    return <Object?>[
      isBluetoothAudioEnabled,
      isVibrationEnabled,
      guidanceType?.index,
    ];
  }

  static NavigationAudioGuidanceSettingsDto decode(Object result) {
    result as List<Object?>;
    return NavigationAudioGuidanceSettingsDto(
      isBluetoothAudioEnabled: result[0] as bool?,
      isVibrationEnabled: result[1] as bool?,
      guidanceType: result[2] != null
          ? AudioGuidanceTypeDto.values[result[2]! as int]
          : null,
    );
  }
}

class SimulationOptionsDto {
  SimulationOptionsDto({
    required this.speedMultiplier,
  });

  double speedMultiplier;

  Object encode() {
    return <Object?>[
      speedMultiplier,
    ];
  }

  static SimulationOptionsDto decode(Object result) {
    result as List<Object?>;
    return SimulationOptionsDto(
      speedMultiplier: result[0]! as double,
    );
  }
}

class LatLngDto {
  LatLngDto({
    required this.latitude,
    required this.longitude,
  });

  double latitude;

  double longitude;

  Object encode() {
    return <Object?>[
      latitude,
      longitude,
    ];
  }

  static LatLngDto decode(Object result) {
    result as List<Object?>;
    return LatLngDto(
      latitude: result[0]! as double,
      longitude: result[1]! as double,
    );
  }
}

class LatLngBoundsDto {
  LatLngBoundsDto({
    required this.southwest,
    required this.northeast,
  });

  LatLngDto southwest;

  LatLngDto northeast;

  Object encode() {
    return <Object?>[
      southwest.encode(),
      northeast.encode(),
    ];
  }

  static LatLngBoundsDto decode(Object result) {
    result as List<Object?>;
    return LatLngBoundsDto(
      southwest: LatLngDto.decode(result[0]! as List<Object?>),
      northeast: LatLngDto.decode(result[1]! as List<Object?>),
    );
  }
}

class SpeedingUpdatedEventDto {
  SpeedingUpdatedEventDto({
    required this.percentageAboveLimit,
    required this.severity,
  });

  double percentageAboveLimit;

  SpeedAlertSeverityDto severity;

  Object encode() {
    return <Object?>[
      percentageAboveLimit,
      severity.index,
    ];
  }

  static SpeedingUpdatedEventDto decode(Object result) {
    result as List<Object?>;
    return SpeedingUpdatedEventDto(
      percentageAboveLimit: result[0]! as double,
      severity: SpeedAlertSeverityDto.values[result[1]! as int],
    );
  }
}

class SpeedAlertOptionsDto {
  SpeedAlertOptionsDto({
    required this.severityUpgradeDurationSeconds,
    required this.minorSpeedAlertThresholdPercentage,
    required this.majorSpeedAlertThresholdPercentage,
  });

  double severityUpgradeDurationSeconds;

  double minorSpeedAlertThresholdPercentage;

  double majorSpeedAlertThresholdPercentage;

  Object encode() {
    return <Object?>[
      severityUpgradeDurationSeconds,
      minorSpeedAlertThresholdPercentage,
      majorSpeedAlertThresholdPercentage,
    ];
  }

  static SpeedAlertOptionsDto decode(Object result) {
    result as List<Object?>;
    return SpeedAlertOptionsDto(
      severityUpgradeDurationSeconds: result[0]! as double,
      minorSpeedAlertThresholdPercentage: result[1]! as double,
      majorSpeedAlertThresholdPercentage: result[2]! as double,
    );
  }
}

class RouteSegmentTrafficDataRoadStretchRenderingDataDto {
  RouteSegmentTrafficDataRoadStretchRenderingDataDto({
    required this.style,
    required this.lengthMeters,
    required this.offsetMeters,
  });

  RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto style;

  int lengthMeters;

  int offsetMeters;

  Object encode() {
    return <Object?>[
      style.index,
      lengthMeters,
      offsetMeters,
    ];
  }

  static RouteSegmentTrafficDataRoadStretchRenderingDataDto decode(
      Object result) {
    result as List<Object?>;
    return RouteSegmentTrafficDataRoadStretchRenderingDataDto(
      style: RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto
          .values[result[0]! as int],
      lengthMeters: result[1]! as int,
      offsetMeters: result[2]! as int,
    );
  }
}

class RouteSegmentTrafficDataDto {
  RouteSegmentTrafficDataDto({
    required this.status,
    required this.roadStretchRenderingDataList,
  });

  RouteSegmentTrafficDataStatusDto status;

  List<RouteSegmentTrafficDataRoadStretchRenderingDataDto?>
      roadStretchRenderingDataList;

  Object encode() {
    return <Object?>[
      status.index,
      roadStretchRenderingDataList,
    ];
  }

  static RouteSegmentTrafficDataDto decode(Object result) {
    result as List<Object?>;
    return RouteSegmentTrafficDataDto(
      status: RouteSegmentTrafficDataStatusDto.values[result[0]! as int],
      roadStretchRenderingDataList: (result[1] as List<Object?>?)!
          .cast<RouteSegmentTrafficDataRoadStretchRenderingDataDto?>(),
    );
  }
}

class RouteSegmentDto {
  RouteSegmentDto({
    this.trafficData,
    required this.destinationLatLng,
    this.latLngs,
    this.destinationWaypoint,
  });

  RouteSegmentTrafficDataDto? trafficData;

  LatLngDto destinationLatLng;

  List<LatLngDto?>? latLngs;

  NavigationWaypointDto? destinationWaypoint;

  Object encode() {
    return <Object?>[
      trafficData?.encode(),
      destinationLatLng.encode(),
      latLngs,
      destinationWaypoint?.encode(),
    ];
  }

  static RouteSegmentDto decode(Object result) {
    result as List<Object?>;
    return RouteSegmentDto(
      trafficData: result[0] != null
          ? RouteSegmentTrafficDataDto.decode(result[0]! as List<Object?>)
          : null,
      destinationLatLng: LatLngDto.decode(result[1]! as List<Object?>),
      latLngs: (result[2] as List<Object?>?)?.cast<LatLngDto?>(),
      destinationWaypoint: result[3] != null
          ? NavigationWaypointDto.decode(result[3]! as List<Object?>)
          : null,
    );
  }
}

/// One of the possible directions from a lane at the end of a route step, and whether it is on the recommended route.
class LaneDirectionDto {
  LaneDirectionDto({
    required this.laneShape,
    required this.isRecommended,
  });

  /// Shape for this lane direction.
  LaneShapeDto laneShape;

  /// Whether this lane is recommended.
  bool isRecommended;

  Object encode() {
    return <Object?>[
      laneShape.index,
      isRecommended,
    ];
  }

  static LaneDirectionDto decode(Object result) {
    result as List<Object?>;
    return LaneDirectionDto(
      laneShape: LaneShapeDto.values[result[0]! as int],
      isRecommended: result[1]! as bool,
    );
  }
}

/// Single lane on the road at the end of a route step.
class LaneDto {
  LaneDto({
    required this.laneDirections,
  });

  /// List of possible directions a driver can follow when using this lane at the end of the respective route step
  List<LaneDirectionDto?> laneDirections;

  Object encode() {
    return <Object?>[
      laneDirections,
    ];
  }

  static LaneDto decode(Object result) {
    result as List<Object?>;
    return LaneDto(
      laneDirections: (result[0] as List<Object?>?)!.cast<LaneDirectionDto?>(),
    );
  }
}

/// Information about a single step along a navigation route.
class StepInfoDto {
  StepInfoDto({
    required this.distanceFromPrevStepMeters,
    required this.timeFromPrevStepSeconds,
    required this.drivingSide,
    this.exitNumber,
    required this.fullInstructions,
    required this.fullRoadName,
    required this.simpleRoadName,
    required this.roundaboutTurnNumber,
    required this.lanes,
    required this.maneuver,
    required this.stepNumber,
  });

  /// Distance in meters from the previous step to this step.
  int distanceFromPrevStepMeters;

  /// Time in seconds from the previous step to this step.
  int timeFromPrevStepSeconds;

  /// Whether this step is on a drive-on-right or drive-on-left route.
  DrivingSideDto drivingSide;

  /// The exit number if it exists.
  String? exitNumber;

  /// The full text of the instruction for this step.
  String fullInstructions;

  /// The full road name for this step.
  String fullRoadName;

  /// The simplified version of the road name.
  String simpleRoadName;

  /// The counted number of the exit to take relative to the location where the
  /// roundabout was entered.
  int roundaboutTurnNumber;

  /// The list of available lanes at the end of this route step.
  List<LaneDto?> lanes;

  /// The maneuver for this step.
  ManeuverDto maneuver;

  /// The index of the step in the list of all steps in the route.
  int stepNumber;

  Object encode() {
    return <Object?>[
      distanceFromPrevStepMeters,
      timeFromPrevStepSeconds,
      drivingSide.index,
      exitNumber,
      fullInstructions,
      fullRoadName,
      simpleRoadName,
      roundaboutTurnNumber,
      lanes,
      maneuver.index,
      stepNumber,
    ];
  }

  static StepInfoDto decode(Object result) {
    result as List<Object?>;
    return StepInfoDto(
      distanceFromPrevStepMeters: result[0]! as int,
      timeFromPrevStepSeconds: result[1]! as int,
      drivingSide: DrivingSideDto.values[result[2]! as int],
      exitNumber: result[3] as String?,
      fullInstructions: result[4]! as String,
      fullRoadName: result[5]! as String,
      simpleRoadName: result[6]! as String,
      roundaboutTurnNumber: result[7]! as int,
      lanes: (result[8] as List<Object?>?)!.cast<LaneDto?>(),
      maneuver: ManeuverDto.values[result[9]! as int],
      stepNumber: result[10]! as int,
    );
  }
}

/// Contains information about the state of navigation, the current nav step if
/// available, and remaining steps if available.
class NavInfoDto {
  NavInfoDto({
    required this.navState,
    this.currentStep,
    required this.remainingSteps,
    required this.routeChanged,
    this.distanceToCurrentStepMeters,
    this.distanceToFinalDestinationMeters,
    this.distanceToNextDestinationMeters,
    this.timeToCurrentStepSeconds,
    this.timeToFinalDestinationSeconds,
    this.timeToNextDestinationSeconds,
  });

  /// The current state of navigation.
  NavStateDto navState;

  /// Information about the upcoming maneuver step.
  StepInfoDto? currentStep;

  /// The remaining steps after the current step.
  List<StepInfoDto?> remainingSteps;

  /// Whether the route has changed since the last sent message.
  bool routeChanged;

  /// Estimated remaining distance in meters along the route to the
  /// current step.
  int? distanceToCurrentStepMeters;

  /// The estimated remaining distance in meters to the final destination which
  /// is the last destination in a multi-destination trip.
  int? distanceToFinalDestinationMeters;

  /// The estimated remaining distance in meters to the next destination.
  ///
  /// Android only.
  int? distanceToNextDestinationMeters;

  /// The estimated remaining time in seconds along the route to the
  /// current step.
  int? timeToCurrentStepSeconds;

  /// The estimated remaining time in seconds to the final destination which is
  /// the last destination in a multi-destination trip.
  int? timeToFinalDestinationSeconds;

  /// The estimated remaining time in seconds to the next destination.
  ///
  /// Android only.
  int? timeToNextDestinationSeconds;

  Object encode() {
    return <Object?>[
      navState.index,
      currentStep?.encode(),
      remainingSteps,
      routeChanged,
      distanceToCurrentStepMeters,
      distanceToFinalDestinationMeters,
      distanceToNextDestinationMeters,
      timeToCurrentStepSeconds,
      timeToFinalDestinationSeconds,
      timeToNextDestinationSeconds,
    ];
  }

  static NavInfoDto decode(Object result) {
    result as List<Object?>;
    return NavInfoDto(
      navState: NavStateDto.values[result[0]! as int],
      currentStep: result[1] != null
          ? StepInfoDto.decode(result[1]! as List<Object?>)
          : null,
      remainingSteps: (result[2] as List<Object?>?)!.cast<StepInfoDto?>(),
      routeChanged: result[3]! as bool,
      distanceToCurrentStepMeters: result[4] as int?,
      distanceToFinalDestinationMeters: result[5] as int?,
      distanceToNextDestinationMeters: result[6] as int?,
      timeToCurrentStepSeconds: result[7] as int?,
      timeToFinalDestinationSeconds: result[8] as int?,
      timeToNextDestinationSeconds: result[9] as int?,
    );
  }
}

class __NavigationViewCreationApiCodec extends StandardMessageCodec {
  const __NavigationViewCreationApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is CameraPositionDto) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is LatLngBoundsDto) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is LatLngDto) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is MapOptionsDto) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is NavigationViewCreationOptionsDto) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is NavigationViewOptionsDto) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return CameraPositionDto.decode(readValue(buffer)!);
      case 129:
        return LatLngBoundsDto.decode(readValue(buffer)!);
      case 130:
        return LatLngDto.decode(readValue(buffer)!);
      case 131:
        return MapOptionsDto.decode(readValue(buffer)!);
      case 132:
        return NavigationViewCreationOptionsDto.decode(readValue(buffer)!);
      case 133:
        return NavigationViewOptionsDto.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// Pigeon only generates messages if the messages are used in API.
/// [MapOptionsDto] is encoded and decoded directly to generate
/// a PlatformView creation message. This API should never be used directly.
class _NavigationViewCreationApi {
  /// Constructor for [_NavigationViewCreationApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _NavigationViewCreationApi({BinaryMessenger? binaryMessenger})
      : __pigeon_binaryMessenger = binaryMessenger;
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      __NavigationViewCreationApiCodec();

  Future<void> _create(NavigationViewCreationOptionsDto msg) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation._NavigationViewCreationApi._create';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[msg]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }
}

class _NavigationViewApiCodec extends StandardMessageCodec {
  const _NavigationViewApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is CameraPositionDto) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is CircleDto) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is CircleOptionsDto) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is ImageDescriptorDto) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is InfoWindowDto) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is LatLngBoundsDto) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is LatLngDto) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is LatLngDto) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else if (value is MarkerAnchorDto) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    } else if (value is MarkerDto) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    } else if (value is MarkerOptionsDto) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else if (value is PatternItemDto) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else if (value is PolygonDto) {
      buffer.putUint8(140);
      writeValue(buffer, value.encode());
    } else if (value is PolygonHoleDto) {
      buffer.putUint8(141);
      writeValue(buffer, value.encode());
    } else if (value is PolygonOptionsDto) {
      buffer.putUint8(142);
      writeValue(buffer, value.encode());
    } else if (value is PolylineDto) {
      buffer.putUint8(143);
      writeValue(buffer, value.encode());
    } else if (value is PolylineOptionsDto) {
      buffer.putUint8(144);
      writeValue(buffer, value.encode());
    } else if (value is StyleSpanDto) {
      buffer.putUint8(145);
      writeValue(buffer, value.encode());
    } else if (value is StyleSpanStrokeStyleDto) {
      buffer.putUint8(146);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return CameraPositionDto.decode(readValue(buffer)!);
      case 129:
        return CircleDto.decode(readValue(buffer)!);
      case 130:
        return CircleOptionsDto.decode(readValue(buffer)!);
      case 131:
        return ImageDescriptorDto.decode(readValue(buffer)!);
      case 132:
        return InfoWindowDto.decode(readValue(buffer)!);
      case 133:
        return LatLngBoundsDto.decode(readValue(buffer)!);
      case 134:
        return LatLngDto.decode(readValue(buffer)!);
      case 135:
        return LatLngDto.decode(readValue(buffer)!);
      case 136:
        return MarkerAnchorDto.decode(readValue(buffer)!);
      case 137:
        return MarkerDto.decode(readValue(buffer)!);
      case 138:
        return MarkerOptionsDto.decode(readValue(buffer)!);
      case 139:
        return PatternItemDto.decode(readValue(buffer)!);
      case 140:
        return PolygonDto.decode(readValue(buffer)!);
      case 141:
        return PolygonHoleDto.decode(readValue(buffer)!);
      case 142:
        return PolygonOptionsDto.decode(readValue(buffer)!);
      case 143:
        return PolylineDto.decode(readValue(buffer)!);
      case 144:
        return PolylineOptionsDto.decode(readValue(buffer)!);
      case 145:
        return StyleSpanDto.decode(readValue(buffer)!);
      case 146:
        return StyleSpanStrokeStyleDto.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class NavigationViewApi {
  /// Constructor for [NavigationViewApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  NavigationViewApi({BinaryMessenger? binaryMessenger})
      : __pigeon_binaryMessenger = binaryMessenger;
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      _NavigationViewApiCodec();

  Future<void> awaitMapReady(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.awaitMapReady';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isMyLocationEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isMyLocationEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> setMyLocationEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMyLocationEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<LatLngDto?> getMyLocation(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMyLocation';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return (__pigeon_replyList[0] as LatLngDto?);
    }
  }

  Future<MapTypeDto> getMapType(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMapType';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return MapTypeDto.values[__pigeon_replyList[0]! as int];
    }
  }

  Future<void> setMapType(int viewId, MapTypeDto mapType) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMapType';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, mapType.index]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setMapStyle(int viewId, String styleJson) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMapStyle';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, styleJson]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isNavigationTripProgressBarEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationTripProgressBarEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> setNavigationTripProgressBarEnabled(
      int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationTripProgressBarEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isNavigationHeaderEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationHeaderEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> setNavigationHeaderEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationHeaderEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isNavigationFooterEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationFooterEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> setNavigationFooterEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationFooterEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isRecenterButtonEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isRecenterButtonEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> setRecenterButtonEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setRecenterButtonEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isSpeedLimitIconEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isSpeedLimitIconEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> setSpeedLimitIconEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setSpeedLimitIconEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isSpeedometerEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isSpeedometerEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> setSpeedometerEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setSpeedometerEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isTrafficIncidentCardsEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isTrafficIncidentCardsEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> setTrafficIncidentCardsEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setTrafficIncidentCardsEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isNavigationUIEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationUIEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> setNavigationUIEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationUIEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<CameraPositionDto> getCameraPosition(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getCameraPosition';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as CameraPositionDto?)!;
    }
  }

  Future<LatLngBoundsDto> getVisibleRegion(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getVisibleRegion';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as LatLngBoundsDto?)!;
    }
  }

  Future<void> followMyLocation(
      int viewId, CameraPerspectiveDto perspective, double? zoomLevel) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.followMyLocation';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
            .send(<Object?>[viewId, perspective.index, zoomLevel])
        as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> animateCameraToCameraPosition(
      int viewId, CameraPositionDto cameraPosition, int? duration) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToCameraPosition';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, cameraPosition, duration]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> animateCameraToLatLng(
      int viewId, LatLngDto point, int? duration) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToLatLng';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, point, duration]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> animateCameraToLatLngBounds(
      int viewId, LatLngBoundsDto bounds, double padding, int? duration) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToLatLngBounds';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, bounds, padding, duration]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> animateCameraToLatLngZoom(
      int viewId, LatLngDto point, double zoom, int? duration) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToLatLngZoom';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, point, zoom, duration]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> animateCameraByScroll(
      int viewId, double scrollByDx, double scrollByDy, int? duration) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraByScroll';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
            .send(<Object?>[viewId, scrollByDx, scrollByDy, duration])
        as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> animateCameraByZoom(int viewId, double zoomBy, double? focusDx,
      double? focusDy, int? duration) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraByZoom';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
            .send(<Object?>[viewId, zoomBy, focusDx, focusDy, duration])
        as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> animateCameraToZoom(
      int viewId, double zoom, int? duration) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToZoom';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, zoom, duration]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> moveCameraToCameraPosition(
      int viewId, CameraPositionDto cameraPosition) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToCameraPosition';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, cameraPosition]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> moveCameraToLatLng(int viewId, LatLngDto point) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToLatLng';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId, point]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> moveCameraToLatLngBounds(
      int viewId, LatLngBoundsDto bounds, double padding) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToLatLngBounds';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, bounds, padding]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> moveCameraToLatLngZoom(
      int viewId, LatLngDto point, double zoom) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToLatLngZoom';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, point, zoom]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> moveCameraByScroll(
      int viewId, double scrollByDx, double scrollByDy) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraByScroll';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, scrollByDx, scrollByDy]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> moveCameraByZoom(
      int viewId, double zoomBy, double? focusDx, double? focusDy) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraByZoom';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, zoomBy, focusDx, focusDy]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> moveCameraToZoom(int viewId, double zoom) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToZoom';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId, zoom]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> showRouteOverview(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.showRouteOverview';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<double> getMinZoomPreference(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMinZoomPreference';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as double?)!;
    }
  }

  Future<double> getMaxZoomPreference(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMaxZoomPreference';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as double?)!;
    }
  }

  Future<void> resetMinMaxZoomPreference(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.resetMinMaxZoomPreference';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setMinZoomPreference(
      int viewId, double minZoomPreference) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMinZoomPreference';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, minZoomPreference]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setMaxZoomPreference(
      int viewId, double maxZoomPreference) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMaxZoomPreference';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, maxZoomPreference]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setMyLocationButtonEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMyLocationButtonEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setConsumeMyLocationButtonClickEventsEnabled(
      int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setConsumeMyLocationButtonClickEventsEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setZoomGesturesEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setZoomGesturesEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setZoomControlsEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setZoomControlsEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setCompassEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setCompassEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setRotateGesturesEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setRotateGesturesEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setScrollGesturesEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setScrollGesturesEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setScrollGesturesDuringRotateOrZoomEnabled(
      int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setScrollGesturesDuringRotateOrZoomEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setTiltGesturesEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setTiltGesturesEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setMapToolbarEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMapToolbarEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setTrafficEnabled(int viewId, bool enabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setTrafficEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, enabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isMyLocationButtonEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isMyLocationButtonEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> isConsumeMyLocationButtonClickEventsEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isConsumeMyLocationButtonClickEventsEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> isZoomGesturesEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isZoomGesturesEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> isZoomControlsEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isZoomControlsEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> isCompassEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isCompassEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> isRotateGesturesEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isRotateGesturesEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> isScrollGesturesEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isScrollGesturesEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> isScrollGesturesEnabledDuringRotateOrZoom(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isScrollGesturesEnabledDuringRotateOrZoom';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> isTiltGesturesEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isTiltGesturesEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> isMapToolbarEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isMapToolbarEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> isTrafficEnabled(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isTrafficEnabled';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<List<MarkerDto?>> getMarkers(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMarkers';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<MarkerDto?>();
    }
  }

  Future<List<MarkerDto?>> addMarkers(
      int viewId, List<MarkerDto?> markers) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addMarkers';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, markers]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<MarkerDto?>();
    }
  }

  Future<List<MarkerDto?>> updateMarkers(
      int viewId, List<MarkerDto?> markers) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updateMarkers';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, markers]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<MarkerDto?>();
    }
  }

  Future<void> removeMarkers(int viewId, List<MarkerDto?> markers) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removeMarkers';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, markers]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> clearMarkers(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearMarkers';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> clear(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clear';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<List<PolygonDto?>> getPolygons(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getPolygons';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<PolygonDto?>();
    }
  }

  Future<List<PolygonDto?>> addPolygons(
      int viewId, List<PolygonDto?> polygons) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addPolygons';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, polygons]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<PolygonDto?>();
    }
  }

  Future<List<PolygonDto?>> updatePolygons(
      int viewId, List<PolygonDto?> polygons) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updatePolygons';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, polygons]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<PolygonDto?>();
    }
  }

  Future<void> removePolygons(int viewId, List<PolygonDto?> polygons) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removePolygons';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, polygons]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> clearPolygons(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearPolygons';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<List<PolylineDto?>> getPolylines(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getPolylines';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<PolylineDto?>();
    }
  }

  Future<List<PolylineDto?>> addPolylines(
      int viewId, List<PolylineDto?> polylines) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addPolylines';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, polylines]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<PolylineDto?>();
    }
  }

  Future<List<PolylineDto?>> updatePolylines(
      int viewId, List<PolylineDto?> polylines) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updatePolylines';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, polylines]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<PolylineDto?>();
    }
  }

  Future<void> removePolylines(int viewId, List<PolylineDto?> polylines) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removePolylines';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, polylines]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> clearPolylines(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearPolylines';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<List<CircleDto?>> getCircles(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getCircles';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<CircleDto?>();
    }
  }

  Future<List<CircleDto?>> addCircles(
      int viewId, List<CircleDto?> circles) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addCircles';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, circles]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<CircleDto?>();
    }
  }

  Future<List<CircleDto?>> updateCircles(
      int viewId, List<CircleDto?> circles) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updateCircles';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, circles]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<CircleDto?>();
    }
  }

  Future<void> removeCircles(int viewId, List<CircleDto?> circles) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removeCircles';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[viewId, circles]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> clearCircles(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearCircles';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> registerOnCameraChangedListener(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.registerOnCameraChangedListener';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }
}

class _ImageRegistryApiCodec extends StandardMessageCodec {
  const _ImageRegistryApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ImageDescriptorDto) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is ImageDescriptorDto) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return ImageDescriptorDto.decode(readValue(buffer)!);
      case 129:
        return ImageDescriptorDto.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class ImageRegistryApi {
  /// Constructor for [ImageRegistryApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ImageRegistryApi({BinaryMessenger? binaryMessenger})
      : __pigeon_binaryMessenger = binaryMessenger;
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      _ImageRegistryApiCodec();

  Future<ImageDescriptorDto> registerBitmapImage(
      String imageId,
      Uint8List bytes,
      double imagePixelRatio,
      double? width,
      double? height) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.registerBitmapImage';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
            .send(<Object?>[imageId, bytes, imagePixelRatio, width, height])
        as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as ImageDescriptorDto?)!;
    }
  }

  Future<void> unregisterImage(ImageDescriptorDto imageDescriptor) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.unregisterImage';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[imageDescriptor]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<List<ImageDescriptorDto?>> getRegisteredImages() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.getRegisteredImages';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!
          .cast<ImageDescriptorDto?>();
    }
  }

  Future<void> clearRegisteredImages() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.clearRegisteredImages';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }
}

class _NavigationViewEventApiCodec extends StandardMessageCodec {
  const _NavigationViewEventApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is CameraPositionDto) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is LatLngDto) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return CameraPositionDto.decode(readValue(buffer)!);
      case 129:
        return LatLngDto.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class NavigationViewEventApi {
  static const MessageCodec<Object?> pigeonChannelCodec =
      _NavigationViewEventApiCodec();

  void onMapClickEvent(int viewId, LatLngDto latLng);

  void onMapLongClickEvent(int viewId, LatLngDto latLng);

  void onRecenterButtonClicked(int viewId);

  void onMarkerEvent(int viewId, String markerId, MarkerEventTypeDto eventType);

  void onMarkerDragEvent(int viewId, String markerId,
      MarkerDragEventTypeDto eventType, LatLngDto position);

  void onPolygonClicked(int viewId, String polygonId);

  void onPolylineClicked(int viewId, String polylineId);

  void onCircleClicked(int viewId, String circleId);

  void onNavigationUIEnabledChanged(int viewId, bool navigationUIEnabled);

  void onMyLocationClicked(int viewId);

  void onMyLocationButtonClicked(int viewId);

  void onCameraChanged(
      int viewId, CameraEventTypeDto eventType, CameraPositionDto position);

  static void setup(NavigationViewEventApi? api,
      {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapClickEvent',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapClickEvent was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapClickEvent was null, expected non-null int.');
          final LatLngDto? arg_latLng = (args[1] as LatLngDto?);
          assert(arg_latLng != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapClickEvent was null, expected non-null LatLngDto.');
          try {
            api.onMapClickEvent(arg_viewId!, arg_latLng!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapLongClickEvent',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapLongClickEvent was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapLongClickEvent was null, expected non-null int.');
          final LatLngDto? arg_latLng = (args[1] as LatLngDto?);
          assert(arg_latLng != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapLongClickEvent was null, expected non-null LatLngDto.');
          try {
            api.onMapLongClickEvent(arg_viewId!, arg_latLng!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onRecenterButtonClicked',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onRecenterButtonClicked was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onRecenterButtonClicked was null, expected non-null int.');
          try {
            api.onRecenterButtonClicked(arg_viewId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerEvent',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerEvent was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerEvent was null, expected non-null int.');
          final String? arg_markerId = (args[1] as String?);
          assert(arg_markerId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerEvent was null, expected non-null String.');
          final MarkerEventTypeDto? arg_eventType = args[2] == null
              ? null
              : MarkerEventTypeDto.values[args[2]! as int];
          assert(arg_eventType != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerEvent was null, expected non-null MarkerEventTypeDto.');
          try {
            api.onMarkerEvent(arg_viewId!, arg_markerId!, arg_eventType!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerDragEvent',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerDragEvent was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerDragEvent was null, expected non-null int.');
          final String? arg_markerId = (args[1] as String?);
          assert(arg_markerId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerDragEvent was null, expected non-null String.');
          final MarkerDragEventTypeDto? arg_eventType = args[2] == null
              ? null
              : MarkerDragEventTypeDto.values[args[2]! as int];
          assert(arg_eventType != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerDragEvent was null, expected non-null MarkerDragEventTypeDto.');
          final LatLngDto? arg_position = (args[3] as LatLngDto?);
          assert(arg_position != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerDragEvent was null, expected non-null LatLngDto.');
          try {
            api.onMarkerDragEvent(
                arg_viewId!, arg_markerId!, arg_eventType!, arg_position!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolygonClicked',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolygonClicked was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolygonClicked was null, expected non-null int.');
          final String? arg_polygonId = (args[1] as String?);
          assert(arg_polygonId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolygonClicked was null, expected non-null String.');
          try {
            api.onPolygonClicked(arg_viewId!, arg_polygonId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolylineClicked',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolylineClicked was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolylineClicked was null, expected non-null int.');
          final String? arg_polylineId = (args[1] as String?);
          assert(arg_polylineId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolylineClicked was null, expected non-null String.');
          try {
            api.onPolylineClicked(arg_viewId!, arg_polylineId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCircleClicked',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCircleClicked was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCircleClicked was null, expected non-null int.');
          final String? arg_circleId = (args[1] as String?);
          assert(arg_circleId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCircleClicked was null, expected non-null String.');
          try {
            api.onCircleClicked(arg_viewId!, arg_circleId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onNavigationUIEnabledChanged',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onNavigationUIEnabledChanged was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onNavigationUIEnabledChanged was null, expected non-null int.');
          final bool? arg_navigationUIEnabled = (args[1] as bool?);
          assert(arg_navigationUIEnabled != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onNavigationUIEnabledChanged was null, expected non-null bool.');
          try {
            api.onNavigationUIEnabledChanged(
                arg_viewId!, arg_navigationUIEnabled!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMyLocationClicked',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMyLocationClicked was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMyLocationClicked was null, expected non-null int.');
          try {
            api.onMyLocationClicked(arg_viewId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMyLocationButtonClicked',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMyLocationButtonClicked was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMyLocationButtonClicked was null, expected non-null int.');
          try {
            api.onMyLocationButtonClicked(arg_viewId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCameraChanged',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCameraChanged was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_viewId = (args[0] as int?);
          assert(arg_viewId != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCameraChanged was null, expected non-null int.');
          final CameraEventTypeDto? arg_eventType = args[1] == null
              ? null
              : CameraEventTypeDto.values[args[1]! as int];
          assert(arg_eventType != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCameraChanged was null, expected non-null CameraEventTypeDto.');
          final CameraPositionDto? arg_position =
              (args[2] as CameraPositionDto?);
          assert(arg_position != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCameraChanged was null, expected non-null CameraPositionDto.');
          try {
            api.onCameraChanged(arg_viewId!, arg_eventType!, arg_position!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}

class _NavigationSessionApiCodec extends StandardMessageCodec {
  const _NavigationSessionApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is DestinationsDto) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is LatLngDto) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is LatLngDto) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is NavigationAudioGuidanceSettingsDto) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is NavigationDisplayOptionsDto) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is NavigationTimeAndDistanceDto) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is NavigationWaypointDto) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is NavigationWaypointDto) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else if (value is RouteSegmentDto) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    } else if (value is RouteSegmentDto) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    } else if (value is RouteSegmentTrafficDataDto) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else if (value is RouteSegmentTrafficDataRoadStretchRenderingDataDto) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else if (value is RouteTokenOptionsDto) {
      buffer.putUint8(140);
      writeValue(buffer, value.encode());
    } else if (value is RoutingOptionsDto) {
      buffer.putUint8(141);
      writeValue(buffer, value.encode());
    } else if (value is SimulationOptionsDto) {
      buffer.putUint8(142);
      writeValue(buffer, value.encode());
    } else if (value is SpeedAlertOptionsDto) {
      buffer.putUint8(143);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return DestinationsDto.decode(readValue(buffer)!);
      case 129:
        return LatLngDto.decode(readValue(buffer)!);
      case 130:
        return LatLngDto.decode(readValue(buffer)!);
      case 131:
        return NavigationAudioGuidanceSettingsDto.decode(readValue(buffer)!);
      case 132:
        return NavigationDisplayOptionsDto.decode(readValue(buffer)!);
      case 133:
        return NavigationTimeAndDistanceDto.decode(readValue(buffer)!);
      case 134:
        return NavigationWaypointDto.decode(readValue(buffer)!);
      case 135:
        return NavigationWaypointDto.decode(readValue(buffer)!);
      case 136:
        return RouteSegmentDto.decode(readValue(buffer)!);
      case 137:
        return RouteSegmentDto.decode(readValue(buffer)!);
      case 138:
        return RouteSegmentTrafficDataDto.decode(readValue(buffer)!);
      case 139:
        return RouteSegmentTrafficDataRoadStretchRenderingDataDto.decode(
            readValue(buffer)!);
      case 140:
        return RouteTokenOptionsDto.decode(readValue(buffer)!);
      case 141:
        return RoutingOptionsDto.decode(readValue(buffer)!);
      case 142:
        return SimulationOptionsDto.decode(readValue(buffer)!);
      case 143:
        return SpeedAlertOptionsDto.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class NavigationSessionApi {
  /// Constructor for [NavigationSessionApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  NavigationSessionApi({BinaryMessenger? binaryMessenger})
      : __pigeon_binaryMessenger = binaryMessenger;
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      _NavigationSessionApiCodec();

  /// General.
  Future<void> createNavigationSession(
      bool abnormalTerminationReportingEnabled) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.createNavigationSession';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[abnormalTerminationReportingEnabled]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isInitialized() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.isInitialized';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> cleanup() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.cleanup';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> showTermsAndConditionsDialog(String title, String companyName,
      bool shouldOnlyShowDriverAwarenessDisclaimer) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.showTermsAndConditionsDialog';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[
      title,
      companyName,
      shouldOnlyShowDriverAwarenessDisclaimer
    ]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> areTermsAccepted() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.areTermsAccepted';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> resetTermsAccepted() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.resetTermsAccepted';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String> getNavSDKVersion() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getNavSDKVersion';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as String?)!;
    }
  }

  /// Navigation.
  Future<bool> isGuidanceRunning() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.isGuidanceRunning';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<void> startGuidance() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.startGuidance';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> stopGuidance() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.stopGuidance';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<RouteStatusDto> setDestinations(DestinationsDto destinations) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setDestinations';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[destinations]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return RouteStatusDto.values[__pigeon_replyList[0]! as int];
    }
  }

  Future<void> clearDestinations() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.clearDestinations';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<NavigationWaypointDto?> continueToNextDestination() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.continueToNextDestination';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return (__pigeon_replyList[0] as NavigationWaypointDto?);
    }
  }

  Future<NavigationTimeAndDistanceDto> getCurrentTimeAndDistance() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getCurrentTimeAndDistance';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as NavigationTimeAndDistanceDto?)!;
    }
  }

  Future<void> setAudioGuidance(
      NavigationAudioGuidanceSettingsDto settings) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setAudioGuidance';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[settings]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setSpeedAlertOptions(SpeedAlertOptionsDto options) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setSpeedAlertOptions';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[options]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<List<RouteSegmentDto?>> getRouteSegments() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getRouteSegments';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!
          .cast<RouteSegmentDto?>();
    }
  }

  Future<List<LatLngDto?>> getTraveledRoute() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getTraveledRoute';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<LatLngDto?>();
    }
  }

  Future<RouteSegmentDto?> getCurrentRouteSegment() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getCurrentRouteSegment';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return (__pigeon_replyList[0] as RouteSegmentDto?);
    }
  }

  /// Simulation
  Future<void> setUserLocation(LatLngDto location) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setUserLocation';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[location]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> removeUserLocation() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.removeUserLocation';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> simulateLocationsAlongExistingRoute() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongExistingRoute';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> simulateLocationsAlongExistingRouteWithOptions(
      SimulationOptionsDto options) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongExistingRouteWithOptions';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[options]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<RouteStatusDto> simulateLocationsAlongNewRoute(
      List<NavigationWaypointDto?> waypoints) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongNewRoute';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[waypoints]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return RouteStatusDto.values[__pigeon_replyList[0]! as int];
    }
  }

  Future<RouteStatusDto> simulateLocationsAlongNewRouteWithRoutingOptions(
      List<NavigationWaypointDto?> waypoints,
      RoutingOptionsDto routingOptions) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongNewRouteWithRoutingOptions';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[waypoints, routingOptions]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return RouteStatusDto.values[__pigeon_replyList[0]! as int];
    }
  }

  Future<RouteStatusDto>
      simulateLocationsAlongNewRouteWithRoutingAndSimulationOptions(
          List<NavigationWaypointDto?> waypoints,
          RoutingOptionsDto routingOptions,
          SimulationOptionsDto simulationOptions) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongNewRouteWithRoutingAndSimulationOptions';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
            .send(<Object?>[waypoints, routingOptions, simulationOptions])
        as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return RouteStatusDto.values[__pigeon_replyList[0]! as int];
    }
  }

  Future<void> pauseSimulation() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.pauseSimulation';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> resumeSimulation() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.resumeSimulation';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Simulation (iOS only)
  Future<void> allowBackgroundLocationUpdates(bool allow) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.allowBackgroundLocationUpdates';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[allow]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Road snapped location updates.
  Future<void> enableRoadSnappedLocationUpdates() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.enableRoadSnappedLocationUpdates';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> disableRoadSnappedLocationUpdates() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.disableRoadSnappedLocationUpdates';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Enable Turn-by-Turn navigation events.
  Future<void> enableTurnByTurnNavigationEvents(
      int? numNextStepsToPreview) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.enableTurnByTurnNavigationEvents';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[numNextStepsToPreview]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> disableTurnByTurnNavigationEvents() async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.disableTurnByTurnNavigationEvents';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> registerRemainingTimeOrDistanceChangedListener(
      int remainingTimeThresholdSeconds,
      int remainingDistanceThresholdMeters) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.registerRemainingTimeOrDistanceChangedListener';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[
      remainingTimeThresholdSeconds,
      remainingDistanceThresholdMeters
    ]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }
}

class _NavigationSessionEventApiCodec extends StandardMessageCodec {
  const _NavigationSessionEventApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is LaneDirectionDto) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is LaneDto) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is LatLngDto) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is NavInfoDto) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is NavigationWaypointDto) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is SpeedingUpdatedEventDto) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is StepInfoDto) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is StepInfoDto) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return LaneDirectionDto.decode(readValue(buffer)!);
      case 129:
        return LaneDto.decode(readValue(buffer)!);
      case 130:
        return LatLngDto.decode(readValue(buffer)!);
      case 131:
        return NavInfoDto.decode(readValue(buffer)!);
      case 132:
        return NavigationWaypointDto.decode(readValue(buffer)!);
      case 133:
        return SpeedingUpdatedEventDto.decode(readValue(buffer)!);
      case 134:
        return StepInfoDto.decode(readValue(buffer)!);
      case 135:
        return StepInfoDto.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class NavigationSessionEventApi {
  static const MessageCodec<Object?> pigeonChannelCodec =
      _NavigationSessionEventApiCodec();

  void onSpeedingUpdated(SpeedingUpdatedEventDto msg);

  void onRoadSnappedLocationUpdated(LatLngDto location);

  void onRoadSnappedRawLocationUpdated(LatLngDto location);

  void onArrival(NavigationWaypointDto waypoint);

  void onRouteChanged();

  void onRemainingTimeOrDistanceChanged(
      double remainingTime, double remainingDistance);

  /// Android-only event.
  void onTrafficUpdated();

  /// Android-only event.
  void onRerouting();

  /// Android-only event.
  void onGpsAvailabilityUpdate(bool available);

  /// Turn-by-Turn navigation events.
  void onNavInfo(NavInfoDto navInfo);

  static void setup(NavigationSessionEventApi? api,
      {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onSpeedingUpdated',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onSpeedingUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final SpeedingUpdatedEventDto? arg_msg =
              (args[0] as SpeedingUpdatedEventDto?);
          assert(arg_msg != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onSpeedingUpdated was null, expected non-null SpeedingUpdatedEventDto.');
          try {
            api.onSpeedingUpdated(arg_msg!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRoadSnappedLocationUpdated',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRoadSnappedLocationUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final LatLngDto? arg_location = (args[0] as LatLngDto?);
          assert(arg_location != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRoadSnappedLocationUpdated was null, expected non-null LatLngDto.');
          try {
            api.onRoadSnappedLocationUpdated(arg_location!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRoadSnappedRawLocationUpdated',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRoadSnappedRawLocationUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final LatLngDto? arg_location = (args[0] as LatLngDto?);
          assert(arg_location != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRoadSnappedRawLocationUpdated was null, expected non-null LatLngDto.');
          try {
            api.onRoadSnappedRawLocationUpdated(arg_location!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onArrival',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onArrival was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final NavigationWaypointDto? arg_waypoint =
              (args[0] as NavigationWaypointDto?);
          assert(arg_waypoint != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onArrival was null, expected non-null NavigationWaypointDto.');
          try {
            api.onArrival(arg_waypoint!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRouteChanged',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          try {
            api.onRouteChanged();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRemainingTimeOrDistanceChanged',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRemainingTimeOrDistanceChanged was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final double? arg_remainingTime = (args[0] as double?);
          assert(arg_remainingTime != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRemainingTimeOrDistanceChanged was null, expected non-null double.');
          final double? arg_remainingDistance = (args[1] as double?);
          assert(arg_remainingDistance != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRemainingTimeOrDistanceChanged was null, expected non-null double.');
          try {
            api.onRemainingTimeOrDistanceChanged(
                arg_remainingTime!, arg_remainingDistance!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onTrafficUpdated',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          try {
            api.onTrafficUpdated();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRerouting',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          try {
            api.onRerouting();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onGpsAvailabilityUpdate',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onGpsAvailabilityUpdate was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final bool? arg_available = (args[0] as bool?);
          assert(arg_available != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onGpsAvailabilityUpdate was null, expected non-null bool.');
          try {
            api.onGpsAvailabilityUpdate(arg_available!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onNavInfo',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        __pigeon_channel.setMessageHandler(null);
      } else {
        __pigeon_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onNavInfo was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final NavInfoDto? arg_navInfo = (args[0] as NavInfoDto?);
          assert(arg_navInfo != null,
              'Argument for dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onNavInfo was null, expected non-null NavInfoDto.');
          try {
            api.onNavInfo(arg_navInfo!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}

class NavigationInspector {
  /// Constructor for [NavigationInspector].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  NavigationInspector({BinaryMessenger? binaryMessenger})
      : __pigeon_binaryMessenger = binaryMessenger;
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      StandardMessageCodec();

  Future<bool> isViewAttachedToSession(int viewId) async {
    const String __pigeon_channelName =
        'dev.flutter.pigeon.google_maps_navigation.NavigationInspector.isViewAttachedToSession';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[viewId]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }
}
