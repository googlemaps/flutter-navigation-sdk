// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Autogenerated from Pigeon (v15.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> FlutterError {
  FlutterError(
    code: "channel-error",
    message: "Unable to establish connection on channel: '\(channelName)'.",
    details: ""
  )
}

private func isNullish(_ value: Any?) -> Bool {
  value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Determines the initial visibility of the navigation UI on map initialization.
enum NavigationUIEnabledPreferenceDto: Int {
  /// Navigation UI gets enabled if the navigation
  /// session has already been successfully started.
  case automatic = 0
  /// Navigation UI is disabled.
  case disabled = 1
}

enum MapTypeDto: Int {
  case none = 0
  case normal = 1
  case satellite = 2
  case terrain = 3
  case hybrid = 4
}

enum CameraPerspectiveDto: Int {
  case tilted = 0
  case topDownHeadingUp = 1
  case topDownNorthUp = 2
}

enum MarkerEventTypeDto: Int {
  case clicked = 0
  case infoWindowClicked = 1
  case infoWindowClosed = 2
  case infoWindowLongClicked = 3
}

enum MarkerDragEventTypeDto: Int {
  case drag = 0
  case dragStart = 1
  case dragEnd = 2
}

enum StrokeJointTypeDto: Int {
  case bevel = 0
  case defaultJoint = 1
  case round = 2
}

enum PatternTypeDto: Int {
  case dash = 0
  case dot = 1
  case gap = 2
}

enum CameraEventTypeDto: Int {
  case moveStartedByApi = 0
  case moveStartedByGesture = 1
  case onCameraMove = 2
  case onCameraIdle = 3
  case onCameraStartedFollowingLocation = 4
  case onCameraStoppedFollowingLocation = 5
}

enum AlternateRoutesStrategyDto: Int {
  case all = 0
  case none = 1
  case one = 2
}

enum RoutingStrategyDto: Int {
  case defaultBest = 0
  case deltaToTargetDistance = 1
  case shorter = 2
}

enum TravelModeDto: Int {
  case driving = 0
  case cycling = 1
  case walking = 2
  case twoWheeler = 3
  case taxi = 4
}

enum RouteStatusDto: Int {
  case internalError = 0
  case statusOk = 1
  case routeNotFound = 2
  case networkError = 3
  case quotaExceeded = 4
  case apiKeyNotAuthorized = 5
  case statusCanceled = 6
  case duplicateWaypointsError = 7
  case noWaypointsError = 8
  case locationUnavailable = 9
  case waypointError = 10
  case travelModeUnsupported = 11
  case locationUnknown = 12
  case quotaCheckFailed = 13
  case unknown = 14
}

enum AudioGuidanceTypeDto: Int {
  case silent = 0
  case alertsOnly = 1
  case alertsAndGuidance = 2
}

enum SpeedAlertSeverityDto: Int {
  case unknown = 0
  case notSpeeding = 1
  case minor = 2
  case major = 3
}

enum RouteSegmentTrafficDataStatusDto: Int {
  case ok = 0
  case unavailable = 1
}

enum RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto: Int {
  case unknown = 0
  case slowerTraffic = 1
  case trafficJam = 2
}

/// A set of values that specify the navigation action to take.
enum ManeuverDto: Int {
  /// Arrival at a destination.
  case destination = 0
  /// Starting point of the maneuver.
  case depart = 1
  /// Arrival at a destination located on the left side of the road.
  case destinationLeft = 2
  /// Arrival at a destination located on the right side of the road.
  case destinationRight = 3
  /// Take the boat ferry.
  case ferryBoat = 4
  /// Take the train ferry.
  case ferryTrain = 5
  /// Current road joins another road slightly on the left.
  case forkLeft = 6
  /// Current road joins another road slightly on the right.
  case forkRight = 7
  /// Current road joins another on the left.
  case mergeLeft = 8
  /// Current road joins another on the right.
  case mergeRight = 9
  /// Current road joins another.
  case mergeUnspecified = 10
  /// The street name changes.
  case nameChange = 11
  /// Keep to the left side of the road when exiting a turnpike or freeway as the road diverges.
  case offRampKeepLeft = 12
  /// Keep to the right side of the road when exiting a turnpike or freeway as the road diverges.
  case offRampKeepRight = 13
  /// Regular left turn to exit a turnpike or freeway.
  case offRampLeft = 14
  /// Regular right turn to exit a turnpike or freeway.
  case offRampRight = 15
  /// Sharp left turn to exit a turnpike or freeway.
  case offRampSharpLeft = 16
  /// Sharp right turn to exit a turnpike or freeway.
  case offRampSharpRight = 17
  /// Slight left turn to exit a turnpike or freeway.
  case offRampSlightLeft = 18
  /// Slight right turn to exit a turnpike or freeway.
  case offRampSlightRight = 19
  /// Exit a turnpike or freeway.
  case offRampUnspecified = 20
  /// Clockwise turn onto the opposite side of the street to exit a turnpike or freeway.
  case offRampUTurnClockwise = 21
  /// Counterclockwise turn onto the opposite side of the street to exit a turnpike or freeway.
  case offRampUTurnCounterclockwise = 22
  /// Keep to the left side of the road when entering a turnpike or freeway as the road diverges.
  case onRampKeepLeft = 23
  /// Keep to the right side of the road when entering a turnpike or freeway as the road diverges.
  case onRampKeepRight = 24
  /// Regular left turn to enter a turnpike or freeway.
  case onRampLeft = 25
  /// Regular right turn to enter a turnpike or freeway.
  case onRampRight = 26
  /// Sharp left turn to enter a turnpike or freeway.
  case onRampSharpLeft = 27
  /// Sharp right turn to enter a turnpike or freeway.
  case onRampSharpRight = 28
  /// Slight left turn to enter a turnpike or freeway.
  case onRampSlightLeft = 29
  /// Slight right turn to enter a turnpike or freeway.
  case onRampSlightRight = 30
  /// Enter a turnpike or freeway.
  case onRampUnspecified = 31
  /// Clockwise turn onto the opposite side of the street to enter a turnpike or freeway.
  case onRampUTurnClockwise = 32
  /// Counterclockwise turn onto the opposite side of the street to enter a turnpike or freeway.
  case onRampUTurnCounterclockwise = 33
  /// Enter a roundabout in the clockwise direction.
  case roundaboutClockwise = 34
  /// Enter a roundabout in the counterclockwise direction.
  case roundaboutCounterclockwise = 35
  /// Exit a roundabout in the clockwise direction.
  case roundaboutExitClockwise = 36
  /// Exit a roundabout in the counterclockwise direction.
  case roundaboutExitCounterclockwise = 37
  /// Enter a roundabout in the clockwise direction and turn left.
  case roundaboutLeftClockwise = 38
  /// Enter a roundabout in the counterclockwise direction and turn left.
  case roundaboutLeftCounterclockwise = 39
  /// Enter a roundabout in the clockwise direction and turn right.
  case roundaboutRightClockwise = 40
  /// Enter a roundabout in the counterclockwise direction and turn right.
  case roundaboutRightCounterclockwise = 41
  /// Enter a roundabout in the clockwise direction and turn sharply to the left.
  case roundaboutSharpLeftClockwise = 42
  /// Enter a roundabout in the counterclockwise direction and turn sharply to the left.
  case roundaboutSharpLeftCounterclockwise = 43
  /// Enter a roundabout in the clockwise direction and turn sharply to the right.
  case roundaboutSharpRightClockwise = 44
  /// Enter a roundabout in the counterclockwise direction and turn sharply to the right.
  case roundaboutSharpRightCounterclockwise = 45
  /// Enter a roundabout in the clockwise direction and turn slightly left.
  case roundaboutSlightLeftClockwise = 46
  /// Enter a roundabout in the counterclockwise direction and turn slightly to the left.
  case roundaboutSlightLeftCounterclockwise = 47
  /// Enter a roundabout in the clockwise direction and turn slightly to the right.
  case roundaboutSlightRightClockwise = 48
  /// Enter a roundabout in the counterclockwise direction and turn slightly to the right.
  case roundaboutSlightRightCounterclockwise = 49
  /// Enter a roundabout in the clockwise direction and continue straight.
  case roundaboutStraightClockwise = 50
  /// Enter a roundabout in the counterclockwise direction and continue straight.
  case roundaboutStraightCounterclockwise = 51
  /// Enter a roundabout in the clockwise direction and turn clockwise onto the opposite side of the
  /// street.
  case roundaboutUTurnClockwise = 52
  /// Enter a roundabout in the counterclockwise direction and turn counterclockwise onto the
  /// opposite side of the street.
  case roundaboutUTurnCounterclockwise = 53
  /// Continue straight.
  case straight = 54
  /// Keep left as the road diverges.
  case turnKeepLeft = 55
  /// Keep right as the road diverges.
  case turnKeepRight = 56
  /// Regular left turn at an intersection.
  case turnLeft = 57
  /// Regular right turn at an intersection.
  case turnRight = 58
  /// Sharp left turn at an intersection.
  case turnSharpLeft = 59
  /// Sharp right turn at an intersection.
  case turnSharpRight = 60
  /// Slight left turn at an intersection.
  case turnSlightLeft = 61
  /// Slight right turn at an intersection.
  case turnSlightRight = 62
  /// Clockwise turn onto the opposite side of the street.
  case turnUTurnClockwise = 63
  /// Counterclockwise turn onto the opposite side of the street.
  case turnUTurnCounterclockwise = 64
  /// Unknown maneuver.
  case unknown = 65
}

/// Whether this step is on a drive-on-right or drive-on-left route.
enum DrivingSideDto: Int {
  /// Drive-on-left side.
  case left = 0
  /// Unspecified side.
  case none = 1
  /// Drive-on-right side.
  case right = 2
}

/// The state of navigation.
enum NavStateDto: Int {
  /// Actively navigating.
  case enroute = 0
  /// Actively navigating but searching for a new route.
  case rerouting = 1
  /// Navigation has ended.
  case stopped = 2
  /// Error or unspecified state.
  case unknown = 3
}

/// A set of values that specify the shape of the road path continuing from the Lane.
enum LaneShapeDto: Int {
  /// Normal left turn (45-135 degrees).
  case normalLeft = 0
  /// Normal right turn (45-135 degrees).
  case normalRight = 1
  /// Sharp left turn (135-175 degrees).
  case sharpLeft = 2
  /// Sharp right turn (135-175 degrees).
  case sharpRight = 3
  /// Slight left turn (10-45 degrees).
  case slightLeft = 4
  /// Slight right turn (10-45 degrees).
  case slightRight = 5
  /// No turn.
  case straight = 6
  /// Shape is unknown.
  case unknown = 7
  /// A left turn onto the opposite side of the same street (175-180 degrees).
  case uTurnLeft = 8
  /// A right turn onto the opposite side of the same street (175-180 degrees).
  case uTurnRight = 9
}

/// Object containing map options used to initialize Google Map view.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MapOptionsDto {
  /// The initial positioning of the camera in the map view.
  var cameraPosition: CameraPositionDto
  /// The type of map to display (e.g., satellite, terrain, hybrid, etc.).
  var mapType: MapTypeDto
  /// If true, enables the compass.
  var compassEnabled: Bool
  /// If true, enables the rotation gestures.
  var rotateGesturesEnabled: Bool
  /// If true, enables the scroll gestures.
  var scrollGesturesEnabled: Bool
  /// If true, enables the tilt gestures.
  var tiltGesturesEnabled: Bool
  /// If true, enables the zoom gestures.
  var zoomGesturesEnabled: Bool
  /// If true, enables the scroll gestures during rotate or zoom.
  var scrollGesturesEnabledDuringRotateOrZoom: Bool
  /// If true, enables the map toolbar.
  var mapToolbarEnabled: Bool
  /// The minimum zoom level that can be set for the map.
  var minZoomPreference: Double?
  /// The maximum zoom level that can be set for the map.
  var maxZoomPreference: Double?
  /// If true, enables zoom controls for the map.
  var zoomControlsEnabled: Bool
  /// Specifies a bounds to constrain the camera target, so that when users scroll and pan the map,
  /// the camera target does not move outside these bounds.
  var cameraTargetBounds: LatLngBoundsDto?

  static func fromList(_ list: [Any?]) -> MapOptionsDto? {
    let cameraPosition = CameraPositionDto.fromList(list[0] as! [Any?])!
    let mapType = MapTypeDto(rawValue: list[1] as! Int)!
    let compassEnabled = list[2] as! Bool
    let rotateGesturesEnabled = list[3] as! Bool
    let scrollGesturesEnabled = list[4] as! Bool
    let tiltGesturesEnabled = list[5] as! Bool
    let zoomGesturesEnabled = list[6] as! Bool
    let scrollGesturesEnabledDuringRotateOrZoom = list[7] as! Bool
    let mapToolbarEnabled = list[8] as! Bool
    let minZoomPreference: Double? = nilOrValue(list[9])
    let maxZoomPreference: Double? = nilOrValue(list[10])
    let zoomControlsEnabled = list[11] as! Bool
    var cameraTargetBounds: LatLngBoundsDto?
    if let cameraTargetBoundsList: [Any?] = nilOrValue(list[12]) {
      cameraTargetBounds = LatLngBoundsDto.fromList(cameraTargetBoundsList)
    }

    return MapOptionsDto(
      cameraPosition: cameraPosition,
      mapType: mapType,
      compassEnabled: compassEnabled,
      rotateGesturesEnabled: rotateGesturesEnabled,
      scrollGesturesEnabled: scrollGesturesEnabled,
      tiltGesturesEnabled: tiltGesturesEnabled,
      zoomGesturesEnabled: zoomGesturesEnabled,
      scrollGesturesEnabledDuringRotateOrZoom: scrollGesturesEnabledDuringRotateOrZoom,
      mapToolbarEnabled: mapToolbarEnabled,
      minZoomPreference: minZoomPreference,
      maxZoomPreference: maxZoomPreference,
      zoomControlsEnabled: zoomControlsEnabled,
      cameraTargetBounds: cameraTargetBounds
    )
  }

  func toList() -> [Any?] {
    [
      cameraPosition.toList(),
      mapType.rawValue,
      compassEnabled,
      rotateGesturesEnabled,
      scrollGesturesEnabled,
      tiltGesturesEnabled,
      zoomGesturesEnabled,
      scrollGesturesEnabledDuringRotateOrZoom,
      mapToolbarEnabled,
      minZoomPreference,
      maxZoomPreference,
      zoomControlsEnabled,
      cameraTargetBounds?.toList(),
    ]
  }
}

/// Object containing navigation options used to initialize Google Navigation view.
///
/// Generated class from Pigeon that represents data sent in messages.
struct NavigationViewOptionsDto {
  /// Determines the initial visibility of the navigation UI on map initialization.
  var navigationUIEnabledPreference: NavigationUIEnabledPreferenceDto

  static func fromList(_ list: [Any?]) -> NavigationViewOptionsDto? {
    let navigationUIEnabledPreference = NavigationUIEnabledPreferenceDto(rawValue: list[0] as! Int)!

    return NavigationViewOptionsDto(
      navigationUIEnabledPreference: navigationUIEnabledPreference
    )
  }

  func toList() -> [Any?] {
    [
      navigationUIEnabledPreference.rawValue,
    ]
  }
}

/// A message for creating a new navigation view.
///
/// This message is used to initialize a new navigation view with a
/// specified initial parameters.
///
/// Generated class from Pigeon that represents data sent in messages.
struct NavigationViewCreationOptionsDto {
  var mapOptions: MapOptionsDto
  var navigationViewOptions: NavigationViewOptionsDto

  static func fromList(_ list: [Any?]) -> NavigationViewCreationOptionsDto? {
    let mapOptions = MapOptionsDto.fromList(list[0] as! [Any?])!
    let navigationViewOptions = NavigationViewOptionsDto.fromList(list[1] as! [Any?])!

    return NavigationViewCreationOptionsDto(
      mapOptions: mapOptions,
      navigationViewOptions: navigationViewOptions
    )
  }

  func toList() -> [Any?] {
    [
      mapOptions.toList(),
      navigationViewOptions.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct CameraPositionDto {
  var bearing: Double
  var target: LatLngDto
  var tilt: Double
  var zoom: Double

  static func fromList(_ list: [Any?]) -> CameraPositionDto? {
    let bearing = list[0] as! Double
    let target = LatLngDto.fromList(list[1] as! [Any?])!
    let tilt = list[2] as! Double
    let zoom = list[3] as! Double

    return CameraPositionDto(
      bearing: bearing,
      target: target,
      tilt: tilt,
      zoom: zoom
    )
  }

  func toList() -> [Any?] {
    [
      bearing,
      target.toList(),
      tilt,
      zoom,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct MarkerDto {
  /// Identifies marker
  var markerId: String
  /// Options for marker
  var options: MarkerOptionsDto

  static func fromList(_ list: [Any?]) -> MarkerDto? {
    let markerId = list[0] as! String
    let options = MarkerOptionsDto.fromList(list[1] as! [Any?])!

    return MarkerDto(
      markerId: markerId,
      options: options
    )
  }

  func toList() -> [Any?] {
    [
      markerId,
      options.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct MarkerOptionsDto {
  var alpha: Double
  var anchor: MarkerAnchorDto
  var draggable: Bool
  var flat: Bool
  var consumeTapEvents: Bool
  var position: LatLngDto
  var rotation: Double
  var infoWindow: InfoWindowDto
  var visible: Bool
  var zIndex: Double
  var icon: ImageDescriptorDto

  static func fromList(_ list: [Any?]) -> MarkerOptionsDto? {
    let alpha = list[0] as! Double
    let anchor = MarkerAnchorDto.fromList(list[1] as! [Any?])!
    let draggable = list[2] as! Bool
    let flat = list[3] as! Bool
    let consumeTapEvents = list[4] as! Bool
    let position = LatLngDto.fromList(list[5] as! [Any?])!
    let rotation = list[6] as! Double
    let infoWindow = InfoWindowDto.fromList(list[7] as! [Any?])!
    let visible = list[8] as! Bool
    let zIndex = list[9] as! Double
    let icon = ImageDescriptorDto.fromList(list[10] as! [Any?])!

    return MarkerOptionsDto(
      alpha: alpha,
      anchor: anchor,
      draggable: draggable,
      flat: flat,
      consumeTapEvents: consumeTapEvents,
      position: position,
      rotation: rotation,
      infoWindow: infoWindow,
      visible: visible,
      zIndex: zIndex,
      icon: icon
    )
  }

  func toList() -> [Any?] {
    [
      alpha,
      anchor.toList(),
      draggable,
      flat,
      consumeTapEvents,
      position.toList(),
      rotation,
      infoWindow.toList(),
      visible,
      zIndex,
      icon.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct ImageDescriptorDto {
  var registeredImageId: String?
  var imagePixelRatio: Double?
  var width: Double?
  var height: Double?

  static func fromList(_ list: [Any?]) -> ImageDescriptorDto? {
    let registeredImageId: String? = nilOrValue(list[0])
    let imagePixelRatio: Double? = nilOrValue(list[1])
    let width: Double? = nilOrValue(list[2])
    let height: Double? = nilOrValue(list[3])

    return ImageDescriptorDto(
      registeredImageId: registeredImageId,
      imagePixelRatio: imagePixelRatio,
      width: width,
      height: height
    )
  }

  func toList() -> [Any?] {
    [
      registeredImageId,
      imagePixelRatio,
      width,
      height,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct InfoWindowDto {
  var title: String?
  var snippet: String?
  var anchor: MarkerAnchorDto

  static func fromList(_ list: [Any?]) -> InfoWindowDto? {
    let title: String? = nilOrValue(list[0])
    let snippet: String? = nilOrValue(list[1])
    let anchor = MarkerAnchorDto.fromList(list[2] as! [Any?])!

    return InfoWindowDto(
      title: title,
      snippet: snippet,
      anchor: anchor
    )
  }

  func toList() -> [Any?] {
    [
      title,
      snippet,
      anchor.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct MarkerAnchorDto {
  var u: Double
  var v: Double

  static func fromList(_ list: [Any?]) -> MarkerAnchorDto? {
    let u = list[0] as! Double
    let v = list[1] as! Double

    return MarkerAnchorDto(
      u: u,
      v: v
    )
  }

  func toList() -> [Any?] {
    [
      u,
      v,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PolygonDto {
  var polygonId: String
  var options: PolygonOptionsDto

  static func fromList(_ list: [Any?]) -> PolygonDto? {
    let polygonId = list[0] as! String
    let options = PolygonOptionsDto.fromList(list[1] as! [Any?])!

    return PolygonDto(
      polygonId: polygonId,
      options: options
    )
  }

  func toList() -> [Any?] {
    [
      polygonId,
      options.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PolygonOptionsDto {
  var points: [LatLngDto?]
  var holes: [PolygonHoleDto?]
  var clickable: Bool
  var fillColor: Int64
  var geodesic: Bool
  var strokeColor: Int64
  var strokeWidth: Double
  var visible: Bool
  var zIndex: Double

  static func fromList(_ list: [Any?]) -> PolygonOptionsDto? {
    let points = list[0] as! [LatLngDto?]
    let holes = list[1] as! [PolygonHoleDto?]
    let clickable = list[2] as! Bool
    let fillColor = list[3] is Int64 ? list[3] as! Int64 : Int64(list[3] as! Int32)
    let geodesic = list[4] as! Bool
    let strokeColor = list[5] is Int64 ? list[5] as! Int64 : Int64(list[5] as! Int32)
    let strokeWidth = list[6] as! Double
    let visible = list[7] as! Bool
    let zIndex = list[8] as! Double

    return PolygonOptionsDto(
      points: points,
      holes: holes,
      clickable: clickable,
      fillColor: fillColor,
      geodesic: geodesic,
      strokeColor: strokeColor,
      strokeWidth: strokeWidth,
      visible: visible,
      zIndex: zIndex
    )
  }

  func toList() -> [Any?] {
    [
      points,
      holes,
      clickable,
      fillColor,
      geodesic,
      strokeColor,
      strokeWidth,
      visible,
      zIndex,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PolygonHoleDto {
  var points: [LatLngDto?]

  static func fromList(_ list: [Any?]) -> PolygonHoleDto? {
    let points = list[0] as! [LatLngDto?]

    return PolygonHoleDto(
      points: points
    )
  }

  func toList() -> [Any?] {
    [
      points,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct StyleSpanStrokeStyleDto {
  var solidColor: Int64?
  var fromColor: Int64?
  var toColor: Int64?

  static func fromList(_ list: [Any?]) -> StyleSpanStrokeStyleDto? {
    let solidColor: Int64? = isNullish(list[0]) ? nil :
      (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let fromColor: Int64? = isNullish(list[1]) ? nil :
      (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))
    let toColor: Int64? = isNullish(list[2]) ? nil :
      (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))

    return StyleSpanStrokeStyleDto(
      solidColor: solidColor,
      fromColor: fromColor,
      toColor: toColor
    )
  }

  func toList() -> [Any?] {
    [
      solidColor,
      fromColor,
      toColor,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct StyleSpanDto {
  var length: Double
  var style: StyleSpanStrokeStyleDto

  static func fromList(_ list: [Any?]) -> StyleSpanDto? {
    let length = list[0] as! Double
    let style = StyleSpanStrokeStyleDto.fromList(list[1] as! [Any?])!

    return StyleSpanDto(
      length: length,
      style: style
    )
  }

  func toList() -> [Any?] {
    [
      length,
      style.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PolylineDto {
  var polylineId: String
  var options: PolylineOptionsDto

  static func fromList(_ list: [Any?]) -> PolylineDto? {
    let polylineId = list[0] as! String
    let options = PolylineOptionsDto.fromList(list[1] as! [Any?])!

    return PolylineDto(
      polylineId: polylineId,
      options: options
    )
  }

  func toList() -> [Any?] {
    [
      polylineId,
      options.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PatternItemDto {
  var type: PatternTypeDto
  var length: Double?

  static func fromList(_ list: [Any?]) -> PatternItemDto? {
    let type = PatternTypeDto(rawValue: list[0] as! Int)!
    let length: Double? = nilOrValue(list[1])

    return PatternItemDto(
      type: type,
      length: length
    )
  }

  func toList() -> [Any?] {
    [
      type.rawValue,
      length,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PolylineOptionsDto {
  var points: [LatLngDto?]?
  var clickable: Bool?
  var geodesic: Bool?
  var strokeColor: Int64?
  var strokeJointType: StrokeJointTypeDto?
  var strokePattern: [PatternItemDto?]?
  var strokeWidth: Double?
  var visible: Bool?
  var zIndex: Double?
  var spans: [StyleSpanDto?]

  static func fromList(_ list: [Any?]) -> PolylineOptionsDto? {
    let points: [LatLngDto?]? = nilOrValue(list[0])
    let clickable: Bool? = nilOrValue(list[1])
    let geodesic: Bool? = nilOrValue(list[2])
    let strokeColor: Int64? = isNullish(list[3]) ? nil :
      (list[3] is Int64? ? list[3] as! Int64? : Int64(list[3] as! Int32))
    var strokeJointType: StrokeJointTypeDto?
    let strokeJointTypeEnumVal: Int? = nilOrValue(list[4])
    if let strokeJointTypeRawValue = strokeJointTypeEnumVal {
      strokeJointType = StrokeJointTypeDto(rawValue: strokeJointTypeRawValue)!
    }
    let strokePattern: [PatternItemDto?]? = nilOrValue(list[5])
    let strokeWidth: Double? = nilOrValue(list[6])
    let visible: Bool? = nilOrValue(list[7])
    let zIndex: Double? = nilOrValue(list[8])
    let spans = list[9] as! [StyleSpanDto?]

    return PolylineOptionsDto(
      points: points,
      clickable: clickable,
      geodesic: geodesic,
      strokeColor: strokeColor,
      strokeJointType: strokeJointType,
      strokePattern: strokePattern,
      strokeWidth: strokeWidth,
      visible: visible,
      zIndex: zIndex,
      spans: spans
    )
  }

  func toList() -> [Any?] {
    [
      points,
      clickable,
      geodesic,
      strokeColor,
      strokeJointType?.rawValue,
      strokePattern,
      strokeWidth,
      visible,
      zIndex,
      spans,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct CircleDto {
  /// Identifies circle.
  var circleId: String
  /// Options for circle.
  var options: CircleOptionsDto

  static func fromList(_ list: [Any?]) -> CircleDto? {
    let circleId = list[0] as! String
    let options = CircleOptionsDto.fromList(list[1] as! [Any?])!

    return CircleDto(
      circleId: circleId,
      options: options
    )
  }

  func toList() -> [Any?] {
    [
      circleId,
      options.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct CircleOptionsDto {
  var position: LatLngDto
  var radius: Double
  var strokeWidth: Double
  var strokeColor: Int64
  var strokePattern: [PatternItemDto?]
  var fillColor: Int64
  var zIndex: Double
  var visible: Bool
  var clickable: Bool

  static func fromList(_ list: [Any?]) -> CircleOptionsDto? {
    let position = LatLngDto.fromList(list[0] as! [Any?])!
    let radius = list[1] as! Double
    let strokeWidth = list[2] as! Double
    let strokeColor = list[3] is Int64 ? list[3] as! Int64 : Int64(list[3] as! Int32)
    let strokePattern = list[4] as! [PatternItemDto?]
    let fillColor = list[5] is Int64 ? list[5] as! Int64 : Int64(list[5] as! Int32)
    let zIndex = list[6] as! Double
    let visible = list[7] as! Bool
    let clickable = list[8] as! Bool

    return CircleOptionsDto(
      position: position,
      radius: radius,
      strokeWidth: strokeWidth,
      strokeColor: strokeColor,
      strokePattern: strokePattern,
      fillColor: fillColor,
      zIndex: zIndex,
      visible: visible,
      clickable: clickable
    )
  }

  func toList() -> [Any?] {
    [
      position.toList(),
      radius,
      strokeWidth,
      strokeColor,
      strokePattern,
      fillColor,
      zIndex,
      visible,
      clickable,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RouteTokenOptionsDto {
  var routeToken: String
  var travelMode: TravelModeDto?

  static func fromList(_ list: [Any?]) -> RouteTokenOptionsDto? {
    let routeToken = list[0] as! String
    var travelMode: TravelModeDto?
    let travelModeEnumVal: Int? = nilOrValue(list[1])
    if let travelModeRawValue = travelModeEnumVal {
      travelMode = TravelModeDto(rawValue: travelModeRawValue)!
    }

    return RouteTokenOptionsDto(
      routeToken: routeToken,
      travelMode: travelMode
    )
  }

  func toList() -> [Any?] {
    [
      routeToken,
      travelMode?.rawValue,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct DestinationsDto {
  var waypoints: [NavigationWaypointDto?]
  var displayOptions: NavigationDisplayOptionsDto
  var routingOptions: RoutingOptionsDto?
  var routeTokenOptions: RouteTokenOptionsDto?

  static func fromList(_ list: [Any?]) -> DestinationsDto? {
    let waypoints = list[0] as! [NavigationWaypointDto?]
    let displayOptions = NavigationDisplayOptionsDto.fromList(list[1] as! [Any?])!
    var routingOptions: RoutingOptionsDto?
    if let routingOptionsList: [Any?] = nilOrValue(list[2]) {
      routingOptions = RoutingOptionsDto.fromList(routingOptionsList)
    }
    var routeTokenOptions: RouteTokenOptionsDto?
    if let routeTokenOptionsList: [Any?] = nilOrValue(list[3]) {
      routeTokenOptions = RouteTokenOptionsDto.fromList(routeTokenOptionsList)
    }

    return DestinationsDto(
      waypoints: waypoints,
      displayOptions: displayOptions,
      routingOptions: routingOptions,
      routeTokenOptions: routeTokenOptions
    )
  }

  func toList() -> [Any?] {
    [
      waypoints,
      displayOptions.toList(),
      routingOptions?.toList(),
      routeTokenOptions?.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RoutingOptionsDto {
  var alternateRoutesStrategy: AlternateRoutesStrategyDto?
  var routingStrategy: RoutingStrategyDto?
  var targetDistanceMeters: [Int64?]?
  var travelMode: TravelModeDto?
  var avoidTolls: Bool?
  var avoidFerries: Bool?
  var avoidHighways: Bool?
  var locationTimeoutMs: Int64?

  static func fromList(_ list: [Any?]) -> RoutingOptionsDto? {
    var alternateRoutesStrategy: AlternateRoutesStrategyDto?
    let alternateRoutesStrategyEnumVal: Int? = nilOrValue(list[0])
    if let alternateRoutesStrategyRawValue = alternateRoutesStrategyEnumVal {
      alternateRoutesStrategy =
        AlternateRoutesStrategyDto(rawValue: alternateRoutesStrategyRawValue)!
    }
    var routingStrategy: RoutingStrategyDto?
    let routingStrategyEnumVal: Int? = nilOrValue(list[1])
    if let routingStrategyRawValue = routingStrategyEnumVal {
      routingStrategy = RoutingStrategyDto(rawValue: routingStrategyRawValue)!
    }
    let targetDistanceMeters: [Int64?]? = nilOrValue(list[2])
    var travelMode: TravelModeDto?
    let travelModeEnumVal: Int? = nilOrValue(list[3])
    if let travelModeRawValue = travelModeEnumVal {
      travelMode = TravelModeDto(rawValue: travelModeRawValue)!
    }
    let avoidTolls: Bool? = nilOrValue(list[4])
    let avoidFerries: Bool? = nilOrValue(list[5])
    let avoidHighways: Bool? = nilOrValue(list[6])
    let locationTimeoutMs: Int64? = isNullish(list[7]) ? nil :
      (list[7] is Int64? ? list[7] as! Int64? : Int64(list[7] as! Int32))

    return RoutingOptionsDto(
      alternateRoutesStrategy: alternateRoutesStrategy,
      routingStrategy: routingStrategy,
      targetDistanceMeters: targetDistanceMeters,
      travelMode: travelMode,
      avoidTolls: avoidTolls,
      avoidFerries: avoidFerries,
      avoidHighways: avoidHighways,
      locationTimeoutMs: locationTimeoutMs
    )
  }

  func toList() -> [Any?] {
    [
      alternateRoutesStrategy?.rawValue,
      routingStrategy?.rawValue,
      targetDistanceMeters,
      travelMode?.rawValue,
      avoidTolls,
      avoidFerries,
      avoidHighways,
      locationTimeoutMs,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NavigationDisplayOptionsDto {
  var showDestinationMarkers: Bool?
  var showStopSigns: Bool?
  var showTrafficLights: Bool?

  static func fromList(_ list: [Any?]) -> NavigationDisplayOptionsDto? {
    let showDestinationMarkers: Bool? = nilOrValue(list[0])
    let showStopSigns: Bool? = nilOrValue(list[1])
    let showTrafficLights: Bool? = nilOrValue(list[2])

    return NavigationDisplayOptionsDto(
      showDestinationMarkers: showDestinationMarkers,
      showStopSigns: showStopSigns,
      showTrafficLights: showTrafficLights
    )
  }

  func toList() -> [Any?] {
    [
      showDestinationMarkers,
      showStopSigns,
      showTrafficLights,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NavigationWaypointDto {
  var title: String
  var target: LatLngDto?
  var placeID: String?
  var preferSameSideOfRoad: Bool?
  var preferredSegmentHeading: Int64?

  static func fromList(_ list: [Any?]) -> NavigationWaypointDto? {
    let title = list[0] as! String
    var target: LatLngDto?
    if let targetList: [Any?] = nilOrValue(list[1]) {
      target = LatLngDto.fromList(targetList)
    }
    let placeID: String? = nilOrValue(list[2])
    let preferSameSideOfRoad: Bool? = nilOrValue(list[3])
    let preferredSegmentHeading: Int64? = isNullish(list[4]) ? nil :
      (list[4] is Int64? ? list[4] as! Int64? : Int64(list[4] as! Int32))

    return NavigationWaypointDto(
      title: title,
      target: target,
      placeID: placeID,
      preferSameSideOfRoad: preferSameSideOfRoad,
      preferredSegmentHeading: preferredSegmentHeading
    )
  }

  func toList() -> [Any?] {
    [
      title,
      target?.toList(),
      placeID,
      preferSameSideOfRoad,
      preferredSegmentHeading,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NavigationTimeAndDistanceDto {
  var time: Double
  var distance: Double

  static func fromList(_ list: [Any?]) -> NavigationTimeAndDistanceDto? {
    let time = list[0] as! Double
    let distance = list[1] as! Double

    return NavigationTimeAndDistanceDto(
      time: time,
      distance: distance
    )
  }

  func toList() -> [Any?] {
    [
      time,
      distance,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NavigationAudioGuidanceSettingsDto {
  var isBluetoothAudioEnabled: Bool?
  var isVibrationEnabled: Bool?
  var guidanceType: AudioGuidanceTypeDto?

  static func fromList(_ list: [Any?]) -> NavigationAudioGuidanceSettingsDto? {
    let isBluetoothAudioEnabled: Bool? = nilOrValue(list[0])
    let isVibrationEnabled: Bool? = nilOrValue(list[1])
    var guidanceType: AudioGuidanceTypeDto?
    let guidanceTypeEnumVal: Int? = nilOrValue(list[2])
    if let guidanceTypeRawValue = guidanceTypeEnumVal {
      guidanceType = AudioGuidanceTypeDto(rawValue: guidanceTypeRawValue)!
    }

    return NavigationAudioGuidanceSettingsDto(
      isBluetoothAudioEnabled: isBluetoothAudioEnabled,
      isVibrationEnabled: isVibrationEnabled,
      guidanceType: guidanceType
    )
  }

  func toList() -> [Any?] {
    [
      isBluetoothAudioEnabled,
      isVibrationEnabled,
      guidanceType?.rawValue,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SimulationOptionsDto {
  var speedMultiplier: Double

  static func fromList(_ list: [Any?]) -> SimulationOptionsDto? {
    let speedMultiplier = list[0] as! Double

    return SimulationOptionsDto(
      speedMultiplier: speedMultiplier
    )
  }

  func toList() -> [Any?] {
    [
      speedMultiplier,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct LatLngDto {
  var latitude: Double
  var longitude: Double

  static func fromList(_ list: [Any?]) -> LatLngDto? {
    let latitude = list[0] as! Double
    let longitude = list[1] as! Double

    return LatLngDto(
      latitude: latitude,
      longitude: longitude
    )
  }

  func toList() -> [Any?] {
    [
      latitude,
      longitude,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct LatLngBoundsDto {
  var southwest: LatLngDto
  var northeast: LatLngDto

  static func fromList(_ list: [Any?]) -> LatLngBoundsDto? {
    let southwest = LatLngDto.fromList(list[0] as! [Any?])!
    let northeast = LatLngDto.fromList(list[1] as! [Any?])!

    return LatLngBoundsDto(
      southwest: southwest,
      northeast: northeast
    )
  }

  func toList() -> [Any?] {
    [
      southwest.toList(),
      northeast.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SpeedingUpdatedEventDto {
  var percentageAboveLimit: Double
  var severity: SpeedAlertSeverityDto

  static func fromList(_ list: [Any?]) -> SpeedingUpdatedEventDto? {
    let percentageAboveLimit = list[0] as! Double
    let severity = SpeedAlertSeverityDto(rawValue: list[1] as! Int)!

    return SpeedingUpdatedEventDto(
      percentageAboveLimit: percentageAboveLimit,
      severity: severity
    )
  }

  func toList() -> [Any?] {
    [
      percentageAboveLimit,
      severity.rawValue,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SpeedAlertOptionsDto {
  var severityUpgradeDurationSeconds: Double
  var minorSpeedAlertThresholdPercentage: Double
  var majorSpeedAlertThresholdPercentage: Double

  static func fromList(_ list: [Any?]) -> SpeedAlertOptionsDto? {
    let severityUpgradeDurationSeconds = list[0] as! Double
    let minorSpeedAlertThresholdPercentage = list[1] as! Double
    let majorSpeedAlertThresholdPercentage = list[2] as! Double

    return SpeedAlertOptionsDto(
      severityUpgradeDurationSeconds: severityUpgradeDurationSeconds,
      minorSpeedAlertThresholdPercentage: minorSpeedAlertThresholdPercentage,
      majorSpeedAlertThresholdPercentage: majorSpeedAlertThresholdPercentage
    )
  }

  func toList() -> [Any?] {
    [
      severityUpgradeDurationSeconds,
      minorSpeedAlertThresholdPercentage,
      majorSpeedAlertThresholdPercentage,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RouteSegmentTrafficDataRoadStretchRenderingDataDto {
  var style: RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto
  var lengthMeters: Int64
  var offsetMeters: Int64

  static func fromList(_ list: [Any?]) -> RouteSegmentTrafficDataRoadStretchRenderingDataDto? {
    let style = RouteSegmentTrafficDataRoadStretchRenderingDataStyleDto(rawValue: list[0] as! Int)!
    let lengthMeters = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    let offsetMeters = list[2] is Int64 ? list[2] as! Int64 : Int64(list[2] as! Int32)

    return RouteSegmentTrafficDataRoadStretchRenderingDataDto(
      style: style,
      lengthMeters: lengthMeters,
      offsetMeters: offsetMeters
    )
  }

  func toList() -> [Any?] {
    [
      style.rawValue,
      lengthMeters,
      offsetMeters,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RouteSegmentTrafficDataDto {
  var status: RouteSegmentTrafficDataStatusDto
  var roadStretchRenderingDataList: [RouteSegmentTrafficDataRoadStretchRenderingDataDto?]

  static func fromList(_ list: [Any?]) -> RouteSegmentTrafficDataDto? {
    let status = RouteSegmentTrafficDataStatusDto(rawValue: list[0] as! Int)!
    let roadStretchRenderingDataList =
      list[1] as! [RouteSegmentTrafficDataRoadStretchRenderingDataDto?]

    return RouteSegmentTrafficDataDto(
      status: status,
      roadStretchRenderingDataList: roadStretchRenderingDataList
    )
  }

  func toList() -> [Any?] {
    [
      status.rawValue,
      roadStretchRenderingDataList,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RouteSegmentDto {
  var trafficData: RouteSegmentTrafficDataDto?
  var destinationLatLng: LatLngDto
  var latLngs: [LatLngDto?]?
  var destinationWaypoint: NavigationWaypointDto?

  static func fromList(_ list: [Any?]) -> RouteSegmentDto? {
    var trafficData: RouteSegmentTrafficDataDto?
    if let trafficDataList: [Any?] = nilOrValue(list[0]) {
      trafficData = RouteSegmentTrafficDataDto.fromList(trafficDataList)
    }
    let destinationLatLng = LatLngDto.fromList(list[1] as! [Any?])!
    let latLngs: [LatLngDto?]? = nilOrValue(list[2])
    var destinationWaypoint: NavigationWaypointDto?
    if let destinationWaypointList: [Any?] = nilOrValue(list[3]) {
      destinationWaypoint = NavigationWaypointDto.fromList(destinationWaypointList)
    }

    return RouteSegmentDto(
      trafficData: trafficData,
      destinationLatLng: destinationLatLng,
      latLngs: latLngs,
      destinationWaypoint: destinationWaypoint
    )
  }

  func toList() -> [Any?] {
    [
      trafficData?.toList(),
      destinationLatLng.toList(),
      latLngs,
      destinationWaypoint?.toList(),
    ]
  }
}

/// One of the possible directions from a lane at the end of a route step, and whether it is on the
/// recommended route.
///
/// Generated class from Pigeon that represents data sent in messages.
struct LaneDirectionDto {
  /// Shape for this lane direction.
  var laneShape: LaneShapeDto
  /// Whether this lane is recommended.
  var isRecommended: Bool

  static func fromList(_ list: [Any?]) -> LaneDirectionDto? {
    let laneShape = LaneShapeDto(rawValue: list[0] as! Int)!
    let isRecommended = list[1] as! Bool

    return LaneDirectionDto(
      laneShape: laneShape,
      isRecommended: isRecommended
    )
  }

  func toList() -> [Any?] {
    [
      laneShape.rawValue,
      isRecommended,
    ]
  }
}

/// Single lane on the road at the end of a route step.
///
/// Generated class from Pigeon that represents data sent in messages.
struct LaneDto {
  /// List of possible directions a driver can follow when using this lane at the end of the
  /// respective route step
  var laneDirections: [LaneDirectionDto?]

  static func fromList(_ list: [Any?]) -> LaneDto? {
    let laneDirections = list[0] as! [LaneDirectionDto?]

    return LaneDto(
      laneDirections: laneDirections
    )
  }

  func toList() -> [Any?] {
    [
      laneDirections,
    ]
  }
}

/// Information about a single step along a navigation route.
///
/// Generated class from Pigeon that represents data sent in messages.
struct StepInfoDto {
  /// Distance in meters from the previous step to this step.
  var distanceFromPrevStepMeters: Int64
  /// Time in seconds from the previous step to this step.
  var timeFromPrevStepSeconds: Int64
  /// Whether this step is on a drive-on-right or drive-on-left route.
  var drivingSide: DrivingSideDto
  /// The exit number if it exists.
  var exitNumber: String?
  /// The full text of the instruction for this step.
  var fullInstructions: String
  /// The full road name for this step.
  var fullRoadName: String
  /// The simplified version of the road name.
  var simpleRoadName: String
  /// The counted number of the exit to take relative to the location where the
  /// roundabout was entered.
  var roundaboutTurnNumber: Int64
  /// The list of available lanes at the end of this route step.
  var lanes: [LaneDto?]
  /// The maneuver for this step.
  var maneuver: ManeuverDto
  /// The index of the step in the list of all steps in the route.
  var stepNumber: Int64

  static func fromList(_ list: [Any?]) -> StepInfoDto? {
    let distanceFromPrevStepMeters = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let timeFromPrevStepSeconds = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    let drivingSide = DrivingSideDto(rawValue: list[2] as! Int)!
    let exitNumber: String? = nilOrValue(list[3])
    let fullInstructions = list[4] as! String
    let fullRoadName = list[5] as! String
    let simpleRoadName = list[6] as! String
    let roundaboutTurnNumber = list[7] is Int64 ? list[7] as! Int64 : Int64(list[7] as! Int32)
    let lanes = list[8] as! [LaneDto?]
    let maneuver = ManeuverDto(rawValue: list[9] as! Int)!
    let stepNumber = list[10] is Int64 ? list[10] as! Int64 : Int64(list[10] as! Int32)

    return StepInfoDto(
      distanceFromPrevStepMeters: distanceFromPrevStepMeters,
      timeFromPrevStepSeconds: timeFromPrevStepSeconds,
      drivingSide: drivingSide,
      exitNumber: exitNumber,
      fullInstructions: fullInstructions,
      fullRoadName: fullRoadName,
      simpleRoadName: simpleRoadName,
      roundaboutTurnNumber: roundaboutTurnNumber,
      lanes: lanes,
      maneuver: maneuver,
      stepNumber: stepNumber
    )
  }

  func toList() -> [Any?] {
    [
      distanceFromPrevStepMeters,
      timeFromPrevStepSeconds,
      drivingSide.rawValue,
      exitNumber,
      fullInstructions,
      fullRoadName,
      simpleRoadName,
      roundaboutTurnNumber,
      lanes,
      maneuver.rawValue,
      stepNumber,
    ]
  }
}

/// Contains information about the state of navigation, the current nav step if
/// available, and remaining steps if available.
///
/// Generated class from Pigeon that represents data sent in messages.
struct NavInfoDto {
  /// The current state of navigation.
  var navState: NavStateDto
  /// Information about the upcoming maneuver step.
  var currentStep: StepInfoDto?
  /// The remaining steps after the current step.
  var remainingSteps: [StepInfoDto?]
  /// Whether the route has changed since the last sent message.
  var routeChanged: Bool
  /// Estimated remaining distance in meters along the route to the
  /// current step.
  var distanceToCurrentStepMeters: Int64?
  /// The estimated remaining distance in meters to the final destination which
  /// is the last destination in a multi-destination trip.
  var distanceToFinalDestinationMeters: Int64?
  /// The estimated remaining distance in meters to the next destination.
  ///
  /// Android only.
  var distanceToNextDestinationMeters: Int64?
  /// The estimated remaining time in seconds along the route to the
  /// current step.
  var timeToCurrentStepSeconds: Int64?
  /// The estimated remaining time in seconds to the final destination which is
  /// the last destination in a multi-destination trip.
  var timeToFinalDestinationSeconds: Int64?
  /// The estimated remaining time in seconds to the next destination.
  ///
  /// Android only.
  var timeToNextDestinationSeconds: Int64?

  static func fromList(_ list: [Any?]) -> NavInfoDto? {
    let navState = NavStateDto(rawValue: list[0] as! Int)!
    var currentStep: StepInfoDto?
    if let currentStepList: [Any?] = nilOrValue(list[1]) {
      currentStep = StepInfoDto.fromList(currentStepList)
    }
    let remainingSteps = list[2] as! [StepInfoDto?]
    let routeChanged = list[3] as! Bool
    let distanceToCurrentStepMeters: Int64? = isNullish(list[4]) ? nil :
      (list[4] is Int64? ? list[4] as! Int64? : Int64(list[4] as! Int32))
    let distanceToFinalDestinationMeters: Int64? = isNullish(list[5]) ? nil :
      (list[5] is Int64? ? list[5] as! Int64? : Int64(list[5] as! Int32))
    let distanceToNextDestinationMeters: Int64? = isNullish(list[6]) ? nil :
      (list[6] is Int64? ? list[6] as! Int64? : Int64(list[6] as! Int32))
    let timeToCurrentStepSeconds: Int64? = isNullish(list[7]) ? nil :
      (list[7] is Int64? ? list[7] as! Int64? : Int64(list[7] as! Int32))
    let timeToFinalDestinationSeconds: Int64? = isNullish(list[8]) ? nil :
      (list[8] is Int64? ? list[8] as! Int64? : Int64(list[8] as! Int32))
    let timeToNextDestinationSeconds: Int64? = isNullish(list[9]) ? nil :
      (list[9] is Int64? ? list[9] as! Int64? : Int64(list[9] as! Int32))

    return NavInfoDto(
      navState: navState,
      currentStep: currentStep,
      remainingSteps: remainingSteps,
      routeChanged: routeChanged,
      distanceToCurrentStepMeters: distanceToCurrentStepMeters,
      distanceToFinalDestinationMeters: distanceToFinalDestinationMeters,
      distanceToNextDestinationMeters: distanceToNextDestinationMeters,
      timeToCurrentStepSeconds: timeToCurrentStepSeconds,
      timeToFinalDestinationSeconds: timeToFinalDestinationSeconds,
      timeToNextDestinationSeconds: timeToNextDestinationSeconds
    )
  }

  func toList() -> [Any?] {
    [
      navState.rawValue,
      currentStep?.toList(),
      remainingSteps,
      routeChanged,
      distanceToCurrentStepMeters,
      distanceToFinalDestinationMeters,
      distanceToNextDestinationMeters,
      timeToCurrentStepSeconds,
      timeToFinalDestinationSeconds,
      timeToNextDestinationSeconds,
    ]
  }
}

private class _NavigationViewCreationApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return CameraPositionDto.fromList(readValue() as! [Any?])
    case 129:
      return LatLngBoundsDto.fromList(readValue() as! [Any?])
    case 130:
      return LatLngDto.fromList(readValue() as! [Any?])
    case 131:
      return MapOptionsDto.fromList(readValue() as! [Any?])
    case 132:
      return NavigationViewCreationOptionsDto.fromList(readValue() as! [Any?])
    case 133:
      return NavigationViewOptionsDto.fromList(readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class _NavigationViewCreationApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CameraPositionDto {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? LatLngBoundsDto {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? LatLngDto {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? MapOptionsDto {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? NavigationViewCreationOptionsDto {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? NavigationViewOptionsDto {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class _NavigationViewCreationApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    _NavigationViewCreationApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    _NavigationViewCreationApiCodecWriter(data: data)
  }
}

class _NavigationViewCreationApiCodec: FlutterStandardMessageCodec {
  static let shared =
    _NavigationViewCreationApiCodec(readerWriter: _NavigationViewCreationApiCodecReaderWriter())
}

/// Pigeon only generates messages if the messages are used in API.
/// [MapOptionsDto] is encoded and decoded directly to generate
/// a PlatformView creation message. This API should never be used directly.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _NavigationViewCreationApi {
  func _create(msg: NavigationViewCreationOptionsDto) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
enum _NavigationViewCreationApiSetup {
  /// The codec used by _NavigationViewCreationApi.
  static var codec: FlutterStandardMessageCodec { _NavigationViewCreationApiCodec.shared }
  /// Sets up an instance of `_NavigationViewCreationApi` to handle messages through the
  /// `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _NavigationViewCreationApi?) {
    let _createChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation._NavigationViewCreationApi._create",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      _createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! NavigationViewCreationOptionsDto
        do {
          try api._create(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      _createChannel.setMessageHandler(nil)
    }
  }
}

private class NavigationViewApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return CameraPositionDto.fromList(readValue() as! [Any?])
    case 129:
      return CircleDto.fromList(readValue() as! [Any?])
    case 130:
      return CircleOptionsDto.fromList(readValue() as! [Any?])
    case 131:
      return ImageDescriptorDto.fromList(readValue() as! [Any?])
    case 132:
      return InfoWindowDto.fromList(readValue() as! [Any?])
    case 133:
      return LatLngBoundsDto.fromList(readValue() as! [Any?])
    case 134:
      return LatLngDto.fromList(readValue() as! [Any?])
    case 135:
      return LatLngDto.fromList(readValue() as! [Any?])
    case 136:
      return MarkerAnchorDto.fromList(readValue() as! [Any?])
    case 137:
      return MarkerDto.fromList(readValue() as! [Any?])
    case 138:
      return MarkerOptionsDto.fromList(readValue() as! [Any?])
    case 139:
      return PatternItemDto.fromList(readValue() as! [Any?])
    case 140:
      return PolygonDto.fromList(readValue() as! [Any?])
    case 141:
      return PolygonHoleDto.fromList(readValue() as! [Any?])
    case 142:
      return PolygonOptionsDto.fromList(readValue() as! [Any?])
    case 143:
      return PolylineDto.fromList(readValue() as! [Any?])
    case 144:
      return PolylineOptionsDto.fromList(readValue() as! [Any?])
    case 145:
      return StyleSpanDto.fromList(readValue() as! [Any?])
    case 146:
      return StyleSpanStrokeStyleDto.fromList(readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class NavigationViewApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CameraPositionDto {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? CircleDto {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? CircleOptionsDto {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? ImageDescriptorDto {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? InfoWindowDto {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? LatLngBoundsDto {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? LatLngDto {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? LatLngDto {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? MarkerAnchorDto {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? MarkerDto {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? MarkerOptionsDto {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? PatternItemDto {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? PolygonDto {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? PolygonHoleDto {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? PolygonOptionsDto {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? PolylineDto {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? PolylineOptionsDto {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? StyleSpanDto {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? StyleSpanStrokeStyleDto {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class NavigationViewApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    NavigationViewApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    NavigationViewApiCodecWriter(data: data)
  }
}

class NavigationViewApiCodec: FlutterStandardMessageCodec {
  static let shared = NavigationViewApiCodec(readerWriter: NavigationViewApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol NavigationViewApi {
  func awaitMapReady(viewId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func isMyLocationEnabled(viewId: Int64) throws -> Bool
  func setMyLocationEnabled(viewId: Int64, enabled: Bool) throws
  func getMyLocation(viewId: Int64) throws -> LatLngDto?
  func getMapType(viewId: Int64) throws -> MapTypeDto
  func setMapType(viewId: Int64, mapType: MapTypeDto) throws
  func setMapStyle(viewId: Int64, styleJson: String) throws
  func isNavigationTripProgressBarEnabled(viewId: Int64) throws -> Bool
  func setNavigationTripProgressBarEnabled(viewId: Int64, enabled: Bool) throws
  func isNavigationHeaderEnabled(viewId: Int64) throws -> Bool
  func setNavigationHeaderEnabled(viewId: Int64, enabled: Bool) throws
  func isNavigationFooterEnabled(viewId: Int64) throws -> Bool
  func setNavigationFooterEnabled(viewId: Int64, enabled: Bool) throws
  func isRecenterButtonEnabled(viewId: Int64) throws -> Bool
  func setRecenterButtonEnabled(viewId: Int64, enabled: Bool) throws
  func isSpeedLimitIconEnabled(viewId: Int64) throws -> Bool
  func setSpeedLimitIconEnabled(viewId: Int64, enabled: Bool) throws
  func isSpeedometerEnabled(viewId: Int64) throws -> Bool
  func setSpeedometerEnabled(viewId: Int64, enabled: Bool) throws
  func isTrafficIncidentCardsEnabled(viewId: Int64) throws -> Bool
  func setTrafficIncidentCardsEnabled(viewId: Int64, enabled: Bool) throws
  func isNavigationUIEnabled(viewId: Int64) throws -> Bool
  func setNavigationUIEnabled(viewId: Int64, enabled: Bool) throws
  func getCameraPosition(viewId: Int64) throws -> CameraPositionDto
  func getVisibleRegion(viewId: Int64) throws -> LatLngBoundsDto
  func followMyLocation(viewId: Int64, perspective: CameraPerspectiveDto, zoomLevel: Double?) throws
  func animateCameraToCameraPosition(viewId: Int64, cameraPosition: CameraPositionDto,
                                     duration: Int64?,
                                     completion: @escaping (Result<Bool, Error>) -> Void)
  func animateCameraToLatLng(viewId: Int64, point: LatLngDto, duration: Int64?,
                             completion: @escaping (Result<Bool, Error>) -> Void)
  func animateCameraToLatLngBounds(viewId: Int64, bounds: LatLngBoundsDto, padding: Double,
                                   duration: Int64?,
                                   completion: @escaping (Result<Bool, Error>) -> Void)
  func animateCameraToLatLngZoom(viewId: Int64, point: LatLngDto, zoom: Double, duration: Int64?,
                                 completion: @escaping (Result<Bool, Error>) -> Void)
  func animateCameraByScroll(viewId: Int64, scrollByDx: Double, scrollByDy: Double,
                             duration: Int64?, completion: @escaping (Result<Bool, Error>) -> Void)
  func animateCameraByZoom(viewId: Int64, zoomBy: Double, focusDx: Double?, focusDy: Double?,
                           duration: Int64?, completion: @escaping (Result<Bool, Error>) -> Void)
  func animateCameraToZoom(viewId: Int64, zoom: Double, duration: Int64?,
                           completion: @escaping (Result<Bool, Error>) -> Void)
  func moveCameraToCameraPosition(viewId: Int64, cameraPosition: CameraPositionDto) throws
  func moveCameraToLatLng(viewId: Int64, point: LatLngDto) throws
  func moveCameraToLatLngBounds(viewId: Int64, bounds: LatLngBoundsDto, padding: Double) throws
  func moveCameraToLatLngZoom(viewId: Int64, point: LatLngDto, zoom: Double) throws
  func moveCameraByScroll(viewId: Int64, scrollByDx: Double, scrollByDy: Double) throws
  func moveCameraByZoom(viewId: Int64, zoomBy: Double, focusDx: Double?, focusDy: Double?) throws
  func moveCameraToZoom(viewId: Int64, zoom: Double) throws
  func showRouteOverview(viewId: Int64) throws
  func getMinZoomPreference(viewId: Int64) throws -> Double
  func getMaxZoomPreference(viewId: Int64) throws -> Double
  func resetMinMaxZoomPreference(viewId: Int64) throws
  func setMinZoomPreference(viewId: Int64, minZoomPreference: Double) throws
  func setMaxZoomPreference(viewId: Int64, maxZoomPreference: Double) throws
  func setMyLocationButtonEnabled(viewId: Int64, enabled: Bool) throws
  func setConsumeMyLocationButtonClickEventsEnabled(viewId: Int64, enabled: Bool) throws
  func setZoomGesturesEnabled(viewId: Int64, enabled: Bool) throws
  func setZoomControlsEnabled(viewId: Int64, enabled: Bool) throws
  func setCompassEnabled(viewId: Int64, enabled: Bool) throws
  func setRotateGesturesEnabled(viewId: Int64, enabled: Bool) throws
  func setScrollGesturesEnabled(viewId: Int64, enabled: Bool) throws
  func setScrollGesturesDuringRotateOrZoomEnabled(viewId: Int64, enabled: Bool) throws
  func setTiltGesturesEnabled(viewId: Int64, enabled: Bool) throws
  func setMapToolbarEnabled(viewId: Int64, enabled: Bool) throws
  func setTrafficEnabled(viewId: Int64, enabled: Bool) throws
  func isMyLocationButtonEnabled(viewId: Int64) throws -> Bool
  func isConsumeMyLocationButtonClickEventsEnabled(viewId: Int64) throws -> Bool
  func isZoomGesturesEnabled(viewId: Int64) throws -> Bool
  func isZoomControlsEnabled(viewId: Int64) throws -> Bool
  func isCompassEnabled(viewId: Int64) throws -> Bool
  func isRotateGesturesEnabled(viewId: Int64) throws -> Bool
  func isScrollGesturesEnabled(viewId: Int64) throws -> Bool
  func isScrollGesturesEnabledDuringRotateOrZoom(viewId: Int64) throws -> Bool
  func isTiltGesturesEnabled(viewId: Int64) throws -> Bool
  func isMapToolbarEnabled(viewId: Int64) throws -> Bool
  func isTrafficEnabled(viewId: Int64) throws -> Bool
  func getMarkers(viewId: Int64) throws -> [MarkerDto]
  func addMarkers(viewId: Int64, markers: [MarkerDto]) throws -> [MarkerDto]
  func updateMarkers(viewId: Int64, markers: [MarkerDto]) throws -> [MarkerDto]
  func removeMarkers(viewId: Int64, markers: [MarkerDto]) throws
  func clearMarkers(viewId: Int64) throws
  func clear(viewId: Int64) throws
  func getPolygons(viewId: Int64) throws -> [PolygonDto]
  func addPolygons(viewId: Int64, polygons: [PolygonDto]) throws -> [PolygonDto]
  func updatePolygons(viewId: Int64, polygons: [PolygonDto]) throws -> [PolygonDto]
  func removePolygons(viewId: Int64, polygons: [PolygonDto]) throws
  func clearPolygons(viewId: Int64) throws
  func getPolylines(viewId: Int64) throws -> [PolylineDto]
  func addPolylines(viewId: Int64, polylines: [PolylineDto]) throws -> [PolylineDto]
  func updatePolylines(viewId: Int64, polylines: [PolylineDto]) throws -> [PolylineDto]
  func removePolylines(viewId: Int64, polylines: [PolylineDto]) throws
  func clearPolylines(viewId: Int64) throws
  func getCircles(viewId: Int64) throws -> [CircleDto]
  func addCircles(viewId: Int64, circles: [CircleDto]) throws -> [CircleDto]
  func updateCircles(viewId: Int64, circles: [CircleDto]) throws -> [CircleDto]
  func removeCircles(viewId: Int64, circles: [CircleDto]) throws
  func clearCircles(viewId: Int64) throws
  func registerOnCameraChangedListener(viewId: Int64) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
enum NavigationViewApiSetup {
  /// The codec used by NavigationViewApi.
  static var codec: FlutterStandardMessageCodec { NavigationViewApiCodec.shared }
  /// Sets up an instance of `NavigationViewApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: NavigationViewApi?) {
    let awaitMapReadyChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.awaitMapReady",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      awaitMapReadyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        api.awaitMapReady(viewId: viewIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      awaitMapReadyChannel.setMessageHandler(nil)
    }
    let isMyLocationEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isMyLocationEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isMyLocationEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isMyLocationEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isMyLocationEnabledChannel.setMessageHandler(nil)
    }
    let setMyLocationEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMyLocationEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setMyLocationEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setMyLocationEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMyLocationEnabledChannel.setMessageHandler(nil)
    }
    let getMyLocationChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMyLocation",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getMyLocationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.getMyLocation(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMyLocationChannel.setMessageHandler(nil)
    }
    let getMapTypeChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMapType",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getMapTypeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.getMapType(viewId: viewIdArg)
          reply(wrapResult(result.rawValue))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMapTypeChannel.setMessageHandler(nil)
    }
    let setMapTypeChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMapType",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setMapTypeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let mapTypeArg = MapTypeDto(rawValue: args[1] as! Int)!
        do {
          try api.setMapType(viewId: viewIdArg, mapType: mapTypeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMapTypeChannel.setMessageHandler(nil)
    }
    let setMapStyleChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMapStyle",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setMapStyleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let styleJsonArg = args[1] as! String
        do {
          try api.setMapStyle(viewId: viewIdArg, styleJson: styleJsonArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMapStyleChannel.setMessageHandler(nil)
    }
    let isNavigationTripProgressBarEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationTripProgressBarEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isNavigationTripProgressBarEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isNavigationTripProgressBarEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isNavigationTripProgressBarEnabledChannel.setMessageHandler(nil)
    }
    let setNavigationTripProgressBarEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationTripProgressBarEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setNavigationTripProgressBarEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setNavigationTripProgressBarEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setNavigationTripProgressBarEnabledChannel.setMessageHandler(nil)
    }
    let isNavigationHeaderEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationHeaderEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isNavigationHeaderEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isNavigationHeaderEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isNavigationHeaderEnabledChannel.setMessageHandler(nil)
    }
    let setNavigationHeaderEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationHeaderEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setNavigationHeaderEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setNavigationHeaderEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setNavigationHeaderEnabledChannel.setMessageHandler(nil)
    }
    let isNavigationFooterEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationFooterEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isNavigationFooterEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isNavigationFooterEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isNavigationFooterEnabledChannel.setMessageHandler(nil)
    }
    let setNavigationFooterEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationFooterEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setNavigationFooterEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setNavigationFooterEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setNavigationFooterEnabledChannel.setMessageHandler(nil)
    }
    let isRecenterButtonEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isRecenterButtonEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isRecenterButtonEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isRecenterButtonEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isRecenterButtonEnabledChannel.setMessageHandler(nil)
    }
    let setRecenterButtonEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setRecenterButtonEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setRecenterButtonEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setRecenterButtonEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setRecenterButtonEnabledChannel.setMessageHandler(nil)
    }
    let isSpeedLimitIconEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isSpeedLimitIconEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isSpeedLimitIconEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isSpeedLimitIconEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isSpeedLimitIconEnabledChannel.setMessageHandler(nil)
    }
    let setSpeedLimitIconEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setSpeedLimitIconEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setSpeedLimitIconEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setSpeedLimitIconEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setSpeedLimitIconEnabledChannel.setMessageHandler(nil)
    }
    let isSpeedometerEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isSpeedometerEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isSpeedometerEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isSpeedometerEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isSpeedometerEnabledChannel.setMessageHandler(nil)
    }
    let setSpeedometerEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setSpeedometerEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setSpeedometerEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setSpeedometerEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setSpeedometerEnabledChannel.setMessageHandler(nil)
    }
    let isTrafficIncidentCardsEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isTrafficIncidentCardsEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isTrafficIncidentCardsEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isTrafficIncidentCardsEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isTrafficIncidentCardsEnabledChannel.setMessageHandler(nil)
    }
    let setTrafficIncidentCardsEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setTrafficIncidentCardsEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setTrafficIncidentCardsEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setTrafficIncidentCardsEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTrafficIncidentCardsEnabledChannel.setMessageHandler(nil)
    }
    let isNavigationUIEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isNavigationUIEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isNavigationUIEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isNavigationUIEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isNavigationUIEnabledChannel.setMessageHandler(nil)
    }
    let setNavigationUIEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setNavigationUIEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setNavigationUIEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setNavigationUIEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setNavigationUIEnabledChannel.setMessageHandler(nil)
    }
    let getCameraPositionChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getCameraPosition",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getCameraPositionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.getCameraPosition(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraPositionChannel.setMessageHandler(nil)
    }
    let getVisibleRegionChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getVisibleRegion",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getVisibleRegionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.getVisibleRegion(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVisibleRegionChannel.setMessageHandler(nil)
    }
    let followMyLocationChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.followMyLocation",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      followMyLocationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let perspectiveArg = CameraPerspectiveDto(rawValue: args[1] as! Int)!
        let zoomLevelArg: Double? = nilOrValue(args[2])
        do {
          try api.followMyLocation(
            viewId: viewIdArg,
            perspective: perspectiveArg,
            zoomLevel: zoomLevelArg
          )
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      followMyLocationChannel.setMessageHandler(nil)
    }
    let animateCameraToCameraPositionChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToCameraPosition",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      animateCameraToCameraPositionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let cameraPositionArg = args[1] as! CameraPositionDto
        let durationArg: Int64? = isNullish(args[2]) ? nil :
          (args[2] is Int64? ? args[2] as! Int64? : Int64(args[2] as! Int32))
        api.animateCameraToCameraPosition(
          viewId: viewIdArg,
          cameraPosition: cameraPositionArg,
          duration: durationArg
        ) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      animateCameraToCameraPositionChannel.setMessageHandler(nil)
    }
    let animateCameraToLatLngChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToLatLng",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      animateCameraToLatLngChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let pointArg = args[1] as! LatLngDto
        let durationArg: Int64? = isNullish(args[2]) ? nil :
          (args[2] is Int64? ? args[2] as! Int64? : Int64(args[2] as! Int32))
        api
          .animateCameraToLatLng(viewId: viewIdArg, point: pointArg,
                                 duration: durationArg) { result in
            switch result {
            case let .success(res):
              reply(wrapResult(res))
            case let .failure(error):
              reply(wrapError(error))
            }
          }
      }
    } else {
      animateCameraToLatLngChannel.setMessageHandler(nil)
    }
    let animateCameraToLatLngBoundsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToLatLngBounds",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      animateCameraToLatLngBoundsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let boundsArg = args[1] as! LatLngBoundsDto
        let paddingArg = args[2] as! Double
        let durationArg: Int64? = isNullish(args[3]) ? nil :
          (args[3] is Int64? ? args[3] as! Int64? : Int64(args[3] as! Int32))
        api.animateCameraToLatLngBounds(
          viewId: viewIdArg,
          bounds: boundsArg,
          padding: paddingArg,
          duration: durationArg
        ) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      animateCameraToLatLngBoundsChannel.setMessageHandler(nil)
    }
    let animateCameraToLatLngZoomChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToLatLngZoom",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      animateCameraToLatLngZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let pointArg = args[1] as! LatLngDto
        let zoomArg = args[2] as! Double
        let durationArg: Int64? = isNullish(args[3]) ? nil :
          (args[3] is Int64? ? args[3] as! Int64? : Int64(args[3] as! Int32))
        api.animateCameraToLatLngZoom(
          viewId: viewIdArg,
          point: pointArg,
          zoom: zoomArg,
          duration: durationArg
        ) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      animateCameraToLatLngZoomChannel.setMessageHandler(nil)
    }
    let animateCameraByScrollChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraByScroll",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      animateCameraByScrollChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let scrollByDxArg = args[1] as! Double
        let scrollByDyArg = args[2] as! Double
        let durationArg: Int64? = isNullish(args[3]) ? nil :
          (args[3] is Int64? ? args[3] as! Int64? : Int64(args[3] as! Int32))
        api.animateCameraByScroll(
          viewId: viewIdArg,
          scrollByDx: scrollByDxArg,
          scrollByDy: scrollByDyArg,
          duration: durationArg
        ) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      animateCameraByScrollChannel.setMessageHandler(nil)
    }
    let animateCameraByZoomChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraByZoom",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      animateCameraByZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let zoomByArg = args[1] as! Double
        let focusDxArg: Double? = nilOrValue(args[2])
        let focusDyArg: Double? = nilOrValue(args[3])
        let durationArg: Int64? = isNullish(args[4]) ? nil :
          (args[4] is Int64? ? args[4] as! Int64? : Int64(args[4] as! Int32))
        api.animateCameraByZoom(
          viewId: viewIdArg,
          zoomBy: zoomByArg,
          focusDx: focusDxArg,
          focusDy: focusDyArg,
          duration: durationArg
        ) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      animateCameraByZoomChannel.setMessageHandler(nil)
    }
    let animateCameraToZoomChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.animateCameraToZoom",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      animateCameraToZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let zoomArg = args[1] as! Double
        let durationArg: Int64? = isNullish(args[2]) ? nil :
          (args[2] is Int64? ? args[2] as! Int64? : Int64(args[2] as! Int32))
        api.animateCameraToZoom(viewId: viewIdArg, zoom: zoomArg, duration: durationArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      animateCameraToZoomChannel.setMessageHandler(nil)
    }
    let moveCameraToCameraPositionChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToCameraPosition",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      moveCameraToCameraPositionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let cameraPositionArg = args[1] as! CameraPositionDto
        do {
          try api.moveCameraToCameraPosition(viewId: viewIdArg, cameraPosition: cameraPositionArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      moveCameraToCameraPositionChannel.setMessageHandler(nil)
    }
    let moveCameraToLatLngChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToLatLng",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      moveCameraToLatLngChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let pointArg = args[1] as! LatLngDto
        do {
          try api.moveCameraToLatLng(viewId: viewIdArg, point: pointArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      moveCameraToLatLngChannel.setMessageHandler(nil)
    }
    let moveCameraToLatLngBoundsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToLatLngBounds",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      moveCameraToLatLngBoundsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let boundsArg = args[1] as! LatLngBoundsDto
        let paddingArg = args[2] as! Double
        do {
          try api.moveCameraToLatLngBounds(
            viewId: viewIdArg,
            bounds: boundsArg,
            padding: paddingArg
          )
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      moveCameraToLatLngBoundsChannel.setMessageHandler(nil)
    }
    let moveCameraToLatLngZoomChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToLatLngZoom",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      moveCameraToLatLngZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let pointArg = args[1] as! LatLngDto
        let zoomArg = args[2] as! Double
        do {
          try api.moveCameraToLatLngZoom(viewId: viewIdArg, point: pointArg, zoom: zoomArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      moveCameraToLatLngZoomChannel.setMessageHandler(nil)
    }
    let moveCameraByScrollChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraByScroll",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      moveCameraByScrollChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let scrollByDxArg = args[1] as! Double
        let scrollByDyArg = args[2] as! Double
        do {
          try api.moveCameraByScroll(
            viewId: viewIdArg,
            scrollByDx: scrollByDxArg,
            scrollByDy: scrollByDyArg
          )
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      moveCameraByScrollChannel.setMessageHandler(nil)
    }
    let moveCameraByZoomChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraByZoom",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      moveCameraByZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let zoomByArg = args[1] as! Double
        let focusDxArg: Double? = nilOrValue(args[2])
        let focusDyArg: Double? = nilOrValue(args[3])
        do {
          try api.moveCameraByZoom(
            viewId: viewIdArg,
            zoomBy: zoomByArg,
            focusDx: focusDxArg,
            focusDy: focusDyArg
          )
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      moveCameraByZoomChannel.setMessageHandler(nil)
    }
    let moveCameraToZoomChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.moveCameraToZoom",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      moveCameraToZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let zoomArg = args[1] as! Double
        do {
          try api.moveCameraToZoom(viewId: viewIdArg, zoom: zoomArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      moveCameraToZoomChannel.setMessageHandler(nil)
    }
    let showRouteOverviewChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.showRouteOverview",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      showRouteOverviewChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.showRouteOverview(viewId: viewIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showRouteOverviewChannel.setMessageHandler(nil)
    }
    let getMinZoomPreferenceChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMinZoomPreference",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getMinZoomPreferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.getMinZoomPreference(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMinZoomPreferenceChannel.setMessageHandler(nil)
    }
    let getMaxZoomPreferenceChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMaxZoomPreference",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getMaxZoomPreferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.getMaxZoomPreference(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMaxZoomPreferenceChannel.setMessageHandler(nil)
    }
    let resetMinMaxZoomPreferenceChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.resetMinMaxZoomPreference",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      resetMinMaxZoomPreferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.resetMinMaxZoomPreference(viewId: viewIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      resetMinMaxZoomPreferenceChannel.setMessageHandler(nil)
    }
    let setMinZoomPreferenceChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMinZoomPreference",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setMinZoomPreferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let minZoomPreferenceArg = args[1] as! Double
        do {
          try api.setMinZoomPreference(viewId: viewIdArg, minZoomPreference: minZoomPreferenceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMinZoomPreferenceChannel.setMessageHandler(nil)
    }
    let setMaxZoomPreferenceChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMaxZoomPreference",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setMaxZoomPreferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let maxZoomPreferenceArg = args[1] as! Double
        do {
          try api.setMaxZoomPreference(viewId: viewIdArg, maxZoomPreference: maxZoomPreferenceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMaxZoomPreferenceChannel.setMessageHandler(nil)
    }
    let setMyLocationButtonEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMyLocationButtonEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setMyLocationButtonEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setMyLocationButtonEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMyLocationButtonEnabledChannel.setMessageHandler(nil)
    }
    let setConsumeMyLocationButtonClickEventsEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setConsumeMyLocationButtonClickEventsEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setConsumeMyLocationButtonClickEventsEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setConsumeMyLocationButtonClickEventsEnabled(
            viewId: viewIdArg,
            enabled: enabledArg
          )
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setConsumeMyLocationButtonClickEventsEnabledChannel.setMessageHandler(nil)
    }
    let setZoomGesturesEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setZoomGesturesEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setZoomGesturesEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setZoomGesturesEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setZoomGesturesEnabledChannel.setMessageHandler(nil)
    }
    let setZoomControlsEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setZoomControlsEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setZoomControlsEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setZoomControlsEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setZoomControlsEnabledChannel.setMessageHandler(nil)
    }
    let setCompassEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setCompassEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setCompassEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setCompassEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCompassEnabledChannel.setMessageHandler(nil)
    }
    let setRotateGesturesEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setRotateGesturesEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setRotateGesturesEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setRotateGesturesEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setRotateGesturesEnabledChannel.setMessageHandler(nil)
    }
    let setScrollGesturesEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setScrollGesturesEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setScrollGesturesEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setScrollGesturesEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setScrollGesturesEnabledChannel.setMessageHandler(nil)
    }
    let setScrollGesturesDuringRotateOrZoomEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setScrollGesturesDuringRotateOrZoomEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setScrollGesturesDuringRotateOrZoomEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setScrollGesturesDuringRotateOrZoomEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setScrollGesturesDuringRotateOrZoomEnabledChannel.setMessageHandler(nil)
    }
    let setTiltGesturesEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setTiltGesturesEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setTiltGesturesEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setTiltGesturesEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTiltGesturesEnabledChannel.setMessageHandler(nil)
    }
    let setMapToolbarEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setMapToolbarEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setMapToolbarEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setMapToolbarEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMapToolbarEnabledChannel.setMessageHandler(nil)
    }
    let setTrafficEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.setTrafficEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setTrafficEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setTrafficEnabled(viewId: viewIdArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTrafficEnabledChannel.setMessageHandler(nil)
    }
    let isMyLocationButtonEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isMyLocationButtonEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isMyLocationButtonEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isMyLocationButtonEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isMyLocationButtonEnabledChannel.setMessageHandler(nil)
    }
    let isConsumeMyLocationButtonClickEventsEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isConsumeMyLocationButtonClickEventsEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isConsumeMyLocationButtonClickEventsEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isConsumeMyLocationButtonClickEventsEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isConsumeMyLocationButtonClickEventsEnabledChannel.setMessageHandler(nil)
    }
    let isZoomGesturesEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isZoomGesturesEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isZoomGesturesEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isZoomGesturesEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isZoomGesturesEnabledChannel.setMessageHandler(nil)
    }
    let isZoomControlsEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isZoomControlsEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isZoomControlsEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isZoomControlsEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isZoomControlsEnabledChannel.setMessageHandler(nil)
    }
    let isCompassEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isCompassEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isCompassEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isCompassEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isCompassEnabledChannel.setMessageHandler(nil)
    }
    let isRotateGesturesEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isRotateGesturesEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isRotateGesturesEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isRotateGesturesEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isRotateGesturesEnabledChannel.setMessageHandler(nil)
    }
    let isScrollGesturesEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isScrollGesturesEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isScrollGesturesEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isScrollGesturesEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isScrollGesturesEnabledChannel.setMessageHandler(nil)
    }
    let isScrollGesturesEnabledDuringRotateOrZoomChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isScrollGesturesEnabledDuringRotateOrZoom",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isScrollGesturesEnabledDuringRotateOrZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isScrollGesturesEnabledDuringRotateOrZoom(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isScrollGesturesEnabledDuringRotateOrZoomChannel.setMessageHandler(nil)
    }
    let isTiltGesturesEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isTiltGesturesEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isTiltGesturesEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isTiltGesturesEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isTiltGesturesEnabledChannel.setMessageHandler(nil)
    }
    let isMapToolbarEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isMapToolbarEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isMapToolbarEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isMapToolbarEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isMapToolbarEnabledChannel.setMessageHandler(nil)
    }
    let isTrafficEnabledChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.isTrafficEnabled",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isTrafficEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isTrafficEnabled(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isTrafficEnabledChannel.setMessageHandler(nil)
    }
    let getMarkersChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getMarkers",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getMarkersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.getMarkers(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMarkersChannel.setMessageHandler(nil)
    }
    let addMarkersChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addMarkers",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      addMarkersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let markersArg = args[1] as! [MarkerDto]
        do {
          let result = try api.addMarkers(viewId: viewIdArg, markers: markersArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addMarkersChannel.setMessageHandler(nil)
    }
    let updateMarkersChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updateMarkers",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      updateMarkersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let markersArg = args[1] as! [MarkerDto]
        do {
          let result = try api.updateMarkers(viewId: viewIdArg, markers: markersArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateMarkersChannel.setMessageHandler(nil)
    }
    let removeMarkersChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removeMarkers",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      removeMarkersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let markersArg = args[1] as! [MarkerDto]
        do {
          try api.removeMarkers(viewId: viewIdArg, markers: markersArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeMarkersChannel.setMessageHandler(nil)
    }
    let clearMarkersChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearMarkers",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      clearMarkersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.clearMarkers(viewId: viewIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearMarkersChannel.setMessageHandler(nil)
    }
    let clearChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clear",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      clearChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.clear(viewId: viewIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearChannel.setMessageHandler(nil)
    }
    let getPolygonsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getPolygons",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getPolygonsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.getPolygons(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPolygonsChannel.setMessageHandler(nil)
    }
    let addPolygonsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addPolygons",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      addPolygonsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let polygonsArg = args[1] as! [PolygonDto]
        do {
          let result = try api.addPolygons(viewId: viewIdArg, polygons: polygonsArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addPolygonsChannel.setMessageHandler(nil)
    }
    let updatePolygonsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updatePolygons",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      updatePolygonsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let polygonsArg = args[1] as! [PolygonDto]
        do {
          let result = try api.updatePolygons(viewId: viewIdArg, polygons: polygonsArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updatePolygonsChannel.setMessageHandler(nil)
    }
    let removePolygonsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removePolygons",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      removePolygonsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let polygonsArg = args[1] as! [PolygonDto]
        do {
          try api.removePolygons(viewId: viewIdArg, polygons: polygonsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removePolygonsChannel.setMessageHandler(nil)
    }
    let clearPolygonsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearPolygons",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      clearPolygonsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.clearPolygons(viewId: viewIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearPolygonsChannel.setMessageHandler(nil)
    }
    let getPolylinesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getPolylines",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getPolylinesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.getPolylines(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPolylinesChannel.setMessageHandler(nil)
    }
    let addPolylinesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addPolylines",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      addPolylinesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let polylinesArg = args[1] as! [PolylineDto]
        do {
          let result = try api.addPolylines(viewId: viewIdArg, polylines: polylinesArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addPolylinesChannel.setMessageHandler(nil)
    }
    let updatePolylinesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updatePolylines",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      updatePolylinesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let polylinesArg = args[1] as! [PolylineDto]
        do {
          let result = try api.updatePolylines(viewId: viewIdArg, polylines: polylinesArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updatePolylinesChannel.setMessageHandler(nil)
    }
    let removePolylinesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removePolylines",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      removePolylinesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let polylinesArg = args[1] as! [PolylineDto]
        do {
          try api.removePolylines(viewId: viewIdArg, polylines: polylinesArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removePolylinesChannel.setMessageHandler(nil)
    }
    let clearPolylinesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearPolylines",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      clearPolylinesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.clearPolylines(viewId: viewIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearPolylinesChannel.setMessageHandler(nil)
    }
    let getCirclesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.getCircles",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getCirclesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.getCircles(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCirclesChannel.setMessageHandler(nil)
    }
    let addCirclesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.addCircles",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      addCirclesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let circlesArg = args[1] as! [CircleDto]
        do {
          let result = try api.addCircles(viewId: viewIdArg, circles: circlesArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addCirclesChannel.setMessageHandler(nil)
    }
    let updateCirclesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.updateCircles",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      updateCirclesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let circlesArg = args[1] as! [CircleDto]
        do {
          let result = try api.updateCircles(viewId: viewIdArg, circles: circlesArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateCirclesChannel.setMessageHandler(nil)
    }
    let removeCirclesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.removeCircles",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      removeCirclesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let circlesArg = args[1] as! [CircleDto]
        do {
          try api.removeCircles(viewId: viewIdArg, circles: circlesArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeCirclesChannel.setMessageHandler(nil)
    }
    let clearCirclesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.clearCircles",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      clearCirclesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.clearCircles(viewId: viewIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearCirclesChannel.setMessageHandler(nil)
    }
    let registerOnCameraChangedListenerChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationViewApi.registerOnCameraChangedListener",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      registerOnCameraChangedListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.registerOnCameraChangedListener(viewId: viewIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      registerOnCameraChangedListenerChannel.setMessageHandler(nil)
    }
  }
}

private class ImageRegistryApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return ImageDescriptorDto.fromList(readValue() as! [Any?])
    case 129:
      return ImageDescriptorDto.fromList(readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class ImageRegistryApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? ImageDescriptorDto {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? ImageDescriptorDto {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class ImageRegistryApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    ImageRegistryApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    ImageRegistryApiCodecWriter(data: data)
  }
}

class ImageRegistryApiCodec: FlutterStandardMessageCodec {
  static let shared = ImageRegistryApiCodec(readerWriter: ImageRegistryApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol ImageRegistryApi {
  func registerBitmapImage(imageId: String, bytes: FlutterStandardTypedData,
                           imagePixelRatio: Double, width: Double?,
                           height: Double?) throws -> ImageDescriptorDto
  func unregisterImage(imageDescriptor: ImageDescriptorDto) throws
  func getRegisteredImages() throws -> [ImageDescriptorDto]
  func clearRegisteredImages() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
enum ImageRegistryApiSetup {
  /// The codec used by ImageRegistryApi.
  static var codec: FlutterStandardMessageCodec { ImageRegistryApiCodec.shared }
  /// Sets up an instance of `ImageRegistryApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: ImageRegistryApi?) {
    let registerBitmapImageChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.registerBitmapImage",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      registerBitmapImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let imageIdArg = args[0] as! String
        let bytesArg = args[1] as! FlutterStandardTypedData
        let imagePixelRatioArg = args[2] as! Double
        let widthArg: Double? = nilOrValue(args[3])
        let heightArg: Double? = nilOrValue(args[4])
        do {
          let result = try api.registerBitmapImage(
            imageId: imageIdArg,
            bytes: bytesArg,
            imagePixelRatio: imagePixelRatioArg,
            width: widthArg,
            height: heightArg
          )
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      registerBitmapImageChannel.setMessageHandler(nil)
    }
    let unregisterImageChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.unregisterImage",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      unregisterImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let imageDescriptorArg = args[0] as! ImageDescriptorDto
        do {
          try api.unregisterImage(imageDescriptor: imageDescriptorArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      unregisterImageChannel.setMessageHandler(nil)
    }
    let getRegisteredImagesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.getRegisteredImages",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getRegisteredImagesChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getRegisteredImages()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getRegisteredImagesChannel.setMessageHandler(nil)
    }
    let clearRegisteredImagesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.ImageRegistryApi.clearRegisteredImages",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      clearRegisteredImagesChannel.setMessageHandler { _, reply in
        do {
          try api.clearRegisteredImages()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearRegisteredImagesChannel.setMessageHandler(nil)
    }
  }
}

private class NavigationViewEventApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return CameraPositionDto.fromList(readValue() as! [Any?])
    case 129:
      return LatLngDto.fromList(readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class NavigationViewEventApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CameraPositionDto {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? LatLngDto {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class NavigationViewEventApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    NavigationViewEventApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    NavigationViewEventApiCodecWriter(data: data)
  }
}

class NavigationViewEventApiCodec: FlutterStandardMessageCodec {
  static let shared =
    NavigationViewEventApiCodec(readerWriter: NavigationViewEventApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol NavigationViewEventApiProtocol {
  func onMapClickEvent(viewId viewIdArg: Int64, latLng latLngArg: LatLngDto,
                       completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onMapLongClickEvent(viewId viewIdArg: Int64, latLng latLngArg: LatLngDto,
                           completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onRecenterButtonClicked(viewId viewIdArg: Int64,
                               completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onMarkerEvent(viewId viewIdArg: Int64, markerId markerIdArg: String,
                     eventType eventTypeArg: MarkerEventTypeDto,
                     completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onMarkerDragEvent(viewId viewIdArg: Int64, markerId markerIdArg: String,
                         eventType eventTypeArg: MarkerDragEventTypeDto,
                         position positionArg: LatLngDto,
                         completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onPolygonClicked(viewId viewIdArg: Int64, polygonId polygonIdArg: String,
                        completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onPolylineClicked(viewId viewIdArg: Int64, polylineId polylineIdArg: String,
                         completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onCircleClicked(viewId viewIdArg: Int64, circleId circleIdArg: String,
                       completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onNavigationUIEnabledChanged(viewId viewIdArg: Int64,
                                    navigationUIEnabled navigationUIEnabledArg: Bool,
                                    completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onMyLocationClicked(viewId viewIdArg: Int64,
                           completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onMyLocationButtonClicked(viewId viewIdArg: Int64,
                                 completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onCameraChanged(viewId viewIdArg: Int64, eventType eventTypeArg: CameraEventTypeDto,
                       position positionArg: CameraPositionDto,
                       completion: @escaping (Result<Void, FlutterError>) -> Void)
}

class NavigationViewEventApi: NavigationViewEventApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }

  var codec: FlutterStandardMessageCodec {
    NavigationViewEventApiCodec.shared
  }

  func onMapClickEvent(viewId viewIdArg: Int64, latLng latLngArg: LatLngDto,
                       completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapClickEvent"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([viewIdArg, latLngArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onMapLongClickEvent(viewId viewIdArg: Int64, latLng latLngArg: LatLngDto,
                           completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMapLongClickEvent"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([viewIdArg, latLngArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onRecenterButtonClicked(viewId viewIdArg: Int64,
                               completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onRecenterButtonClicked"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([viewIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onMarkerEvent(viewId viewIdArg: Int64, markerId markerIdArg: String,
                     eventType eventTypeArg: MarkerEventTypeDto,
                     completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerEvent"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([viewIdArg, markerIdArg, eventTypeArg.rawValue] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onMarkerDragEvent(viewId viewIdArg: Int64, markerId markerIdArg: String,
                         eventType eventTypeArg: MarkerDragEventTypeDto,
                         position positionArg: LatLngDto,
                         completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMarkerDragEvent"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel
      .sendMessage([viewIdArg, markerIdArg, eventTypeArg.rawValue,
                    positionArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(FlutterError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
  }

  func onPolygonClicked(viewId viewIdArg: Int64, polygonId polygonIdArg: String,
                        completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolygonClicked"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([viewIdArg, polygonIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onPolylineClicked(viewId viewIdArg: Int64, polylineId polylineIdArg: String,
                         completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onPolylineClicked"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([viewIdArg, polylineIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCircleClicked(viewId viewIdArg: Int64, circleId circleIdArg: String,
                       completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCircleClicked"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([viewIdArg, circleIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onNavigationUIEnabledChanged(viewId viewIdArg: Int64,
                                    navigationUIEnabled navigationUIEnabledArg: Bool,
                                    completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onNavigationUIEnabledChanged"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([viewIdArg, navigationUIEnabledArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onMyLocationClicked(viewId viewIdArg: Int64,
                           completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMyLocationClicked"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([viewIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onMyLocationButtonClicked(viewId viewIdArg: Int64,
                                 completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onMyLocationButtonClicked"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([viewIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCameraChanged(viewId viewIdArg: Int64, eventType eventTypeArg: CameraEventTypeDto,
                       position positionArg: CameraPositionDto,
                       completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationViewEventApi.onCameraChanged"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([viewIdArg, eventTypeArg.rawValue, positionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}

private class NavigationSessionApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return DestinationsDto.fromList(readValue() as! [Any?])
    case 129:
      return LatLngDto.fromList(readValue() as! [Any?])
    case 130:
      return LatLngDto.fromList(readValue() as! [Any?])
    case 131:
      return NavigationAudioGuidanceSettingsDto.fromList(readValue() as! [Any?])
    case 132:
      return NavigationDisplayOptionsDto.fromList(readValue() as! [Any?])
    case 133:
      return NavigationTimeAndDistanceDto.fromList(readValue() as! [Any?])
    case 134:
      return NavigationWaypointDto.fromList(readValue() as! [Any?])
    case 135:
      return NavigationWaypointDto.fromList(readValue() as! [Any?])
    case 136:
      return RouteSegmentDto.fromList(readValue() as! [Any?])
    case 137:
      return RouteSegmentDto.fromList(readValue() as! [Any?])
    case 138:
      return RouteSegmentTrafficDataDto.fromList(readValue() as! [Any?])
    case 139:
      return RouteSegmentTrafficDataRoadStretchRenderingDataDto.fromList(readValue() as! [Any?])
    case 140:
      return RouteTokenOptionsDto.fromList(readValue() as! [Any?])
    case 141:
      return RoutingOptionsDto.fromList(readValue() as! [Any?])
    case 142:
      return SimulationOptionsDto.fromList(readValue() as! [Any?])
    case 143:
      return SpeedAlertOptionsDto.fromList(readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class NavigationSessionApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? DestinationsDto {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? LatLngDto {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? LatLngDto {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? NavigationAudioGuidanceSettingsDto {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? NavigationDisplayOptionsDto {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? NavigationTimeAndDistanceDto {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? NavigationWaypointDto {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? NavigationWaypointDto {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? RouteSegmentDto {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? RouteSegmentDto {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? RouteSegmentTrafficDataDto {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? RouteSegmentTrafficDataRoadStretchRenderingDataDto {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? RouteTokenOptionsDto {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? RoutingOptionsDto {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? SimulationOptionsDto {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? SpeedAlertOptionsDto {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class NavigationSessionApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    NavigationSessionApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    NavigationSessionApiCodecWriter(data: data)
  }
}

class NavigationSessionApiCodec: FlutterStandardMessageCodec {
  static let shared =
    NavigationSessionApiCodec(readerWriter: NavigationSessionApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol NavigationSessionApi {
  /// General.
  func createNavigationSession(abnormalTerminationReportingEnabled: Bool,
                               completion: @escaping (Result<Void, Error>) -> Void)
  func isInitialized() throws -> Bool
  func cleanup() throws
  func showTermsAndConditionsDialog(title: String, companyName: String,
                                    shouldOnlyShowDriverAwarenessDisclaimer: Bool,
                                    completion: @escaping (Result<Bool, Error>) -> Void)
  func areTermsAccepted() throws -> Bool
  func resetTermsAccepted() throws
  func getNavSDKVersion() throws -> String
  /// Navigation.
  func isGuidanceRunning() throws -> Bool
  func startGuidance() throws
  func stopGuidance() throws
  func setDestinations(destinations: DestinationsDto,
                       completion: @escaping (Result<RouteStatusDto, Error>) -> Void)
  func clearDestinations() throws
  func continueToNextDestination() throws -> NavigationWaypointDto?
  func getCurrentTimeAndDistance() throws -> NavigationTimeAndDistanceDto
  func setAudioGuidance(settings: NavigationAudioGuidanceSettingsDto) throws
  func setSpeedAlertOptions(options: SpeedAlertOptionsDto) throws
  func getRouteSegments() throws -> [RouteSegmentDto]
  func getTraveledRoute() throws -> [LatLngDto]
  func getCurrentRouteSegment() throws -> RouteSegmentDto?
  /// Simulation
  func setUserLocation(location: LatLngDto) throws
  func removeUserLocation() throws
  func simulateLocationsAlongExistingRoute() throws
  func simulateLocationsAlongExistingRouteWithOptions(options: SimulationOptionsDto) throws
  func simulateLocationsAlongNewRoute(waypoints: [NavigationWaypointDto],
                                      completion: @escaping (Result<RouteStatusDto, Error>) -> Void)
  func simulateLocationsAlongNewRouteWithRoutingOptions(waypoints: [NavigationWaypointDto],
                                                        routingOptions: RoutingOptionsDto,
                                                        completion: @escaping (Result<
                                                          RouteStatusDto,
                                                          Error
                                                        >) -> Void)
  func simulateLocationsAlongNewRouteWithRoutingAndSimulationOptions(waypoints: [
    NavigationWaypointDto
  ],
  routingOptions: RoutingOptionsDto,
  simulationOptions: SimulationOptionsDto,
  completion: @escaping (Result<
    RouteStatusDto,
    Error
  >) -> Void)
  func pauseSimulation() throws
  func resumeSimulation() throws
  /// Simulation (iOS only)
  func allowBackgroundLocationUpdates(allow: Bool) throws
  /// Road snapped location updates.
  func enableRoadSnappedLocationUpdates() throws
  func disableRoadSnappedLocationUpdates() throws
  /// Enable Turn-by-Turn navigation events.
  func enableTurnByTurnNavigationEvents(numNextStepsToPreview: Int64?) throws
  func disableTurnByTurnNavigationEvents() throws
  func registerRemainingTimeOrDistanceChangedListener(remainingTimeThresholdSeconds: Int64,
                                                      remainingDistanceThresholdMeters: Int64) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
enum NavigationSessionApiSetup {
  /// The codec used by NavigationSessionApi.
  static var codec: FlutterStandardMessageCodec { NavigationSessionApiCodec.shared }
  /// Sets up an instance of `NavigationSessionApi` to handle messages through the
  /// `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: NavigationSessionApi?) {
    /// General.
    let createNavigationSessionChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.createNavigationSession",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      createNavigationSessionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let abnormalTerminationReportingEnabledArg = args[0] as! Bool
        api
          .createNavigationSession(
            abnormalTerminationReportingEnabled: abnormalTerminationReportingEnabledArg
          ) { result in
            switch result {
            case .success:
              reply(wrapResult(nil))
            case let .failure(error):
              reply(wrapError(error))
            }
          }
      }
    } else {
      createNavigationSessionChannel.setMessageHandler(nil)
    }
    let isInitializedChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.isInitialized",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isInitializedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isInitialized()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isInitializedChannel.setMessageHandler(nil)
    }
    let cleanupChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.cleanup",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      cleanupChannel.setMessageHandler { _, reply in
        do {
          try api.cleanup()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cleanupChannel.setMessageHandler(nil)
    }
    let showTermsAndConditionsDialogChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.showTermsAndConditionsDialog",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      showTermsAndConditionsDialogChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let titleArg = args[0] as! String
        let companyNameArg = args[1] as! String
        let shouldOnlyShowDriverAwarenessDisclaimerArg = args[2] as! Bool
        api.showTermsAndConditionsDialog(
          title: titleArg,
          companyName: companyNameArg,
          shouldOnlyShowDriverAwarenessDisclaimer: shouldOnlyShowDriverAwarenessDisclaimerArg
        ) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      showTermsAndConditionsDialogChannel.setMessageHandler(nil)
    }
    let areTermsAcceptedChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.areTermsAccepted",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      areTermsAcceptedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.areTermsAccepted()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      areTermsAcceptedChannel.setMessageHandler(nil)
    }
    let resetTermsAcceptedChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.resetTermsAccepted",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      resetTermsAcceptedChannel.setMessageHandler { _, reply in
        do {
          try api.resetTermsAccepted()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      resetTermsAcceptedChannel.setMessageHandler(nil)
    }
    let getNavSDKVersionChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getNavSDKVersion",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getNavSDKVersionChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getNavSDKVersion()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getNavSDKVersionChannel.setMessageHandler(nil)
    }
    /// Navigation.
    let isGuidanceRunningChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.isGuidanceRunning",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      isGuidanceRunningChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isGuidanceRunning()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isGuidanceRunningChannel.setMessageHandler(nil)
    }
    let startGuidanceChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.startGuidance",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      startGuidanceChannel.setMessageHandler { _, reply in
        do {
          try api.startGuidance()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startGuidanceChannel.setMessageHandler(nil)
    }
    let stopGuidanceChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.stopGuidance",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      stopGuidanceChannel.setMessageHandler { _, reply in
        do {
          try api.stopGuidance()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopGuidanceChannel.setMessageHandler(nil)
    }
    let setDestinationsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setDestinations",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setDestinationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let destinationsArg = args[0] as! DestinationsDto
        api.setDestinations(destinations: destinationsArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res.rawValue))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setDestinationsChannel.setMessageHandler(nil)
    }
    let clearDestinationsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.clearDestinations",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      clearDestinationsChannel.setMessageHandler { _, reply in
        do {
          try api.clearDestinations()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearDestinationsChannel.setMessageHandler(nil)
    }
    let continueToNextDestinationChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.continueToNextDestination",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      continueToNextDestinationChannel.setMessageHandler { _, reply in
        do {
          let result = try api.continueToNextDestination()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      continueToNextDestinationChannel.setMessageHandler(nil)
    }
    let getCurrentTimeAndDistanceChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getCurrentTimeAndDistance",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getCurrentTimeAndDistanceChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getCurrentTimeAndDistance()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCurrentTimeAndDistanceChannel.setMessageHandler(nil)
    }
    let setAudioGuidanceChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setAudioGuidance",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setAudioGuidanceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! NavigationAudioGuidanceSettingsDto
        do {
          try api.setAudioGuidance(settings: settingsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAudioGuidanceChannel.setMessageHandler(nil)
    }
    let setSpeedAlertOptionsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setSpeedAlertOptions",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setSpeedAlertOptionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! SpeedAlertOptionsDto
        do {
          try api.setSpeedAlertOptions(options: optionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setSpeedAlertOptionsChannel.setMessageHandler(nil)
    }
    let getRouteSegmentsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getRouteSegments",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getRouteSegmentsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getRouteSegments()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getRouteSegmentsChannel.setMessageHandler(nil)
    }
    let getTraveledRouteChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getTraveledRoute",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getTraveledRouteChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getTraveledRoute()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTraveledRouteChannel.setMessageHandler(nil)
    }
    let getCurrentRouteSegmentChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.getCurrentRouteSegment",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getCurrentRouteSegmentChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getCurrentRouteSegment()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCurrentRouteSegmentChannel.setMessageHandler(nil)
    }
    /// Simulation
    let setUserLocationChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.setUserLocation",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setUserLocationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let locationArg = args[0] as! LatLngDto
        do {
          try api.setUserLocation(location: locationArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setUserLocationChannel.setMessageHandler(nil)
    }
    let removeUserLocationChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.removeUserLocation",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      removeUserLocationChannel.setMessageHandler { _, reply in
        do {
          try api.removeUserLocation()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeUserLocationChannel.setMessageHandler(nil)
    }
    let simulateLocationsAlongExistingRouteChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongExistingRoute",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      simulateLocationsAlongExistingRouteChannel.setMessageHandler { _, reply in
        do {
          try api.simulateLocationsAlongExistingRoute()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      simulateLocationsAlongExistingRouteChannel.setMessageHandler(nil)
    }
    let simulateLocationsAlongExistingRouteWithOptionsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongExistingRouteWithOptions",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      simulateLocationsAlongExistingRouteWithOptionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! SimulationOptionsDto
        do {
          try api.simulateLocationsAlongExistingRouteWithOptions(options: optionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      simulateLocationsAlongExistingRouteWithOptionsChannel.setMessageHandler(nil)
    }
    let simulateLocationsAlongNewRouteChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongNewRoute",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      simulateLocationsAlongNewRouteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let waypointsArg = args[0] as! [NavigationWaypointDto]
        api.simulateLocationsAlongNewRoute(waypoints: waypointsArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res.rawValue))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      simulateLocationsAlongNewRouteChannel.setMessageHandler(nil)
    }
    let simulateLocationsAlongNewRouteWithRoutingOptionsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongNewRouteWithRoutingOptions",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      simulateLocationsAlongNewRouteWithRoutingOptionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let waypointsArg = args[0] as! [NavigationWaypointDto]
        let routingOptionsArg = args[1] as! RoutingOptionsDto
        api.simulateLocationsAlongNewRouteWithRoutingOptions(
          waypoints: waypointsArg,
          routingOptions: routingOptionsArg
        ) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res.rawValue))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      simulateLocationsAlongNewRouteWithRoutingOptionsChannel.setMessageHandler(nil)
    }
    let simulateLocationsAlongNewRouteWithRoutingAndSimulationOptionsChannel =
      FlutterBasicMessageChannel(
        name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.simulateLocationsAlongNewRouteWithRoutingAndSimulationOptions",
        binaryMessenger: binaryMessenger,
        codec: codec
      )
    if let api {
      simulateLocationsAlongNewRouteWithRoutingAndSimulationOptionsChannel
        .setMessageHandler { message, reply in
          let args = message as! [Any?]
          let waypointsArg = args[0] as! [NavigationWaypointDto]
          let routingOptionsArg = args[1] as! RoutingOptionsDto
          let simulationOptionsArg = args[2] as! SimulationOptionsDto
          api.simulateLocationsAlongNewRouteWithRoutingAndSimulationOptions(
            waypoints: waypointsArg,
            routingOptions: routingOptionsArg,
            simulationOptions: simulationOptionsArg
          ) { result in
            switch result {
            case let .success(res):
              reply(wrapResult(res.rawValue))
            case let .failure(error):
              reply(wrapError(error))
            }
          }
        }
    } else {
      simulateLocationsAlongNewRouteWithRoutingAndSimulationOptionsChannel.setMessageHandler(nil)
    }
    let pauseSimulationChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.pauseSimulation",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      pauseSimulationChannel.setMessageHandler { _, reply in
        do {
          try api.pauseSimulation()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseSimulationChannel.setMessageHandler(nil)
    }
    let resumeSimulationChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.resumeSimulation",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      resumeSimulationChannel.setMessageHandler { _, reply in
        do {
          try api.resumeSimulation()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      resumeSimulationChannel.setMessageHandler(nil)
    }
    /// Simulation (iOS only)
    let allowBackgroundLocationUpdatesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.allowBackgroundLocationUpdates",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      allowBackgroundLocationUpdatesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let allowArg = args[0] as! Bool
        do {
          try api.allowBackgroundLocationUpdates(allow: allowArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      allowBackgroundLocationUpdatesChannel.setMessageHandler(nil)
    }
    /// Road snapped location updates.
    let enableRoadSnappedLocationUpdatesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.enableRoadSnappedLocationUpdates",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      enableRoadSnappedLocationUpdatesChannel.setMessageHandler { _, reply in
        do {
          try api.enableRoadSnappedLocationUpdates()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      enableRoadSnappedLocationUpdatesChannel.setMessageHandler(nil)
    }
    let disableRoadSnappedLocationUpdatesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.disableRoadSnappedLocationUpdates",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      disableRoadSnappedLocationUpdatesChannel.setMessageHandler { _, reply in
        do {
          try api.disableRoadSnappedLocationUpdates()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      disableRoadSnappedLocationUpdatesChannel.setMessageHandler(nil)
    }
    /// Enable Turn-by-Turn navigation events.
    let enableTurnByTurnNavigationEventsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.enableTurnByTurnNavigationEvents",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      enableTurnByTurnNavigationEventsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let numNextStepsToPreviewArg: Int64? = isNullish(args[0]) ? nil :
          (args[0] is Int64? ? args[0] as! Int64? : Int64(args[0] as! Int32))
        do {
          try api.enableTurnByTurnNavigationEvents(numNextStepsToPreview: numNextStepsToPreviewArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      enableTurnByTurnNavigationEventsChannel.setMessageHandler(nil)
    }
    let disableTurnByTurnNavigationEventsChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.disableTurnByTurnNavigationEvents",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      disableTurnByTurnNavigationEventsChannel.setMessageHandler { _, reply in
        do {
          try api.disableTurnByTurnNavigationEvents()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      disableTurnByTurnNavigationEventsChannel.setMessageHandler(nil)
    }
    let registerRemainingTimeOrDistanceChangedListenerChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationSessionApi.registerRemainingTimeOrDistanceChangedListener",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      registerRemainingTimeOrDistanceChangedListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let remainingTimeThresholdSecondsArg = args[0] is Int64 ? args[0] as! Int64 :
          Int64(args[0] as! Int32)
        let remainingDistanceThresholdMetersArg = args[1] is Int64 ? args[1] as! Int64 :
          Int64(args[1] as! Int32)
        do {
          try api.registerRemainingTimeOrDistanceChangedListener(
            remainingTimeThresholdSeconds: remainingTimeThresholdSecondsArg,
            remainingDistanceThresholdMeters: remainingDistanceThresholdMetersArg
          )
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      registerRemainingTimeOrDistanceChangedListenerChannel.setMessageHandler(nil)
    }
  }
}

private class NavigationSessionEventApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return LaneDirectionDto.fromList(readValue() as! [Any?])
    case 129:
      return LaneDto.fromList(readValue() as! [Any?])
    case 130:
      return LatLngDto.fromList(readValue() as! [Any?])
    case 131:
      return NavInfoDto.fromList(readValue() as! [Any?])
    case 132:
      return NavigationWaypointDto.fromList(readValue() as! [Any?])
    case 133:
      return SpeedingUpdatedEventDto.fromList(readValue() as! [Any?])
    case 134:
      return StepInfoDto.fromList(readValue() as! [Any?])
    case 135:
      return StepInfoDto.fromList(readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class NavigationSessionEventApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? LaneDirectionDto {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? LaneDto {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? LatLngDto {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? NavInfoDto {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? NavigationWaypointDto {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? SpeedingUpdatedEventDto {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? StepInfoDto {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? StepInfoDto {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class NavigationSessionEventApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    NavigationSessionEventApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    NavigationSessionEventApiCodecWriter(data: data)
  }
}

class NavigationSessionEventApiCodec: FlutterStandardMessageCodec {
  static let shared =
    NavigationSessionEventApiCodec(readerWriter: NavigationSessionEventApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol NavigationSessionEventApiProtocol {
  func onSpeedingUpdated(msg msgArg: SpeedingUpdatedEventDto,
                         completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onRoadSnappedLocationUpdated(location locationArg: LatLngDto,
                                    completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onRoadSnappedRawLocationUpdated(location locationArg: LatLngDto,
                                       completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onArrival(waypoint waypointArg: NavigationWaypointDto,
                 completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onRouteChanged(completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onRemainingTimeOrDistanceChanged(remainingTime remainingTimeArg: Double,
                                        remainingDistance remainingDistanceArg: Double,
                                        completion: @escaping (Result<Void, FlutterError>) -> Void)
  /// Android-only event.
  func onTrafficUpdated(completion: @escaping (Result<Void, FlutterError>) -> Void)
  /// Android-only event.
  func onRerouting(completion: @escaping (Result<Void, FlutterError>) -> Void)
  /// Android-only event.
  func onGpsAvailabilityUpdate(available availableArg: Bool,
                               completion: @escaping (Result<Void, FlutterError>) -> Void)
  /// Turn-by-Turn navigation events.
  func onNavInfo(navInfo navInfoArg: NavInfoDto,
                 completion: @escaping (Result<Void, FlutterError>) -> Void)
}

class NavigationSessionEventApi: NavigationSessionEventApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }

  var codec: FlutterStandardMessageCodec {
    NavigationSessionEventApiCodec.shared
  }

  func onSpeedingUpdated(msg msgArg: SpeedingUpdatedEventDto,
                         completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onSpeedingUpdated"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([msgArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onRoadSnappedLocationUpdated(location locationArg: LatLngDto,
                                    completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRoadSnappedLocationUpdated"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([locationArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onRoadSnappedRawLocationUpdated(location locationArg: LatLngDto,
                                       completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRoadSnappedRawLocationUpdated"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([locationArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onArrival(waypoint waypointArg: NavigationWaypointDto,
                 completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onArrival"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([waypointArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onRouteChanged(completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRouteChanged"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onRemainingTimeOrDistanceChanged(remainingTime remainingTimeArg: Double,
                                        remainingDistance remainingDistanceArg: Double,
                                        completion: @escaping (Result<Void, FlutterError>)
                                          -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRemainingTimeOrDistanceChanged"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([remainingTimeArg, remainingDistanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  /// Android-only event.
  func onTrafficUpdated(completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onTrafficUpdated"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  /// Android-only event.
  func onRerouting(completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onRerouting"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  /// Android-only event.
  func onGpsAvailabilityUpdate(available availableArg: Bool,
                               completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onGpsAvailabilityUpdate"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([availableArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  /// Turn-by-Turn navigation events.
  func onNavInfo(navInfo navInfoArg: NavInfoDto,
                 completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName =
      "dev.flutter.pigeon.google_maps_navigation.NavigationSessionEventApi.onNavInfo"
    let channel = FlutterBasicMessageChannel(
      name: channelName,
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    channel.sendMessage([navInfoArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol NavigationInspector {
  func isViewAttachedToSession(viewId: Int64) throws -> Bool
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
enum NavigationInspectorSetup {
  /// The codec used by NavigationInspector.
  /// Sets up an instance of `NavigationInspector` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: NavigationInspector?) {
    let isViewAttachedToSessionChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.google_maps_navigation.NavigationInspector.isViewAttachedToSession",
      binaryMessenger: binaryMessenger
    )
    if let api {
      isViewAttachedToSessionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.isViewAttachedToSession(viewId: viewIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isViewAttachedToSessionChannel.setMessageHandler(nil)
    }
  }
}
